<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wi-Fi Minesweeper</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/noisejs@2.1.0/index.min.js"></script>


<script src="riffwave.js"></script>
<script src="sfxr.js"></script>
<script src="config.js"></script> <!-- LOCAL=true on public, false on my pc config -->

<script>
//////////////////////////////////////////////
//
//  force to public server here for quick testing:
//
//window.APP_CONFIG.LOCAL = false; // this is true on my pc by default. on release version false.
</script>




<!--
todo: 
- tee mappieditori jossa voi piirtää pelialueen lisäämällä mustia ruutuja johon ei voi pelissä klikata.
  - lisää myös ominaisuus joka tallentaa oman selaimen muistiin omat mapit uudelleenkäyttöä varten.
- lisää tallennettuja ennaltaluotuja perusmappeja eri muodoilla.



- jatka: console.warn(`id:${player.id} ==? peerid:${peer} - quitted: ${player.quitted}`);
  timed out chat viestit eivät mene läpi mutta kyllä loggaa ne.
 - timeout ei ehkä toimi kunnolla, spämmäsi joskus sitä viestiä. kokeilin korjata player.quitted arvolla ettei yritä poistaa uudestaan.
 
- jos hosti quittaa niin ilmoita pelaajille: tee jokin pingi hostia varten myös.


- lisää mahdollisuus valita oma väri ennen aloitusta. huom: tsekkaa ettei väri ole jo käytössä.
- lisää valinta pelin alussa että pelaaja voi valita kumman pommin haluaa.
  revealBombAirplaneZeros()
- lisää poistonappi pelaajille. varsinkin ai:lle jos vahingossa laittaa.


- korjaa suuntima: peittyy chätin ym alle.
  - tee canvas pienemmäksi jotenkin. yritin mutta vääntyy kuvasuhde...

- tee lipuista heiluva animaatio rotaatiolla.
- anna pelaajan valita oman pommin tyyli pelin alussa.

- lisää range näkymä pommille että tietää mihin asti se osuu.
- tee tekoäly niin että se käy läpi vain merkitsevät ruudut eikä koko mappia jotta se on nopeampi isoilla mapeilla.
- renderöi webgl:llä nopeuttaakseen renderöintiä.
- lisää nappi valikkoa varten mistä voi esim katsoa pelihistoriaa ja tallennettuja edellisiä pelejä ja toistaa ne uudestaan. 
  lisää myös pomminapit ym.
- lisää nappi pommin käytölle ja pommituksen tyylin valinta ennen peliä. tai sitten myös peliin.


- muokkaa warning äänen logiikkaa niin että se varoittaa kun vihollinen tarvitsee voittaakseen enää 6 tai alle miinoja?



- tee sieniversio missä vältellään tappavan myrkyllisiä sieniä. siinä voisi kävellä metsässä ja kokeilla "kaivaa" jolloin se kertoo kuinka monta myrkkysientä on lähellä. tai sit niin että etitään kaikkia sieniä, mutta pitää osata välttää myrkkysieniä, ja sit puuston ja maaston perusteella voi mennä löytämään tiettyjä sieniä. ja sit pitää tehä ruokaa niistä että jaksaa etsiä lisää sieniä.







-->
<style>
@font-face {
    font-family: 'Nimbus Sans L';
    src: url('fonts/NimbusSanL-Reg.woff2') format('woff2'),
        url('fonts/NimbusSanL-Reg.woff') format('woff'),
        url('fonts/NimbusSanL-Reg.ttf') format('truetype');
    font-weight: 400; /*normal*/
    font-style: normal;
    font-display: swap;
}
@font-face {
    font-family: 'Nimbus Sans L';
    src: url('fonts/NimbusSanL-Bol.woff2') format('woff2'),
        url('fonts/NimbusSanL-Bol.woff') format('woff'),
        url('fonts/NimbusSanL-Bol.ttf') format('truetype');
    font-weight: 700; /*bold*/
    font-style: normal;
    font-display: swap;
}


/* --- START: Added Loader CSS --- */

#loader-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
	background-color: rgba(0,0,0, 0.6);
    display: none;
	flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.loader-spinner {
	border: 8px solid #0a0d0a; 
	border-top: 8px solid #0a84ff; 
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}



/* --- END: Added Loader CSS --- */

</style>
<style>
:root {
	--bg-color: #121212;
	--surface-color: #1e1e1e;
	--primary-text: #e0e0e0;
	--secondary-text: #a0a0a0;
	--border-color: #333;
	--accent-color: #03dac6;
	--grid-line-color: #444;
	--win-line-color: #ffeb3b;
}

* {
	box-sizing: border-box;
	-webkit-tap-highlight-color: transparent;
}

body {
	background-color: var(--bg-color);
	color: var(--primary-text);
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
	margin: 0;
	padding: 0;
	----overflow: hidden;
	display: flex;
	justify-content: center;
	align-items: center;
	----height: 100vh;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

.screen {
	display: none;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	width: 100%;
	max-width: 400px;
	padding: 20px;
	text-align: center;
}

.screen.active {
  display: flex;

  flex-direction: column;
  align-items: center;
  justify-content: flex-start; /* instead of center */
  min-height: 100vh;
  overflow-y: auto;

}


h1, h2 {
	margin-top: 0;
	font-weight: 500;
}

.input-group {
	width: 100%;
	margin-bottom: 15px;
}

input[type="text"], input[type="number"], select {
	width: 100%;
	padding: 12px;
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: 8px;
	color: var(--primary-text);
	font-size: 16px;
}

input::placeholder {
	color: var(--secondary-text);
}

button {
	width: 100%;
	padding: 14px;
	border: none;
	border-radius: 8px;
	background-color: var(--accent-color);
	color: #000;
	font-size: 18px;
	font-weight: bold;
	cursor: pointer;
	transition: background-color 0.2s;
}

button:disabled {
	background-color: #555;
	color: #888;
	cursor: not-allowed;
}

button.secondary {
	background-color: var(--surface-color);
	color: var(--accent-color);
	border: 1px solid var(--accent-color);
}

.symbol-select-group {
	display: flex;
	align-items: center;
	gap: 10px;
	width: 100%;
}

#symbol-select {
	flex-grow: 1;
}

#custom-symbol-input {
	width: 80px;
	text-align: center;
	font-size: 20px;
}

#player-list {
	list-style: none;
	padding: 0;
	width: 100%;
	margin-top: 20px;
	max-height: 150px;
	min-height:150px;
	overflow-y: auto;
}

#player-list li {
	background-color: var(--surface-color);
	padding: 10px;
	border-radius: 5px;
	margin-bottom: 5px;
	font-size: 18px;
}

#game-screen {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	display: none; /* Managed by JS */
	flex-direction: column;
}

#game-canvas {
	touch-action: none; /* Disables default browser gestures */
	background-color: #000;
	width: 100%;
	height: 100%;
	---position:absolute;
	---top:77px;
}

#game-info {
	position: absolute;
	display:flex;
	align-items: center; 
	top: 0;
	left: 0;
	width: 100%;

	font-size: 1.2em;
	color: white;
	pointer-events: none; /* Clicks go through it */
	z-index: 10;
}

#infopadding {
	width:100px;
}

#game-status {
  flex: 1;               /* take all remaining horizontal space */
  text-align:right;
  padding-right:10px;
  
    height: 37px;
}

#bomb-button {
    width: 40px;
    height: 33px;
    padding: 0;
    margin: 0;
	background: green;
	border: none;
	cursor: pointer;
	display:none;
}

#bomb-button img {
    width: 25px;
}

#chat {
	position: absolute;
	top: 0;
	left: 0;             /* start from the left edge */
	right: 0;            /* stretch to the right edge */
	display: flex;
	/*gap: 5px;*/
	align-items: center;  /* vertically center children */

	box-sizing: border-box; /* include padding in width */
}

#chatMessages {
	flex: 1;               /* takes all remaining space */
	border: 1px solid #888;
	border-left:0;
	border-top:0;
	padding: 5px;
	overflow: hidden;
	/*white-space: nowrap;*/
		
	white-space: normal;     /* allow line breaks */
	word-break: break-word;  /* break long words if needed */
	overflow-wrap: anywhere; /* modern way to force wrapping */

	/*text-overflow: ellipsis;*/
	height:71px;
	padding-top:71px;
	background-color: rgba(0, 0, 0, 0.8);
	overflow-x: hidden;           /* prevent horizontal scroll */
	overflow-y: auto;         /* enable vertical scrolling */
	scrollbar-width: none;    /* hide scrollbar in Firefox */
	
	position: relative;   /* must be positioned for z-index to work */
	top:0;
	z-index: 1;           /* normal */
	outline: none;        /* remove blue focus outline if you don’t want it */
	font-size:11px;
}
#chatMessages:focus {
	z-index: 9999;        /* bring on top when focused */
	border-color:white;
}

#chatMessages::-webkit-scrollbar {
	display: none;            /* hide scrollbar in Chrome/Safari/Edge */
}



#game-state-list {
	width: 100px;
	border: 1px solid #888;
	border-left:0;
	border-top:0;
	padding-left: 5px;
	overflow: hidden;
	/*white-space: nowrap;*/
		
	white-space: normal;     /* allow line breaks */
	word-break: break-word;  /* break long words if needed */
	overflow-wrap: anywhere; /* modern way to force wrapping */

	/*text-overflow: ellipsis;*/
	height:76px;
	/*padding-top:71px;*/
	background-color: rgba(0, 0, 0, 0.8);
	overflow-x: hidden;           /* prevent horizontal scroll */
	overflow-y: auto;         /* enable vertical scrolling */
	scrollbar-width: none;    /* hide scrollbar in Firefox */
	
	position: relative;   /* must be positioned for z-index to work */
	top:0;
	z-index: 1;           /* normal */
	outline: none;        /* remove blue focus outline if you don’t want it */
	
	font-size:11px;
}
#game-state-list:focus {
	z-index: 9999;        /* bring on top when focused */
	border-color:white;
}

#game-state-list::-webkit-scrollbar {
	display: none;            /* hide scrollbar in Chrome/Safari/Edge */
}


.focusedPlayer {
	border-bottom:1px dashed;
}

#chatInput {
	width: 65px;           /* fixed sizes */
	position: relative;
	top: 18px;
	border-radius:0;
	height: 39px;
	padding-left: 3px;
	padding-right: 3px;
	font-size:11px;
}

#chatSend {
	width: 56px;           /* fixed width */
	position: relative;
	top: 18px;
	border-radius:0;
	height: 39px;
	padding:0;
}


.my-turn {
	background-color: rgba(0,0,255,0.3);
}
.opponent-turn {
	background-color: rgba(255,0,0,0.3);
}


/*howtoplay-btn*/
.infobutton {
    background-color: #468627;
    width: 150px;
    margin-bottom: 10px;
}

.aibutton {
    background-color: #4686FF;
    width: 63px;
    margin-top: 0px;
	----margin-bottom:20px;
}



  
 /* Overlay background */
  .modal {
    display: none; /* hidden by default */
    position: fixed;
    z-index: 1000;
    left: 0; top: 0;
    width: 100%; height: 100%;
    background-color: rgba(0,0,0,0.8);
  }

  /* Centered box */
  .modal-content {
    background: #000;
    margin: 5% auto;
    padding: 20px;
    width: 100%;
    max-height: 100%;        /* limit height */
    border-radius: 20px;
	border:1px solid yellow;
    overflow-y: auto;       /* scrollbar if content is too tall */
  }

  .close {
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    position: relative;
    top: -13px;
  }

  .instructions {
    line-height: 1.5;
  }
  
  
</style>
	
	
	






<style>
/*
  body { 
    font-family: sans-serif; 
    margin: 20px; 
    background: #121212; 
    color: #eee;
  }
  select, input { 
    font-size: 16px; 
    padding: 5px; 
    background: #1e1e1e;
    color: #eee;
    border: 1px solid #555;
  }
  */
  
  #emojiView {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #1a1a1a;
    overflow-y: auto;
    display: none;
    padding: 5px;
    box-sizing: border-box;
    z-index: 1000;
    color: #eee;
    padding-top: 65px;
  }
#emojiGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, 50px);
  gap: 0;
}

.emojiSquare {
  width: 50px;
  height: 50px;
  outline: 1px solid #555; /* outline doesn’t double up */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;
  cursor: pointer;
  background: #222;
  color: #eee;
}
  .emojiSquare:hover {
	  background: #ff0000;
	  color: #fff;
  }
  #emojiControls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
  }
#closeBtn {
    position: fixed;
    top: 4px;
    right: 11px;
    cursor: pointer;
    font-weight: bold;
    font-size: 29px;
    padding: 5px 12px;
    background: #333;
    border: 3px solid #DDD;
    color: #eee;
    border-radius: 4px;
    box-shadow: 0 0 15px 10px rgba(0,0,0,0.75);
}

  #closeBtn:hover { background: #ff4d4d; color: #fff; }
  #searchOptions { display: flex; align-items: center; gap: 5px; }
  #searchOptions input, #searchOptions button {
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 5px 8px;
    border-radius: 4px;
  }
  #searchOptions button:hover { background: #ff4d4d; color: #fff; }
  
  
  
  

.spec-wrap input[type="radio"] {
  display: none;
}

.spec-wrap label {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-radius: 6px;
  cursor: pointer;
  margin-right: 6px;
}

.spec-wrap input[type="radio"]:checked + label {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
}

.spec-input {
	width:100px;
}


.hiterm {
	color:#c3ff4e;
}
  
</style>


</head>
<body>

    <div id="loader-overlay">
        <div class="loader-spinner"></div>
		<div>Loading...</div>
    </div>
	
    <div id="home-screen" class="screen active">
        <h1>Wi-Fi Minesweeper</h1>
		<button id="howtoplay-btn" class="infobutton">? How to play</button>

        <div class="input-group" style="display: flex; gap: 10px; align-items: center;">
            <label for="game-name-input" style="white-space: nowrap;">Game ID:</label>
			<input type="text" id="game-name-input" value="DefaultGameName" placeholder="Enter Game Name">
        </div>
        <div class="input-group" style="display: flex; gap: 10px; align-items: center;">
             <label for="player-name-input" style="white-space: nowrap;">Your name:</label>
			 <input type="text" id="player-name-input" placeholder="Enter Your Name">
        </div>
        <div class="input-group" style="display: flex; gap: 10px; align-items: center;">
            <label for="server-name-input">Server:</label>
			<select id="server-name-input">
			
			</select>
        </div>
        <button id="host-btn">Host Game</button>
        <br>
		
        <button id="join-btn" class="secondary">Join Game</button>
        <button id="join-spectator-btn" class="secondary">Join as spectator</button>
        <p id="home-error" style="color: #FF00FF;"></p>
    </div>

    <div id="lobby-screen" class="screen">
        <h2 id="lobby-game-name"></h2>
		<button id="howtoplay-btn" class="infobutton">? How to play</button>
		
        <div id="host-controls">
            <h3>Game Settings</h3>

            <div class="input-group" style="display: flex; gap: 10px; align-items: center;">
				<label for="grid-x-input">Width:</label>
                <input type="number" id="grid-x-input" value="16" min="3">
				<label for="grid-y-input">Height:</label>
                <input type="number" id="grid-y-input" value="16" min="3">
            </div>
            <div class="input-group">
             
				<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
					<label for="total-mines-input">Total mines:</label>
					<input type="number" id="total-mines-input" value="51" min="1">
					<label for="map-style-input">Map style:</label>
					<select id="map-style-input">
						<option value="0" selected>Rectangle</option>
						<option value="1">Round</option>
					</select>
				</div>
				
				<span>Bombs:</span>
				<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
					<label for="total-bombs-input">Total:</label>
					<input type="number" id="total-bombs-input" value="1" min="0">
					
					<label for="bomb-radius-input">Radius:</label>
					<input type="number" id="bomb-radius-input" value="2" min="1">
				</div>
				
				<span>AI player:</span>
				<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
					<label for="ai-confusion-input">Mistake factor:</label>
					<input type="number" id="ai-confusion-input" value="0" min="0" max="3">
					<label for="ai-delay-input">Delay:</label>
					<input type="number" id="ai-delay-input" value="400" min="0">
					<button id="add-ai-btn" class="aibutton">Add</button>
				</div>

				
				<div class="input-group spec-wrap" style="display: flex; gap: 10px; align-items: center;">
					<span>Spectate game:</span>
					<input type="radio" id="spectate-yes" name="spectate-setting" value="1">
					<label for="spectate-yes" class="spec-input">Yes</label>
					<input type="radio" id="spectate-no" name="spectate-setting" value="0" checked>
					<label for="spectate-no" class="spec-input">No</label>
				 </div>
				 
			 
				
            </div>
            <button id="start-game-btn">Start Game</button>
        </div>
		
        
        <h3>Players in Lobby</h3>
        <ul id="player-list"></ul>
        
        <div class="input-group" style="display:none">
            <label>Your Symbol</label>
            <div class="symbol-select-group">
                <select id="symbol-select"></select>

					<label for="groupSelect">Group:</label>
					<select id="groupSelect">
					  <option value=""></option>
					  <option value="search">--Search--</option>
					</select>
					<div id="emojiView">
					  <div id="emojiControls">
						<div id="searchOptions" style="display:none;">
						  <input type="text" id="searchInput" placeholder="Search...">
						  <button id="matchModeBtn">Word</button>
						  <button id="searchBtn">Search</button>
						</div>
						<div id="closeBtn">✖</div>
					  </div>
					  <div id="emojiGrid"></div>
					</div>



                <input type="text" id="custom-symbol-input" maxlength="16" placeholder="Unicode">
            </div>
        </div>
		

        <p id="lobby-error" style="color: red;"></p>
    </div>
	
	<style>
  .instructions p.twocells {
    display: grid;
    grid-template-columns: 1fr auto; /* text takes remaining space, image only as wide as needed */
    align-items: start;
    gap: 10px; /* space between text and image */
    margin: 0 0 1em 0;
  }

  .instructions p.twocells img {
    width: 75px;
    height: auto;
  }
</style>
	<!-- help section -->
	<div id="howtoplay-modal" class="modal">
		<div class="modal-content">
			<span class="close">&times;</span>
			<!--<h2>How to Play</h2>-->
			<div class="instructions">
				<p>1. Find the mines by <span class="hiterm">Double Left Click</span> or a <span class="hiterm">Single Tap</span>. You get a new turn if you found a mine. Mines are flagged with flags after they are found.</p>
				<p class="twocells">
					<span>2. The numbers tell you how many mines are around that number: vertically, horizontally and diagonally (max 8 mines around).</span>
					<img src="images/help-mines.webp" width="75" title="2 mines around number 2">
				</p>


				<p>3. <span class="hiterm">Right Click</span> or <span class="hiterm">Long Press</span> activates the bomb on that position, which creates 5x5 explosion by default (radius = 2). Bomb can be placed only if you are not the leading player and you didn't make a move yet on your turn.</p>
				<p>4. Winner is the player who found most mines. A tie is also possible depending on settings.</p>
				<p>5. The game also ends if the other players doesn't have a chance anymore to find more mines than the leading player. Leading player becomes the winner and the remaining mines are revealed.</p>
			</div>
		</div>
	</div>
	

    <div id="game-screen">
		<div id="game-info">
			<span id="infopadding"></span>
		    <span id="game-status"></span>
		    <button id="bomb-button">
			    <img src="images/bomb-big96.png" alt="bomb" width="90"/>
		    </button>
		</div>
        <canvas id="game-canvas"></canvas>
		

		 <div id="chat">
			<div id="game-state-list" tabindex="0"></div>
			<div id="chatMessages" tabindex="0"></div>
			<input id="chatInput" type="text" placeholder="Type message...">
			<button id="chatSend">Send</button>
		</div>
    </div>



<script>

var CACHED_SOUND_EFFECTS = {};


var SOUNDS = {
	//undo: [1,0,0,0.145,0,0.432,0.468603,0,-0.212,0,0,0,0,0,0.548476,0,0,0,0,0.756234,0,0,0,0,0.061],
	changestyle: [1,0,0,0.066307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.623612,0,0,1,0,0,0,0,0.11],
	showhide: [1,3,0.219375,0.070448,0.264728,0.246,0.940782,0,-0.359019,0,0.276075,0.558813,0,0,0,0,0,0,0,1,0,0,0.909348,0,0.252],
	complete: [1,0,0,0.414,0.092,0.851,0.269,0,0.391888,0,0,0.787,0.027,0.033,0.082,-0.489,0.463,0.002,0.001,1,0,0,0,0,0.13],
	explosion: [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	hint: [1,3,0.2034,0.519972,0.079301,0.420554,0.503805,0,0.019718,-0.113554,0.02742,-0.960806,0.437405,-0.928749,0.31182,0.242098,-0.059401,0.008261,-0.0102,0.205988,0.046432,0.574843,0.114387,0.001109,0.1068],
	already: [1,1,0,0.115,0.431,0.526,0.311,0,0,-0.266,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.184],
	tie: [1,0,0,0.66307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.423612,0,0,1,0,0,0,0,0.11],
	fail: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,-0.352,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	really: [1,0,0,0.382534,0,0.663,0.318,0,0.115469,-0.138,0,0,0,0,0.31911,0,0,0,0,0.642664,0,0,0,0,0.1068],
	kill: [1,0,0,0.089127,0,0.441,0.494,0,-0.333792,0,0,0,0,0,0.080034,0,0,0,0,1,0,0,0.013473,0,0.09],
	next: [1,0,0,0.362553,0,0.454,0.501627,0,0.205054,0,0,0,0,0,0.578561,0,0,0,0,0.902463,0,0,0.157574,0,0.1068],
	clear: [1,3,0,0.233,0.316,0.438,0.301,0,-0.294087,0,0,0,0.319083,0.897748,0,0,0.670729,0,0,1,0,0,0,0,0.1068],
	score: [1,0,0,0.353496,0,0.472,0.404228,0,0.391888,0,0,0,0,0,0.174445,0,0.527907,0,0,1,0,0,0,0,0.1068],
	click: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,0,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	shuffle: [1,1,0,0.19396,0,0.463777,0.225533,0,0.307713,0,0,0,0,0,1,0,0.578735,0,0,1,0,0,0,0,0.134],
}




/////////////////////////////////
// JSFXR

var SOUNDS_ENABLED = true;
var PARAMS;
if(typeof Params !== "undefined"){
	PARAMS = new Params();
}else{
	SOUNDS_ENABLED = false;
}
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;

// JSFXR
/////////////////////////////////




function generate_sounds(){
	if(SOUNDS_ENABLED){
		for(var soundName in SOUNDS) {
			if(SOUNDS.hasOwnProperty(soundName)){
				console.log("Generating sound "+soundName);
				generate_sound_caches(soundName);
			}
		}
	}
}


function generate_sound_caches(soundName){
	if(SOUNDS_ENABLED){
		let newPARAMS = SOUNDS[soundName];
		
		if(newPARAMS[0] != 1){
			console.log("unknown sound version '"+newPARAMS[0]+"'");
			console.log(newPARAMS);
			return;
		}
		
		let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
		
		let output = {};
		output['oldParams'] = true;
		output['sample_rate'] = 44100;
		output['sample_size'] = 8;

		for(let i = 1; i < order.length; i++){
			output[order[i]] = newPARAMS[i];
		}

		PARAMS.fromJSON(output);
		
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName] = {};
		}
		
		SOUND = new SoundEffect(PARAMS).generate();
		CACHED_SOUND_EFFECTS[soundName]['sound'] = SOUND;
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	}
}


function play_sound(soundName){
	if(SOUNDS_ENABLED){
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			return;
		}
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'];
		SOUND.getAudio().play();
		console.log("play_sound: "+soundName);
		
		//console.log("CACHED_SOUND_EFFECTS:");
		//console.log(CACHED_SOUND_EFFECTS);
	}
}

generate_sounds();




// Draw a 2px-thick circle in the center; the canvas background remains transparent
function drawCircle(ctx, offsetX, offsetY, cx, cy, radius, lineWidth = 10, strokeStyle = '#ff0000') {
	ctx.beginPath();
	
	ctx.arc(offsetX+cx, offsetY+cy, radius, 0, Math.PI * 2);
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = strokeStyle;
	
	ctx.stroke();
}






/*
states:
-3 ...
-2 other item (for later use)
-1 mine
0 empty
1 (number of mines around)
2 (number of mines around)
3...
*/

let TYPE_MINE = -1;
let TYPE_EMPTY = 0;

let typeToValue = {
	"-1": "",
};

function set_mine(data, x, y, type){
	data.map[y][x].type = type;
	//data.map[y][x].value = typeToValue[data.map[y][x].type] ?? "X";
}


function generate_map(width, height, total_mines){
	let data = {
		width: width,
		height: height,
		chancesTemp: Array.from({length: height}, () => Array.from({length: width}, () => ({
			percent: -1, // 0.5, 0.333.., 0.666, 1.0... etc
			checked: 0,
			color: "black",
		}))),
		chances: Array.from({length: height}, () => Array.from({length: width}, () => ({
			percent: -1, // 0.5, 0.333.., 0.666, 1.0... etc
			checked: 0,
			color: "black",
		}))),
		chances2: Array.from({length: height}, () => Array.from({length: width}, () => ({
			empty: -1, // 0.5, 0.333.., 0.666, 1.0... etc
			mines: -1,
			total: -1,
			checked: 0,
		}))),
		map: Array.from({length: height}, () => Array.from({length: width}, () => ({
			type: TYPE_EMPTY, // -1 = mine, 0 = empty, 1-8 = number
			//value: "", // not used
			visible: 0,
			isBlocked: 0,
			owner: -1, // who has found the mine
			numbersAround: 0, // for darker water calcuations
			waternum: random(0,100)
		}))),
	};
	
	
	//generateBlockedEdges(data);
	if(isCircularMap){
		generateCircularMap(data);
	}
	
	// add mines:
	let placed = 0;
	while (placed < total_mines) {
		let x = Math.floor(Math.random() * width);
		let y = Math.floor(Math.random() * height);

		if (data.map[y][x].type === TYPE_EMPTY && !data.map[y][x].isBlocked) {
			set_mine(data, x, y, TYPE_MINE);
			placed++;
		}
	}
	
	// count mines around each spot:
	for(let y = 0; y < height; y++){
		for(let x = 0; x < width; x++){
			if(data.map[y][x].type === TYPE_EMPTY && !data.map[y][x].isBlocked){
				data.map[y][x].type = count_mines_around(data, x, y);
			}
		}	
	}
	

	return data;
}

function generateCircularMap(data) {
	const height = data.height;
	const width = data.width;

	const centerX = width / 2-0.5;
	const centerY = height / 2-0.5;

	// Radius along X and Y (half width/height)
	const radiusX = width / 2;
	const radiusY = height / 2;

	for (let y = 0; y < height; y++) {
		for (let x = 0; x < width; x++) {
			// Ellipse equation: (dx^2 / rx^2) + (dy^2 / ry^2)
			const dx = x - centerX;
			const dy = y - centerY;
			const value = (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY);
			// Inside ellipse (value <= 1) → unblocked; outside → blocked
			data.map[y][x].isBlocked = value > 1 ? 1 : 0;
			data.map[y][x].visible = data.map[y][x].isBlocked; // fixes AI trying to make a move on blocked cells.
		}
	}
}

function calculate_circular_map_free_cells(width, height){
	let count = 0;
	const centerX = width / 2-0.5;
	const centerY = height / 2-0.5;

	// Radius along X and Y (half width/height)
	const radiusX = width / 2;
	const radiusY = height / 2;

	for (let y = 0; y < height; y++) {
		for (let x = 0; x < width; x++) {
			// Ellipse equation: (dx^2 / rx^2) + (dy^2 / ry^2)
			const dx = x - centerX;
			const dy = y - centerY;
			const value = (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY);
			if(value <= 1){
				count++;
			}
		}
	}
	return count;
}



// Assuming you have perlin noise available, e.g. using 'noisejs' or similar library
// import { Noise } from 'noisejs'; // if in module context
// const noise = new Noise(Math.random());
// generate_random_map

function normalizeMap(map) {
  let min = Infinity;
  let max = -Infinity;

  // Find min and max
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      const v = map[y][x];
      if (v < min) min = v;
      if (v > max) max = v;
    }
  }

  // Normalize to 0..1
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      map[y][x] = (map[y][x] - min) / (max - min);
    }
  }

  return map;
}

function generateBlockedEdges(data, options = {}) {
	let minsize = Math.round(Math.min(data.width, data.height)*0.25);
  const {
    edgeRadius = minsize,     // how far from edges to potentially block
    threshold = 0.43,    // noise threshold for blocking
    scale = 0.5,        // how rough/smooth the perlin pattern is
    blurPasses = 1,     // how many blur/smooth passes to apply
    seed = Math.random()
  } = options;

  const noise = new Noise(seed);

  const height = data.height;
  const width = data.width;

  // Step 1: Create initial noise map
  const noiseMap = [];
  for (let y = 0; y < height; y++) {
    noiseMap[y] = [];
    for (let x = 0; x < width; x++) {
      // Compute distance from nearest edge
      const distToEdge = Math.min(x, y, width - 1 - x, height - 1 - y);

      // Only apply noise within edge radius
      //if (distToEdge <= edgeRadius) {
        const nx = x * scale;
        const ny = y * scale;
        const value = noise.perlin2(nx, ny);
        noiseMap[y][x] = (value + 1) / 2; // normalize to 0–1
      //} else {
      //  noiseMap[y][x] = 0;
      //}
    }
  }
  
    let opacityMap = [];
	// apply opacity gradient around edges:
	for (let y = 0; y < height; y++) {
		opacityMap[y] = [];
		for (let x = 0; x < width; x++) {
			let distToEdge = Math.min(x, y, width - 1 - x, height - 1 - y);
			if(distToEdge > edgeRadius){
				distToEdge = edgeRadius;
			}
			distToEdge++;
			let opacity = 1-(distToEdge/(edgeRadius+1));
			opacityMap[y][x] = opacity;
			noiseMap[y][x] = noiseMap[y][x]*opacity;
		}
	}

  console.log("opacityMap");
  console.log(opacityMap);
  
  console.log("noiseMap");
  console.log(noiseMap);
  

  // Step 2: Optional blur / smooth pass
  const blur = (map) => {
    const out = map.map(row => [...row]);
	const blurRadius = 3;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let sum = 0;
        let count = 0;
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          for (let dx = -blurRadius; dx <= blurRadius; dx++) {
			let xx = x+dx;
			let yy = y+dy;
			if(xx < 0 || yy < 0 || xx > width-1 || yy > height-1){
				continue;
			}
            sum += map[yy][xx];
            count++;
          }
        }
        out[y][x] = (sum / count);
      }
    }
    return out;
  };

  let blurredMap = noiseMap;
  for (let i = 0; i < blurPasses; i++) {
    blurredMap = blur(blurredMap);
  }
  console.log("blurredMap");
  console.log(blurredMap);
  
 


  blurredMap = normalizeMap(blurredMap);

  let blockedMap = [];
  // Step 3: Apply threshold and set blocked tiles
  for (let y = 0; y < height; y++) {
    blockedMap[y] = [];
    for (let x = 0; x < width; x++) {
		//let testval = blurredMap[y][x]*opacityMap[y][x];
		let testval = blurredMap[y][x];
      if (testval > threshold) {
        data.map[y][x].isBlocked = 1;
		data.map[y][x].visible = 1; // fixes AI trying to make a move on blocked cells.
      }
	  blockedMap[y].push(data.map[y][x].isBlocked);
    }
  }
  console.log("blockedMap");
  console.log(blockedMap);

}




function count_mines_around(data, xp, yp){
	let count = 0;
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(data.map[yy][xx].type < TYPE_EMPTY){
						count++;
					}
				}
			}
		}
	}
	return count;
}



function count_map_numbers_around(data){
	// check if this should be rendered as dark water (no visible numbers around it)
	for(let y = 0; y < data.height; y++){
		for(let x = 0; x < data.width; x++){
			data.map[y][x].numbersAround = count_numbers_around(data, x, y);
		}	
	}
}


function count_numbers_around(data, xp, yp){
	let count = 0;
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(data.map[yy][xx].type > TYPE_EMPTY && data.map[yy][xx].visible){
						count++;
					}
				}
			}
		}
	}
	return count;
}









function revealZeros(data, startX, startY, grid) {
	let queue = [[startY, startX]];

	while (queue.length > 0) {
		let [y, x] = queue.shift();

		// Bounds check
		if (y < 0 || y >= data.height || x < 0 || x >= data.width) continue;

		let cell = data.map[y][x];

		// Already visible? skip
		if (cell.visible) continue;
		if (cell.isBlocked) continue;

		// Reveal this cell
		cell.visible = 1;
		if(cell.type < TYPE_EMPTY){
			grid[y][x] = ""; // set visible grid empty for mines.
		}else{
			if(cell.type === TYPE_EMPTY){
				grid[y][x] = "";
			}else{
				grid[y][x] = cell.type;
			}
		}

		// If it's not a zero, stop spreading from here
		if (cell.type !== TYPE_EMPTY) continue;

		// Spread to all 8 neighbors
		for (let dy = -1; dy <= 1; dy++) {
			for (let dx = -1; dx <= 1; dx++) {
				if (dx === 0 && dy === 0) continue; // skip self
				queue.push([y + dy, x + dx]);
			}
		}
	}
}


function revealBombAirplaneZeros(data, startX, startY, grid) {
	// make 2x14 strip of bombs, center is mouse cursor. 
	// if part of bombing area goes outside of map, it will set it inside map automatically.
	let radiusX = 6;
	let radiusY = 1;
	let queue = [];
	// -6 -5 -4 -3 -2 -1 0 1 2 3 4 5
	// -1 0
	for (let dy = -radiusY; dy < radiusY; dy++) {
		for (let dx = -radiusX; dx < radiusX; dx++) {

            const y = startY + dy;
            const x = startX + dx;

            if (y < 0 || y >= data.height || x < 0 || x >= data.width) continue;

            let cell = data.map[y][x];
            if (cell.visible) continue;
			if (cell.isBlocked) continue;

            cell.visible = 1;
            if (cell.type < TYPE_EMPTY) {
                grid[y][x] = ""; // set visible grid empty for mines.
            } else {
                grid[y][x] = cell.type === TYPE_EMPTY ? "" : cell.type;
            }

            // If the cell is a zero, add it to the BFS queue
            if (cell.type === TYPE_EMPTY) {
                queue.push([y, x]);
            }
		}
	}
	
	
    // BFS for spreading zeros
    while (queue.length > 0) {
        let [y, x] = queue.shift();

        // Spread to all 8 neighbors
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const ny = y + dy;
                const nx = x + dx;

                if (ny < 0 || ny >= data.height || nx < 0 || nx >= data.width) continue;
                if (dx === 0 && dy === 0) continue;

                let neighbor = data.map[ny][nx];
                if (neighbor.visible) continue;
				if (neighbor.isBlocked) continue;

                neighbor.visible = 1;
                if (neighbor.type < TYPE_EMPTY) {
                    grid[ny][nx] = ""; // set visible grid empty for mines.
                } else {
                    grid[ny][nx] = neighbor.type === TYPE_EMPTY ? "" : neighbor.type;
                }

                // If neighbor is zero, add to queue
                if (neighbor.type === TYPE_EMPTY) {
                    queue.push([ny, nx]);
                }
            }
        }
    }
	
	
	// set owner for found mines:
	for(let yy = -radiusY; yy < radiusY; yy++){
		for(let xx = -radiusX; xx < radiusX; xx++){
			let xp = xx+startX;
			let yp = yy+startY;
			if(xp >= 0 && xp < gameState.minemap.width){
				if(yp >= 0 && yp < gameState.minemap.height){
					if(gameState.minemap.map[yp][xp].type < TYPE_EMPTY){
						gameState.minemap.map[yp][xp].owner = gameState.currentPlayerIndex;
					}
				}
			}
		}
	}
}


function revealBombZeros(data, startX, startY, grid) {
    let queue = [];
	let radius = gameState.bombRadius;

    // First, reveal 5x5 area around startX, startY
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const y = startY + dy;
            const x = startX + dx;

            if (y < 0 || y >= data.height || x < 0 || x >= data.width) continue;

            let cell = data.map[y][x];
            if (cell.visible) continue;
			if (cell.isBlocked) continue;

            cell.visible = 1;
            if (cell.type < TYPE_EMPTY) {
                grid[y][x] = ""; // set visible grid empty for mines.
            } else {
                grid[y][x] = cell.type === TYPE_EMPTY ? "" : cell.type;
            }

            // If the cell is a zero, add it to the BFS queue
            if (cell.type === TYPE_EMPTY) {
                queue.push([y, x]);
            }
        }
    }

    // BFS for spreading zeros
    while (queue.length > 0) {
        let [y, x] = queue.shift();

        // Spread to all 8 neighbors
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const ny = y + dy;
                const nx = x + dx;

                if (ny < 0 || ny >= data.height || nx < 0 || nx >= data.width) continue;
                if (dx === 0 && dy === 0) continue;

                let neighbor = data.map[ny][nx];
                if (neighbor.visible) continue;
				if (neighbor.isBlocked) continue;

                neighbor.visible = 1;
                if (neighbor.type < TYPE_EMPTY) {
                    grid[ny][nx] = ""; // set visible grid empty for mines.
                } else {
                    grid[ny][nx] = neighbor.type === TYPE_EMPTY ? "" : neighbor.type;
                }

                // If neighbor is zero, add to queue
                if (neighbor.type === TYPE_EMPTY) {
                    queue.push([ny, nx]);
                }
            }
        }
    }
	
	// set owner for found mines:
	for(let yy = -radius; yy <= radius; yy++){
		for(let xx = -radius; xx <= radius; xx++){
			let xp = xx+startX;
			let yp = yy+startY;
			if(xp >= 0 && xp < gameState.minemap.width){
				if(yp >= 0 && yp < gameState.minemap.height){
					if(gameState.minemap.map[yp][xp].type < TYPE_EMPTY){
						gameState.minemap.map[yp][xp].owner = gameState.currentPlayerIndex;
					}
				}
			}
		}
	}
}





let emojiData = [];
let matchMode = 'word'; // or 'any'

async function loadEmojis() {
  const res = await fetch('emojis-all.json');
  emojiData = await res.json();

  const select = document.getElementById('groupSelect');
  emojiData.forEach(group => {
    const opt = document.createElement('option');
    opt.value = group.group;
    opt.textContent = group.group;
    select.appendChild(opt);
  });
}

function showEmojiView(items) {
  const grid = document.getElementById('emojiGrid');
  grid.innerHTML = '';
  items.forEach(([symbol, name]) => {
    const div = document.createElement('div');
    div.className = 'emojiSquare';
    div.textContent = symbol;
    div.title = name;
    div.addEventListener('click', () => {
      document.getElementById('custom-symbol-input').value = symbol;
      document.getElementById('emojiView').style.display = 'none';
	  attemptSetSymbol();
    });
    grid.appendChild(div);
  });
  document.getElementById('emojiView').style.display = 'block';
}

document.getElementById('groupSelect').addEventListener('change', (e) => {
  const val = e.target.value;
  const searchOptions = document.getElementById('searchOptions');
  if(val === 'search') {
    searchOptions.style.display = 'flex';
    document.getElementById('emojiGrid').innerHTML = '';
    document.getElementById('emojiView').style.display = 'block';
  } else {
    searchOptions.style.display = 'none';
    const group = emojiData.find(g => g.group === val);
    if(group) showEmojiView(group.list);
  }
});

document.getElementById('closeBtn').addEventListener('click', () => {
  document.getElementById('emojiView').style.display = 'none';
});

document.getElementById('matchModeBtn').addEventListener('click', () => {
  matchMode = matchMode === 'word' ? 'any' : 'word';
  document.getElementById('matchModeBtn').textContent = matchMode.charAt(0).toUpperCase() + matchMode.slice(1);
});

document.getElementById('searchBtn').addEventListener('click', () => {
  const query = document.getElementById('searchInput').value.toLowerCase();
  if(!query) return;
  let results = [];
  emojiData.forEach(group => {
    group.list.forEach(([symbol,name]) => {
      const lname = name.toLowerCase();
      if((matchMode==='word' && lname.split(' ').includes(query)) ||
         (matchMode==='any' && lname.includes(query))) {
        results.push([symbol,name]);
      }
    });
  });
  showEmojiView(results);
});

loadEmojis();
</script>


<script>
// ---------- CONFIG & STATE ---------- //
const PREDEFINED_SYMBOLS = ['X', 'O', '#', '%'];

let peer;
let myPeerId;
let hostId;
let connections = {}; // key: peerId, value: connection object
let isHost = false;

let lastMoves = {};

let localPlayer = {
    id: null,
    name: "Player",
    symbol: '',
    isReady: false,
	isAI: false,
	isSpec: false,
	firstMove: true,
	quitted: false,
};

let gameState = {
    players: [],
    grid: [],
    gridSize: { x: 10, y: 10 },
	totalMines: 30,
	totalBombs: 1,
	bombRadius: 2,
    currentPlayerIndex: 0,
    gameStarted: false,
    gameOver: false,
    winner: null,
	ties: null,
	lastMoveFailed: false,
	minemap: {},
	minesRemaining: 0,
	history: [],
};

let localState = {
	// used to only store animation data
	animations: {
		map: null, // initialize this on game start.
	},
};


// ---------- UI ELEMENT REFERENCES ---------- //
const screens = {
    home: document.getElementById('home-screen'),
    lobby: document.getElementById('lobby-screen'),
    game: document.getElementById('game-screen'),
};
const gameNameInput = document.getElementById('game-name-input');
const playerNameInput = document.getElementById('player-name-input');
playerNameInput.value = randomPlayerName();

const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const joinSpectatorBtn = document.getElementById('join-spectator-btn');
const homeError = document.getElementById('home-error');

const lobbyGameName = document.getElementById('lobby-game-name');
const hostControls = document.getElementById('host-controls');
const startGameBtn = document.getElementById('start-game-btn');
const playerList = document.getElementById('player-list');
const symbolSelect = document.getElementById('symbol-select');
const customSymbolInput = document.getElementById('custom-symbol-input');
//const changeSymbolBtn = document.getElementById('change-symbol-btn');
const lobbyError = document.getElementById('lobby-error');
const gridXInput = document.getElementById('grid-x-input');
const gridYInput = document.getElementById('grid-y-input');




const mapStyleInput = document.getElementById("map-style-input");

let isCircularMap = false;

// Trigger when user changes the selection
mapStyleInput.addEventListener("change", (event) => {
	const selectedValue = event.target.value;
	isCircularMap = (selectedValue == 1);
	setTotalMines();
	console.log("Selected map style:", selectedValue);
});


const totalMinesInput = document.getElementById('total-mines-input');
const totalBombsInput = document.getElementById('total-bombs-input');
const bombRadiusInput = document.getElementById('bomb-radius-input');

const loaderOverlay = document.getElementById('loader-overlay'); 

// Show the loader
function showLoader() {
    loaderOverlay.style.display = 'flex';
	loaderOverlay.style.opacity = '1';
}

// Hide the loader
function hideLoader() {
	loaderOverlay.style.display = 'none';
	loaderOverlay.style.opacity = '0';
}



const gameInfo = document.getElementById('game-status');
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;



const chatMessages = document.getElementById("chatMessages");
const gameStateList = document.getElementById("game-state-list");
const chatInput = document.getElementById("chatInput");
const chatSend = document.getElementById("chatSend");


let isHostSpectating = false; 
document.querySelectorAll('input[name="spectate-setting"]').forEach(radio => {
	radio.addEventListener('change', () => {
		isHostSpectating = radio.value === "1";
		attemptSetSpec();
		console.log("Spectate changed:", isHostSpectating);
	});
});

function getSpectateValue() {
	return isHostSpectating;
}


//////////////////////////////////////////////////
//
// AI functionality ai turn ai feature
//

const addAiBtn = document.getElementById('add-ai-btn');

let ai_counter = 1;

addAiBtn.addEventListener('click', () => {
    if (!isHost) return;

    const aiPlayer = {
        id: `ai-${ai_counter}`,
        name: `AI-${ai_counter}`,
        symbol: '', // Not used for drawing, but good practice
        isReady: true,
        isAI: true,
		isSpec: false,
		quitted: false,
		firstMove: true,
        colors: newPlayerColor(),
        minesFound: 0,
        bombsUsed: 0,
    };

    gameState.players.push(aiPlayer);
    ai_counter++;

    // Update the UI for the host and broadcast the new state to all clients
    updateLobbyUI();
    broadcast({ type: 'game_state', state: gameState });
});




function checkForAITurn() {
    // Only the host should control the AI
    if (!isHost || gameState.gameOver) return;

    const currentPlayer = gameState.players[gameState.currentPlayerIndex];

    // If the current player is an AI, trigger their move
    if (currentPlayer && currentPlayer.isAI) {
		

		
		let delay = Math.max(parseInt(document.getElementById('ai-delay-input').value,10), 0); // min = 0
		
		
        setTimeout(() => {
            // Read the confusion factor from the input field
            const confusionFactor = parseInt(document.getElementById('ai-confusion-input').value,10) || 0;
            const bestMove = ai_find_best_move(confusionFactor);

            if (bestMove) {
                const aiMove = {
                    x: bestMove.x,
                    y: bestMove.y,
                    playerId: currentPlayer.id,
                    weapon: MOVE_TYPE_NORMAL // AI currently only does normal clicks
                };
                // Process the AI's move as if it came from a player
                handlePlayerMove(aiMove);
            }
        }, delay); // delay to simulate thinking
    }
}






function mark_percentages(){
	let data = gameState.minemap;
	mark_absolute_chances(data);
	// 6 passes should do it
	mark_absolute_chances2(data, "#008800");
	mark_absolute_chances2(data, "#000088");
	mark_absolute_chances2(data, "#FF00FF");
	mark_absolute_chances2(data, "#FFFFFF");
	mark_absolute_chances2(data, "#FFFF88");
	mark_absolute_chances2(data, "#FF8888");
	
	// check remaining percentages:
	//mark_absolute_chances3(data, "#888888");

}

function ai_find_best_move(confusion_factor = 0){
	
	// choose the first 100% cell where to hit:
	for(let y = 0; y < gameState.minemap.height; y++){
		for(let x = 0; x < gameState.minemap.width; x++){
			if(!gameState.minemap.map[y][x].visible && gameState.minemap.chances[y][x].percent == 1.0){
			
				console.log("found 100% chance at ",x,y);
				return {x,y};
			}
		}
	}

	return ai_find_next_best_move(gameState.minemap, confusion_factor);
	
}


function mark_chances(data, cells, percent, color = "black"){
	for(let i = 0; i < cells.length; i++){
		let square = cells[i];
		let xx = square.x;
		let yy = square.y;
		// only change percent if its higher:
		if(percent >= data.chances[yy][xx].percent){
			data.chances[yy][xx].percent = percent;
			data.chances[yy][xx].checked = 1;
			data.chances[yy][xx].color = color;
		}
	}
}


function mark_chances_temp(data, cells, percent, color = "black"){
	for(let i = 0; i < cells.length; i++){
		let square = cells[i];
		let xx = square.x;
		let yy = square.y;
		// only change percent if its higher:
		if(percent >= data.chancesTemp[yy][xx].percent){
			data.chancesTemp[yy][xx].percent = percent;
			data.chancesTemp[yy][xx].checked = 1;
			data.chancesTemp[yy][xx].color = color;
		}
	}
}



function mark_chances_temp2(data, cells, percent, color = "black"){
	for(let i = 0; i < cells.length; i++){
		let square = cells[i];
		let xx = square.x;
		let yy = square.y;
		// only change percent if its higher:
		if(!data.chancesTemp[yy][xx].checked){
			data.chancesTemp[yy][xx].percent = percent;
			data.chancesTemp[yy][xx].checked = 1;
			data.chancesTemp[yy][xx].color = color;
		}
	}
}



function copy_temp_to_chances2(){
	let data = gameState.minemap;
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			let olddata = Object.assign({}, data.chancesTemp[y][x]);
			if(olddata.percent > data.chances[y][x].percent){
				data.chances[y][x].percent = olddata.percent;
				data.chances[y][x].checked = olddata.checked;
				data.chances[y][x].color = olddata.color;
			}
		}
	}
}

function copy_temp_to_chances(){
	let data = gameState.minemap;
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			let olddata = Object.assign({}, data.chancesTemp[y][x]);
			data.chances[y][x].percent = olddata.percent;
			data.chances[y][x].checked = olddata.checked;
			data.chances[y][x].color = olddata.color;
		}
	}
}

function copy_chances_totemp(){
	let data = gameState.minemap;
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			let olddata = Object.assign({}, data.chances[y][x]);
			data.chancesTemp[y][x].percent = olddata.percent;
			data.chancesTemp[y][x].checked = olddata.checked;
			data.chancesTemp[y][x].color = olddata.color;
		}
	}
}




// find visible mines around
function mark_absolute_chances(data){
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			// if a number (1-8) that we can see:
			if(data.map[y][x].visible && data.map[y][x].type > TYPE_EMPTY){
				let totalMinesCount = data.map[y][x].type;
				if(totalMinesCount > 0){
					let mines = find_visible_mines_around(data, x, y);
					let empty = find_nonvisible_around(data, x, y);
					
					
					if(mines.length == totalMinesCount){
						// 0% chance (all mines found)
						mark_chances(data, empty, 0);
					}

					if(false){
						data.chances2[y][x].mines = mines.length;
						data.chances2[y][x].empty = empty.length;
						data.chances2[y][x].total = totalMinesCount;
						data.chances2[y][x].checked = 1;
					}
				}
			}
		}
	}
	
	
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			// if a number (1-8) that we can see:
			if(data.map[y][x].visible && data.map[y][x].type > TYPE_EMPTY){
				let totalMinesCount = data.map[y][x].type;
				if(totalMinesCount > 0){
					let mines = find_visible_mines_around(data, x, y);
					let empty = find_nonvisible_around(data, x, y);
					

					// empty+minesFound = minesTotal = all empty squares must be mines.
					if(empty.length + mines.length == totalMinesCount){
						// 100% chance of mines in the empty squares.
						mark_chances(data, empty, 1.0);
					}
					

					if(false){
						data.chances2[y][x].mines = mines.length;
						data.chances2[y][x].empty = empty.length;
						data.chances2[y][x].total = totalMinesCount;
						data.chances2[y][x].checked = 1;
					}
				}
			}
		}
	}
}



function find_nonvisible_around(data, xp, yp){
	let foundmines = [];
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(!data.map[yy][xx].visible){
						foundmines.push({x: xx, y:yy});
					}
				}
			}
		}
	}
	return foundmines;
}

// find visible mines around
function find_visible_mines_around(data, xp, yp){
	let foundmines = [];
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(data.map[yy][xx].visible && data.map[yy][xx].type < TYPE_EMPTY){
						foundmines.push({x: xx, y:yy});
					}
				}
			}
		}
	}
	return foundmines;
}




function mark_absolute_chances2(data, color){
	copy_chances_totemp();
	
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			// if a number (1-8) that we can see:
			if(data.map[y][x].visible && data.map[y][x].type > TYPE_EMPTY){
				let totalMinesCount = data.map[y][x].type;
				if(totalMinesCount > 0){
					let mines = find_visible_mines_around2(data, x, y);
					let empty = find_nonvisible_around2(data, x, y);
					
					
					if(mines.length == totalMinesCount){
						// 0% chance (all mines found)
						mark_chances_temp(data, empty, 0, color);
					}

					if(1){
						data.chances2[y][x].mines = mines.length;
						data.chances2[y][x].empty = empty.length;
						data.chances2[y][x].total = totalMinesCount;
						data.chances2[y][x].checked = 1;
					}
				}
			}
		}
	}
	
	
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			// if a number (1-8) that we can see:
			if(data.map[y][x].visible && data.map[y][x].type > TYPE_EMPTY){
				let totalMinesCount = data.map[y][x].type;
				if(totalMinesCount > 0){
					let mines = find_visible_mines_around2(data, x, y);
					let empty = find_nonvisible_around2(data, x, y);
					

					// empty+minesFound = minesTotal = all empty squares must be mines.
					if(empty.length + mines.length == totalMinesCount){
						// 100% chance of mines in the empty squares.
						mark_chances_temp(data, empty, 1.0, color);
					}
					

					if(1){
						data.chances2[y][x].mines = mines.length;
						data.chances2[y][x].empty = empty.length;
						data.chances2[y][x].total = totalMinesCount;
						data.chances2[y][x].checked = 1;
					}
				}
			}
		}
	}
	
	
	
	
	copy_temp_to_chances();
}






function find_nonvisible_around2(data, xp, yp){
	let foundmines = [];
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(!data.map[yy][xx].visible){
						if(data.chances[yy][xx].percent != 0){
							foundmines.push({x: xx, y:yy});
						}
					}
				}
			}
		}
	}
	return foundmines;
}

// find 100% mines around
function find_visible_mines_around2(data, xp, yp){
	let foundmines = [];
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					let minefound = 0;
					if(data.map[yy][xx].visible && data.map[yy][xx].type < TYPE_EMPTY){
						minefound = 1; // found mine already
					}
					if(!data.map[yy][xx].visible && data.chances[yy][xx].percent == 1.0){
						minefound = 1; // 100% chance of mine in invisible area
					}
					if(minefound){
						foundmines.push({x: xx, y:yy});
					}
				}
			}
		}
	}
	return foundmines;
}







function mark_absolute_chances3(data, color){
	copy_chances_totemp();
	
	for(let y = 0; y < gameState.gridSize.y; y++){
		for(let x = 0; x < gameState.gridSize.x; x++){
			// if a number (1-8) that we can see:
			if(data.map[y][x].visible && data.map[y][x].type > TYPE_EMPTY){
				let totalMinesCount = data.map[y][x].type;
				if(totalMinesCount > 0){
					let mines = find_visible_mines_around2(data, x, y);
					let empty = find_nonvisible_around2(data, x, y);
					
					
					let minesRemaining = totalMinesCount-mines.length;
					
					if(minesRemaining <= totalMinesCount){
						if(empty.length > 0){
							let chance = minesRemaining/empty.length;
							mark_chances_temp2(data, empty, chance, color);
						}
					}

					if(0){
						data.chances2[y][x].mines = mines.length;
						data.chances2[y][x].empty = empty.length;
						data.chances2[y][x].total = totalMinesCount;
						data.chances2[y][x].checked = 1;
					}
				}
			}
		}
	}
	

	copy_temp_to_chances2();
}
















/**
 * AI player function.
 * Analyzes the game board to determine the best location to place a flag (i.e., find a mine).
 * It first looks for guaranteed mines. If none are found, it makes a
 * probabilistic guess to find the square with the highest chance of being a mine.
 * @param {object} data - The current game data, including the map.
 * @param {number} confusion_factor - A number from 0 to 3+ to control AI difficulty.
 * 0: Perfect logic, no intentional mistakes.
 * 1: Small chance of making a mistake.
 * 2: Medium chance of making a mistake.
 * 3: High chance of making a mistake.
 * @returns {object|null} An object with {x, y} coordinates for the best move, or null if no moves are possible.
 */
function ai_find_next_best_move(data, confusion_factor = 0) {
    // --- Helper functions ---
	
	//console.log("ai_find_next_best_move 1");
    const containsCoord = (list, coord) => list.some(item => item.x === coord.x && item.y === coord.y);
    const uniqueCoords = (list) => {
        const seen = new Set();
        return list.filter(item => {
            const key = `${item.x},${item.y}`;
            return seen.has(key) ? false : seen.add(key);
        });
    };
	
	//console.log("ai_find_next_best_move 2");

    // --- Step 1: Scan the board to categorize squares ---
    let unopened_squares = [];
    let visible_numbered_squares = [];
    for (let y = 0; y < data.height; y++) {
        for (let x = 0; x < data.width; x++) {
            if (!data.map[y][x].visible) {
                unopened_squares.push({ x, y });
            } else if (data.map[y][x].type > 0) {
                visible_numbered_squares.push({ x, y, number: data.map[y][x].type });
            }
        }
    }

    if (unopened_squares.length === 0) return null; // Game is over
	
	//console.log("ai_find_next_best_move 3");

    // --- Step 2: Use logic to find certainties ---
    let certainly_safe = [];
    let certainly_mines = [];
    let changed_in_pass = true;

    // This loop repeats the deduction process until no new information can be found.
    while (changed_in_pass) {
        changed_in_pass = false;
        for (const square of visible_numbered_squares) {
            const { x, y, number } = square;
            let adjacent_unopened = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < data.width && ny >= 0 && ny < data.height && !data.map[ny][nx].visible) {
                       adjacent_unopened.push({ x: nx, y: ny });
                    }
                }
            }
            
            // Adjust for already identified certainties
            let known_mine_neighbors_count = adjacent_unopened.filter(n => containsCoord(certainly_mines, n)).length;
            let known_safe_neighbors_count = adjacent_unopened.filter(n => containsCoord(certainly_safe, n)).length;
            let unknown_neighbors = adjacent_unopened.filter(n => !containsCoord(certainly_mines, n) && !containsCoord(certainly_safe, n));

            // Rule 1: If a number equals its adjacent unopened neighbors (minus known safe ones), they must all be mines.
            if (number === (adjacent_unopened.length - known_safe_neighbors_count) && unknown_neighbors.length > 0) {
                unknown_neighbors.forEach(n => {
                    if (!containsCoord(certainly_mines, n)) {
                        certainly_mines.push(n);
                        changed_in_pass = true;
                    }
                });
            }

            // Rule 2: If a number equals its known mine neighbors, all other unknown neighbors must be safe.
            if (number === known_mine_neighbors_count && unknown_neighbors.length > 0) {
                 unknown_neighbors.forEach(n => {
                    if (!containsCoord(certainly_safe, n)) {
                        certainly_safe.push(n);
                        changed_in_pass = true;
                    }
                });
            }
        }
    }
    certainly_mines = uniqueCoords(certainly_mines).filter(mine => !containsCoord(certainly_safe, mine));

	//console.log("ai_find_next_best_move 4");

    // --- Step 3: Decision Making (OBJECTIVE: FIND MINES) ---

    // Case A: We found guaranteed mines. This is the best possible move.
    if (certainly_mines.length > 0) {
        // Apply confusion factor: chance to make a mistake instead of picking a guaranteed mine.
        if (Math.random() < confusion_factor * 0.15) {
            const possible_mistakes = unopened_squares.filter(sq => !containsCoord(certainly_mines, sq));
            if (possible_mistakes.length > 0) {
                 return possible_mistakes[Math.floor(Math.random() * possible_mistakes.length)];
            }
        }
        // Otherwise, make the smart move and pick a guaranteed mine.
        return certainly_mines[Math.floor(Math.random() * certainly_mines.length)];
    }
	
	//console.log("ai_find_next_best_move 5");

    // Case B: No certainties found, so make a probabilistic guess for the MOST likely mine.
    let probabilities = {}; // key: "x,y", value: highest probability of being a mine
    let candidates = unopened_squares.filter(sq => !containsCoord(certainly_safe, sq));
    if (candidates.length === 0) return null; // All remaining squares are safe
	
	//console.log("ai_find_next_best_move 6");

    for (const square of visible_numbered_squares) {
        const { x, y, number } = square;
        let adjacent_unknowns = [];
        let known_mine_neighbors_count = 0;
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                if (dx === 0 && dy === 0) continue;
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < data.width && ny >= 0 && ny < data.height && !data.map[ny][nx].visible) {
                    const neighbor_coord = { x: nx, y: ny };
                    if (containsCoord(certainly_mines, neighbor_coord)) {
                        // This case shouldn't happen if we return early, but for safety
                        known_mine_neighbors_count++; 
                    } else if (!containsCoord(certainly_safe, neighbor_coord)) {
                        adjacent_unknowns.push(neighbor_coord);
                    }
                }
            }
        }

        if (adjacent_unknowns.length > 0) {
            const prob = (number - known_mine_neighbors_count) / adjacent_unknowns.length;
            for (const unknown of adjacent_unknowns) {
                const key = `${unknown.x},${unknown.y}`;
                // We want the highest probability from any neighboring number.
                if (!probabilities[key] || prob > probabilities[key]) {
                     probabilities[key] = prob;
                }
            }
        }
    }
	
	//console.log("ai_find_next_best_move 7");

    let best_guesses = [];
    let max_prob = -1; // Probabilities are 0-1, so start at -1.
    for (const cand of candidates) {
        const key = `${cand.x},${cand.y}`;
        const prob = probabilities[key] ?? 0; // Assume 0% chance if no info
        if (prob > max_prob) {
            max_prob = prob;
            best_guesses = [cand];
        } else if (prob === max_prob && max_prob > 0) { // Only add if it's a real possibility
            best_guesses.push(cand);
        }
    }
    
    // If no square has a probability > 0, guess any candidate that isn't certainly safe.
    if(best_guesses.length === 0) best_guesses = candidates; 
	
	//console.log("ai_find_next_best_move 8");

    // Apply confusion factor: higher chance to make a mistake on a guess (pick a less likely mine).
    if (Math.random() < confusion_factor * 0.25 && candidates.length > best_guesses.length) {
        const worse_guesses = candidates.filter(cand => !containsCoord(best_guesses, cand));
        if (worse_guesses.length > 0) {
            return worse_guesses[Math.floor(Math.random() * worse_guesses.length)];
        }
    }
	
	//console.log("ai_find_next_best_move 9");

    // Otherwise, make the best possible guess.
    let bestmove = best_guesses[Math.floor(Math.random() * best_guesses.length)];
	console.log("ai_find_next_best_move:", bestmove);
	return bestmove;
}


//
// AI functionality ends
//
//////////////////////////////////////////////////





//const howToPlayBtn = document.getElementById('howtoplay-btn');

const howToPlayBtns = document.querySelectorAll('.infobutton');
const modal = document.getElementById('howtoplay-modal');
const closeBtn = modal.querySelector('.close');

// Loop through each button
howToPlayBtns.forEach(button => {
	button.addEventListener('click', () => {
		console.log("hehe");
		modal.style.display = 'block';
	});
});


//howToPlayBtn.addEventListener('click', () => {
//	modal.style.display = 'block';
//});

closeBtn.addEventListener('click', () => {
	modal.style.display = 'none';
});

window.addEventListener('click', (e) => {
	if (e.target === modal) {
		modal.style.display = 'none';
	}
});

// Close modal by pressing Escape
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && modal.style.display === 'block') {
    modal.style.display = 'none';
  }
});



function setTotalMines() {
	let width = parseInt(gridXInput.value,10);
	let height = parseInt(gridYInput.value,10);
	let ratio = 51/256;
	let total = 0;
	if(isCircularMap){
		total = calculate_circular_map_free_cells(width, height);
	}else{
		total = width*height;
	}
	
	let val = Math.round(total*ratio);
	if(val < 1) val = 1;
	totalMinesInput.value = val;
	
}

gridXInput.addEventListener("input", setTotalMines);
gridYInput.addEventListener("input", setTotalMines);



// ---------- UI MANAGEMENT ---------- //
function showScreen(screenName) {
    Object.values(screens).forEach(screen => screen.classList.remove('active'));
    if(screenName === 'game') {
        screens.game.style.display = 'flex';
        screens.home.style.display = 'none';
        screens.lobby.style.display = 'none';
    } else {
        screens.game.style.display = 'none';
        screens[screenName].classList.add('active');
    }
}

function updateLobbyUI() {
    lobbyGameName.textContent = `Game: ${gameNameInput.value}`;
    hostControls.style.display = isHost ? 'block' : 'none';
    
    const me = gameState.players.find(p => p.id === localPlayer.id);
    if (me) {
        localPlayer = { ...localPlayer, ...me };
    }

    playerList.innerHTML = '';
    gameState.players.forEach((p, playerIndex) => {
        const li = document.createElement('li');
        const displayName = p.isSpec ? `${p.name} (Spectator)` : p.name;
		const safeName = document.createTextNode(displayName);
		li.innerHTML = `<span style="color:${p.colors.color}"></span>`;
		li.querySelector("span").appendChild(safeName);
        playerList.appendChild(li);
    });

    const usedSymbols = gameState.players.map(p => p.symbol);
    const availableSymbols = PREDEFINED_SYMBOLS.filter(s => !usedSymbols.includes(s) || s === localPlayer.symbol);

    symbolSelect.innerHTML = availableSymbols.map(s => `<option value="${s}" ${s === localPlayer.symbol ? 'selected' : ''}>${s}</option>`).join('');

}

function updateGameUI() {
    if (gameState.gameStarted) {
        updateGameInfo();
        draw();
		console.log("updateGameUI draw");
    }
}






const playerColors = [
	{color: "#e6194B", flag: "red"}, // red
	{color: "#4363d8", flag: "blue"}, // blue
	{color: "#ffe119", flag: "yellow"}, // yellow
	{color: "#3cb44b", flag: "green"}, // dark green
	{color: "#f58231", flag: "gray"}, // orange
	{color: "#911eb4", flag: "gray"}, // purple
	{color: "#42d4f4", flag: "gray"}, // cyan
	{color: "#f032e6", flag: "gray"}, // magenta
	{color: "#bfef45", flag: "gray"}, // lime
	{color: "#469990", flag: "gray"}, // teal
	{color: "#9A6324", flag: "gray"}, // brown
	{color: "#808000", flag: "gray"}, // olive
	{color: "#000075", flag: "gray"}, // navy
	{color: "#a9a9a9", flag: "gray"}, // gray
	{color: "#555588", flag: "gray"},  // grayis blue
];

let playerColorCounter = 0;

function nextFreeColor(){
	let found_free_color = 0;
	let free_color = "#123456";
	let colors_obj = {};
	for(let i = 0; i < playerColors.length; i++){
		let color = playerColors[i].color;
		// check if any player has this color already:
		let found = 0;
		for(let p = 0; p < gameState.players.length; p++){
			let player_color = gameState.players[p].colors.color;
			if(player_color == color){
				found = 1;
				break;
			}
		}
		if(!found){
			found_free_color = 1;
			free_color = color;
			colors_obj = playerColors[i];
			break;
		}
	}
	if(found_free_color){
		return colors_obj;
	}else{
		// if all colors are taken, cycle by player count:
		return playerColors[gameState.players.length % playerColors.length];
	}
}


// playerColors array contains all colors
let specColors = {color: '#FFFFFF', flag: "pirate"}; // pirate = not found / spec

function newPlayerColor(isSpec = false){
	// specs doesnt actually need flag but using it anyway
	return isSpec ? specColors : nextFreeColor();
}
/*
window.addEventListener('beforeunload', (e) => {
  e.preventDefault(); // Required in some browsers
  e.returnValue = 'sure?'; // Chrome shows default confirmation

  if (conn && conn.open) {
    conn.send({ type: 'disconnect' });
    conn.close();
  }
  if (peer && !peer.destroyed) {
    peer.destroy();
  }
});
*/

window.addEventListener('beforeunload', () => {

  if (peer && !peer.destroyed) {
    peer.destroy(); // closes local peer connection
  }

  // Notify your server immediately
  navigator.sendBeacon('/peer-disconnect', JSON.stringify({ peerId: peer.id }));
});








function remove_player(peer, hostSide, timedOut = false){
	let hostStr = hostSide ? "(HOST)" : "(peer)";
	
	
	if (isHost) {
		//gameState.players = gameState.players.filter(p => p.id !== conn.peer);
		// set disconnected players as spectators so game can continue:
		// todo: or make them into AI's...?
		let removed_player_index = -1;
		let removed_player = null;
		for(let i = 0; i < gameState.players.length; i++){
			let player = gameState.players[i];
			//console.warn(`id:${player.id} ==? peerid:${peer} - quitted: ${player.quitted} - index=${i}`);
			if(!player.quitted && player.id === peer){
				player.isSpec = true;
				player.quitted = true;
				removed_player_index = i;
				removed_player = player;
				break;
			}
		}
		
		if(removed_player_index != -1){
			console.warn("removed_player_index = "+removed_player_index);
		
			delete connections[peer];
		
			// let others play if quitter was in turn:
			if(removed_player_index == gameState.currentPlayerIndex){
				advanceToNextPlayer();
				checkForAITurn(); // start AI turn if it is his turn.
			}
			if(timedOut){
				console.warn("sendChatMessage timed out, set as spec");
		
				sendChatMessage(`Player "${removed_player.name}" timed out, set as spectator.`);
			}else{
			
				console.warn("sendChatMessage has left the game");
			
				sendChatMessage(`Player "${removed_player.name}" has left the game.`);
			}
			
			
			
			console.log(`${hostStr} sent game_state:`);
			broadcast({ type: 'game_state', state: gameState });
			updateLobbyUI(); // Host updates its own view
		}
		
	}
	
	updateGameInfo();
	
	if(pingTimer){
		clearInterval(pingTimer);
		pingTimer = null;
	}
	
	
	
}


// check if player timed out:
setInterval(() => {
	if(isHost){
		const now = Date.now();
		for(let i = 0; i < gameState.players.length; i++){
			let player = gameState.players[i];
			if(player.peerId && !player.quitted){
				if (now - player.lastPing > 3000) { // e.g., 10 seconds timeout
					console.warn(`Player ${player.id} timed out (interval check)`);

					console.warn("trying to remove player");
					remove_player(player.peerId, isHost, true);

					// Clean up connection
					//if (player.conn) player.conn.close();
					//delete players[peerId];
					// Optionally notify other players
				}
			}
		}
	}
}, 3000); // check every 3 seconds


let pingTimer = null;

// ---------- NETWORKING (PeerJS) ---------- //

function setupConnection(conn, hostSide) {
	let hostStr = hostSide ? "(HOST)" : "(peer)";
	
    conn.on('open', () => {
		hideLoader();
        console.log(`${hostStr} > conn.on('open'): Connected to ${conn.peer}`);
        connections[conn.peer] = conn;


		
        if (isHost) {
			console.log(`${hostStr} sent game_state:`);
            conn.send({ type: 'game_state', state: gameState });
        }else{
			// avoid creating multiple timers:
			if(pingTimer){
				console.log("clearInterval(pingTimer)");
				clearInterval(pingTimer);
			}
			pingTimer = setInterval(() => {
				if (conn && conn.open) {
					conn.send({ type: 'ping', t: Date.now() });
				}
			}, 3000);
		}
    });

    conn.on('data', data => {
		//hideLoader();
		console.log(`${hostStr} > conn.on('data') at setupConnection(): (${localPlayer.id}) ${conn.peer}`);
		console.log(data);
		
		
		if (data.type === 'ping') {
			console.log("ping received from "+conn.peer);
			
			let player = getPlayerById(conn.peer);
			if(player){
				player.lastPing = Date.now();
				player.peerId = conn.peer;
			}
		}else{
			handleMessage(data, conn.peer);
		}
	});
	peer.on('disconnect', () => {
        console.log(`${hostStr} > conn.on('disconnect'): disconnected with ${conn.peer}`);
		remove_player(conn.peer, hostSide);
	});

    conn.on('close', () => {
		hideLoader();
        console.log(`${hostStr} > conn.on('close'): Connection closed with ${conn.peer}`);
		remove_player(conn.peer, hostSide);

    });
	
	


}


let selectedServerIndex = 1; // default to render.com

// select local server if local server is forced in config:
if(window.APP_CONFIG.LOCAL == true){
	selectedServerIndex = 0;
}

// onlyLocal = only visible if window.APP_CONFIG.LOCAL = true
let serversList = [
	{name: "local", onlyLocal: true, config: {
		host: 'localhost',
		port: 9000,
		path: '/peerjs',
		secure: false,
		debug: 2,
	}}, // dont show this if testing locally.
	{name: "render.com", onlyLocal: false, config: {
		host: 'peerjs-server-j9al.onrender.com',
		path: '/peerjs',
		secure: true,
		debug: 2,
	}},
	{name: "peerjs.com (Wi-Fi only)", onlyLocal: false, config: {
		debug: 2
	}},
];


const serverNameInput = document.getElementById("server-name-input");
serverNameInput.value = selectedServerIndex;

serversList.forEach((server, index) => {
	// if onlyLocal is false or config local is true, then add line:
	if(!server.onlyLocal || window.APP_CONFIG.LOCAL){
		const option = document.createElement("option");
		option.value = index;  // value attribute
		option.textContent = server.name;  // visible text
		serverNameInput.appendChild(option);
	}
});

function initializePeer(hostSide, peerId = null) {
	let hostStr = hostSide ? "(HOST)" : "(peer)";
	
    myPeerId = peerId || 'tictactoe-' + Math.random().toString(36).substr(2, 23);
    localPlayer.id = myPeerId;


	selectedServerIndex = parseInt(serverNameInput.value, 10);
	let selectedServer = serversList[selectedServerIndex];

	peer = new Peer(myPeerId, selectedServer.config);
	
	if(selectedServer.config.host){
		console.warn(`connecting to ${selectedServer.config.host}${selectedServer.config.path}`);
	}else{
		console.warn(`connecting to wifi server (peerjs.com)`);
	}
	console.warn(selectedServer.config);
	
	/*
	if(selectedServer == "local"){
		peer = new Peer(myPeerId, {
			host: 'localhost',
			port: 9000,
			path: '/peerjs',
			secure: false,
			debug: 2,
		});
	}else if(selectedServer == "public-peerjs"){
		peer = new Peer(myPeerId, { debug: 2 }); // use debug 3 to see more.
	}else if(){
		peer = new Peer(myPeerId, {
			host: 'peerjs-server-j9al.onrender.com',
			path: '/peerjs',
			secure: true,
			debug: 2,
		});
	}*/




    peer.on('open', id => {
		hideLoader();
		console.log(`${hostStr} > peer.on('open')`);
        console.log('initializePeer: My peer ID is: ' + id);
		console.log("current gameState:");
		console.log(gameState);
    });

    peer.on('connection', conn => {
		//hideLoader();
		console.log(`${hostStr} > peer.on('connection')`);
        setupConnection(conn, hostSide);
    });

    peer.on('error', err => {
		hideLoader();
		console.log(`${hostStr} > peer.on('error')`);
        console.error("PeerJS Error:", err);
        homeError.textContent = `Error: ${err.message}. Try a different Game Name.`;
        joinBtn.disabled = false;
        hostBtn.disabled = false;
    });
}


function hostGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
	
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
	
    localPlayer.name = playerName;
    isHost = true;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
	
	showLoader();
	
    initializePeer(true, gameName); 


    peer.on('open', id => {
		localPlayer.symbol = PREDEFINED_SYMBOLS[0];
		localPlayer.isReady = true;
		localPlayer.colors = newPlayerColor();
		localPlayer.minesFound = 0;
		localPlayer.bombsUsed = 0;
		localPlayer.isAI = false;
		localPlayer.isSpec = false; // has to modify this when STARTING the game. getSpectateValue()
		localPlayer.firstMove = true;
		localPlayer.quitted = false;
		gameState.players.push(localPlayer); 
		
		showScreen('lobby');
		updateLobbyUI();
    });
	

}



function joinGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
	
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
	
    localPlayer.name = playerName;
    isHost = false;
    hostId = gameName;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
	
	showLoader();
	
    initializePeer(false);


    setTimeout(() => { 
        if (!peer || !peer.id) return;
        const conn = peer.connect(hostId, { reliable: true });
        if(conn) {
            setupConnection(conn, false);
        } else {
			hideLoader();
            homeError.textContent = "Could not connect to host. Check Game Name.";
            hostBtn.disabled = false;
            joinBtn.disabled = false;
        }
    }, 1000);
	
	
}

function joinAsSpectator() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
	
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
	
    localPlayer.name = playerName;
    localPlayer.isSpec = true; // Set spectator flag
    isHost = false;
    hostId = gameName;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
    joinSpectatorBtn.disabled = true;
	
	showLoader();

    initializePeer(false);

    setTimeout(() => { 
        if (!peer || !peer.id) return;
        const conn = peer.connect(hostId, { reliable: true });
        if(conn) {
            setupConnection(conn, false);
        } else {
			hideLoader();
            homeError.textContent = "Could not connect to host. Check Game Name.";
            hostBtn.disabled = false;
            joinBtn.disabled = false;
            joinSpectatorBtn.disabled = false;
        }
    }, 1000);
}

function broadcast(data) {
    if (!isHost) return;
    Object.values(connections).forEach(conn => {
        conn.send(data);
    });
}

function sendToHost(data) {
    if (isHost) return;
    const conn = connections[hostId];
    if (conn) {
        conn.send(data);
    }
}

/*
changestyle
showhide hyvä
already ok
fail ok 
already lol
kill hyvä
next hassu
clear hyvä
score ok
click ok
shuffle ok

complete : voitit pelin
explosion : hävisit
*/

function getMoveType(x, y){
	return gameState.minemap.map[y][x].type;
}



function init_animation_map(){

	if(localState.animations.map == null){
		let width = gameState.minemap.width;
		let height = gameState.minemap.height;
		
		localState = {
			animations: {
				map: Array.from({length: height}, () => Array.from({length: width}, () => ({
					frame: 0, // animation frame
				}))),
			},
		};
		
		//console.log("localState initialized:");
		//console.log(localState);
	}
}


function handleMessage(data, peerId) {
    //console.log('Received:', data.type);
	
	console.log(data.type+":");
	
	let hostStr = isHost ? "(HOST)" : "(peer)";
	
    switch (data.type) {
        case 'game_state':
			console.log("case: game_state "+hostStr);
            gameState = data.state;
			console.log(gameState);
			
			if(gameState.gameStarted){
				if(gameState.playStartSound){
					gameState.playStartSound = false;
					playSound("startgame");
				}
			}
			
			if (gameState.gameOver) {
				if (gameState.winner) {
					if(gameState.winner.id === localPlayer.id){
						playSound("victory");
					}else{
						playSound("bigsplash");
					}
				} else {
					play_sound("tie");
				}
			}
			
			

			if (gameState.lastMove) {
				
				
				if(!gameState.lastMoveFailed){
					
					//console.log("!gameState.lastMoveFailed");
				
					//console.log("gameState.lastMove");
					//console.log(gameState.lastMove);
					const lastmove = gameState.lastMove;
					
					if(lastmove.weapon == MOVE_TYPE_BOMB){
						if (lastmove.playerId === localPlayer.id) {
							playSound("bigsplash"); // you made the move
						} else {
							playSound("bigsplash"); // opponent move
						}
					}else{
					
						let type = getMoveType(gameState.lastMove.x, gameState.lastMove.y);
						let moveSound = "miss";
						let playerHitMine = (type < 0);
						if(playerHitMine){
							moveSound = "hit";
						}else if(type == 0){
							moveSound = "miss_long";
						}
						
						if (lastmove.playerId === localPlayer.id) {
							playSound(moveSound); // you made the move
						} else {
							playSound(moveSound); // opponent move
							
							// set warning mines count max 10 and min 1:
							let warningMines = Math.round(gameState.totalMines*(6/51));
							if(warningMines > 10){
								warningMines = 10;
							}else if(warningMines < 1){
								warningMines = 1;
							}
							
							if (!gameState.gameOver) {
								if(playerHitMine && gameState.minesRemaining <= warningMines){
									playSound("warning");
								}
							}
						}
						
						
					}
					
					///updateGameUI(); // no effect on bombs score bug...
				}
			}

			
            if (!isHost && !localPlayer.isReady) {
				// important to set it first:
				localPlayer.isReady = true; // had to set this first or it spammed player_join messages
				
				console.log(`sendToHost({ type: 'player_join', player: ${localPlayer.id} });`);
                showScreen('lobby');
                sendToHost({ type: 'player_join', player: localPlayer });
                
            }
			
			
			// will trigger this every time a move is made...
            if (gameState.gameStarted) {
				// initialize animations map only once:
				init_animation_map();
				
                showScreen('game');
                resizeCanvas();
                updateGameUI();
            } else {
                updateLobbyUI();
            }
			
            break;
        case 'player_join':
		
			console.log("case: player_join "+hostStr);
            if (isHost) {
                // ** THE BUG FIX IS HERE **
                // Check if player already exists before adding
                if (gameState.players.some(p => p.id === data.player.id)) {
                    //console.warn(`Player ${data.player.id} tried to join again. Ignoring.`);
                    // Resend state just in case they missed it
                    connections[data.player.id]?.send({ type: 'game_state', state: gameState });
                    return;
                }

                let newPlayer = data.player;
				if(gameState.gameStarted){
					newPlayer.isSpec = true;

					sendChatMessage(`Player "${newPlayer.name}" joined as spectator.`);					
				}
				
                const usedSymbols = gameState.players.map(p => p.symbol);
                const nextSymbol = PREDEFINED_SYMBOLS.find(s => !usedSymbols.includes(s));
                newPlayer.symbol = nextSymbol || '';
				
				newPlayer.colors = newPlayerColor(newPlayer.isSpec);
				newPlayer.minesFound = 0;
				newPlayer.bombsUsed = 0;
				newPlayer.isAI = false;
				newPlayer.firstMove = true;
				newPlayer.quitted = false;

                
                gameState.players.push(newPlayer);
                broadcast({ type: 'game_state', state: gameState });
                updateLobbyUI();
            }
			
			updateGameInfo();
			
            break;
        case 'player_update':
			console.log("case: player_update "+hostStr);
             if (isHost) {
                const playerIndex = gameState.players.findIndex(p => p.id === peerId);
                if (playerIndex > -1) {
                    const requestedSymbol = data.player.symbol;
                    if (gameState.players.some((p, i) => p.symbol === requestedSymbol && i !== playerIndex)) {
                        connections[peerId].send({type: 'symbol_taken'});
                    } else {
                        gameState.players[playerIndex].symbol = data.player.symbol;
                        broadcast({ type: 'game_state', state: gameState });
                        updateLobbyUI();
                    }
                }
            }
            break;
        case 'player_update_spec':
			console.log("case: player_update_spec "+hostStr);
             if (isHost) {
                const playerIndex = gameState.players.findIndex(p => p.id === peerId);
                if (playerIndex > -1) {
                    const isSpec = data.player.isSpec;
					
					

					gameState.players[playerIndex].isSpec = isSpec;
					gameState.players[playerIndex].colors = newPlayerColor(isSpec);

					broadcast({ type: 'game_state', state: gameState });
					updateLobbyUI();

                }
            }
            break;
        case 'symbol_taken':
			console.log("case: symbol_taken "+hostStr);
            lobbyError.textContent = "Symbol is already taken!";
            setTimeout(() => lobbyError.textContent = "", 2000);
            break;
        case 'player_move':
			console.log("case: player_move "+hostStr);
            if (isHost) {
                handlePlayerMove(data.move);
            }
            break;
		case "player_message":
			console.log("case: player_message "+hostStr);
			if (isHost) {
				// Rebroadcast to everyone else, but NOT back to the original sender
				broadcast(data, peerId); // assuming your broadcast supports excluding peerId
			}

			// Show the message (all peers including host)
			addChatMessage(data.text, data.playerId);
			break;
    }
}


// Send message when clicking the button
chatSend.addEventListener("click", () => sendChatMessage());

// Or when pressing Enter
chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter") sendChatMessage();
});

function sendChatMessage(str = null) {
	// If function was triggered by an event (PointerEvent, KeyboardEvent, etc.), ignore it
	// note: fixed by "() => sendChatMessage()" in addEventListener
	//if (str instanceof Event) {
	//	str = null;
	//}
	let msg;
	
	if(str != null){
		msg = {
			type: "player_message",
			playerId: -1,
			text: str,
		};
	}else{
		if(!chatInput.value.trim()){
			return;
		}
		msg = {
			type: "player_message",
			playerId: localPlayer.id,
			text: chatInput.value.trim(),
		};
	}

	if (isHost) {
		// Host only needs to broadcast, not handleMessage directly
		broadcast(msg);
		addChatMessage(msg.text, msg.playerId); // add to host UI only
	} else {
		sendToHost(msg);
		//addChatMessage(msg.text, msg.playerId); // add immediately for sender
	}

	chatInput.value = "";
}

function getPlayerById(id, myArray = null) {
	if(myArray){
		return myArray.find(p => p.id === id) || null;
	}else{
		return gameState.players.find(p => p.id === id) || null;
	}
}


function addChatMessage(text, playerId = -1) {
	const div = document.createElement("div");

	if(playerId != -1){
		let player = getPlayerById(playerId);


		// Player name in color
		const nameSpan = document.createElement("span");
		nameSpan.style.color = player.colors.color;
		nameSpan.textContent = player.name; // safe

		div.appendChild(nameSpan);

		// Colon + message
		div.appendChild(document.createTextNode(": " + text));
	}else{
		div.appendChild(document.createTextNode(text));
	}
	chatMessages.appendChild(div);


	// scroll to bottom
	chatMessages.scrollTop = chatMessages.scrollHeight;
}




function restartGame(){
	location.reload();
}




function addRestartMessage() {

	const div = document.createElement("div");

	// Player name in color
	const nameSpan = document.createElement("span");
	nameSpan.style.color = "#FFFFFF";
	nameSpan.innerHTML = `<button id="restartGameBtn" onclick="restartGame();">Restart game</button>`;

	div.appendChild(nameSpan);


	chatMessages.appendChild(div);


	// scroll to bottom
	chatMessages.scrollTop = chatMessages.scrollHeight;
}





// ---------- GAME LOGIC ---------- //
function attemptSetSymbol() {
    const selectedSymbol = String(symbolSelect.value);
    const customSymbol = String(customSymbolInput.value);
	
	console.log("attemptSetSymbol selectedSymbol:'"+selectedSymbol+"', customSymbol:'"+customSymbol+"'");
    
    let symbolToSet = customSymbol || selectedSymbol;
    if (!symbolToSet || localPlayer.symbol === symbolToSet) return;
	
	console.log("attemptSetSymbol 2");

    let updatedPlayer = { ...localPlayer, symbol: symbolToSet };
    
    const payload = { type: 'player_update', player: updatedPlayer };

    if (isHost) {
		console.log("attemptSetSymbol 3");
        const playerIndex = gameState.players.findIndex(p => p.id === localPlayer.id);
        if (playerIndex > -1) {
            if (gameState.players.some((p, i) => p.symbol === symbolToSet && i !== playerIndex)) {
                lobbyError.textContent = "Symbol is already taken!";
				console.log(lobbyError.textContent);
                setTimeout(() => lobbyError.textContent = "", 2000);
            } else {
                gameState.players[playerIndex].symbol = symbolToSet;
                broadcast({ type: 'game_state', state: gameState });
				console.log("set symbol: "+symbolToSet);
                updateLobbyUI();
            }
        }
    } else {
		console.log("attemptSetSymbol 4");
        sendToHost(payload);
    }
}



function attemptSetSpec() {
    const isSpec = getSpectateValue();

    let updatedPlayer = { ...localPlayer, 
		isSpec: isSpec, 
		colors: newPlayerColor(isSpec),
	};
    
    const payload = { type: 'player_update_spec', player: updatedPlayer };

    if (isHost) {
		console.log("attemptSetSpec host");
        const playerIndex = gameState.players.findIndex(p => p.id === localPlayer.id);
        if (playerIndex > -1) {
			gameState.players[playerIndex].isSpec = isSpec;
			gameState.players[playerIndex].colors = newPlayerColor(isSpec);

			broadcast({ type: 'game_state', state: gameState });
			console.log("set spec: "+isSpec);
			updateLobbyUI();
        }
    } else {
		console.log("attemptSetSpec peer");
        sendToHost(payload);
    }
}



function addGameStateElement(playerId, playerColor, playerName, text) {
	const div = document.createElement("div");
	div.id = `gameState-${playerId}`;

	// Player name in color
	const nameSpan = document.createElement("span");
	nameSpan.style.color = playerColor;
	nameSpan.textContent = playerName;
	nameSpan.id = `gameStateName-${playerId}`;
	
	// Colon + message in white
	const textSpan = document.createElement("span");
	textSpan.style.color = "white";
	textSpan.textContent = text;
	textSpan.id = `gameStateValue-${playerId}`;

	// Add both spans into the div
	div.appendChild(nameSpan);
	div.appendChild(textSpan);

	// Add div to the list
	gameStateList.appendChild(div);

	// Scroll to bottom
	gameStateList.scrollTop = gameStateList.scrollHeight;
	
	console.log("list: added "+playerName);
}

function createGameStateElements(){
	// always empty so players update every time ui updates:
	gameStateList.innerHTML = "";
	//if(!document.getElementById(`gameStateValue-mines`)){
	addGameStateElement("mines", "white", "Remaining", `: ${gameState.totalMines}`);
	for(let i = 0; i < gameState.players.length; i++){
		if(!gameState.players[i].quitted){
			addGameStateElement(gameState.players[i].id, gameState.players[i].colors.color, gameState.players[i].name, ": 0");
		}else{
			console.log("list: failed to add "+gameState.players[i].name);
		
		}
	}
	gameStateList.scrollTop = gameStateList.scrollHeight;
	//}
}
	

function startGame() {
    if (!isHost) return;

/*	// not needed anymore since gameState is changed when spectator state is changed.
	if(getSpectateValue()){
		let player = getPlayerById(localPlayer.id);
		player.isSpec = true; // has to modify this when STARTING the game. 
		player.color = "#FFFFFF";
		//player.name = player.name+" (spec)";
	}
	*/
	
    gameState.gridSize = { x: parseInt(gridXInput.value,10), y: parseInt(gridYInput.value,10) };
	gameState.totalMines = Math.max(1, Math.min(parseInt(totalMinesInput.value,10), gameState.gridSize.x*gameState.gridSize.y)); // minimum = 1, max = w*h
	gameState.totalBombs = Math.max(0, parseInt(totalBombsInput.value,10)); // minimum = 0
	gameState.bombRadius = Math.max(1, parseInt(bombRadiusInput.value,10)); // minimum = 1
    gameState.grid = Array(gameState.gridSize.y).fill(null).map(() => Array(gameState.gridSize.x).fill(null));
    
    const activePlayers = gameState.players.filter(p => !p.isSpec);
    if (activePlayers.length > 0) {
        const randomActivePlayer = activePlayers[Math.floor(Math.random() * activePlayers.length)];
        gameState.currentPlayerIndex = gameState.players.findIndex(p => p.id === randomActivePlayer.id);
    } else {
        gameState.currentPlayerIndex = 0;
        gameState.gameOver = true; // No active players, end immediately
    }

    gameState.gameStarted = true;
	gameState.playStartSound = true;
    gameState.gameOver = gameState.gameOver || false;
    gameState.winner = null;
	gameState.ties = null;
	gameState.lastMoveFailed = false;
	gameState.minemap = generate_map(gameState.gridSize.x, gameState.gridSize.y, gameState.totalMines);
	gameState.minesRemaining = get_remaining_mines();
	gameState.history = [];
	


    broadcast({ type: 'game_state', state: gameState });
    handleMessage({ type: 'game_state', state: gameState }); // Update host locally
    checkForAITurn(); // Check if the first player is an AI
}



function setLastMoveByPlayer(x, y, playerId, weapon) {
    gameState.lastMoves = gameState.lastMoves || {};
    gameState.lastMoves[playerId] = { x, y, weapon};
	gameState.lastMove = { x, y, playerId, weapon};
}


function get_remaining_mines(){
	let mines = 0;
	for(let y = 0; y < gameState.minemap.height; y++){
		for(let x = 0; x < gameState.minemap.width; x++){
			if(gameState.minemap.map[y][x].type < TYPE_EMPTY && gameState.minemap.map[y][x].owner == -1){
				mines++;
			}
		}
	}
	return mines;
}


function get_mines_by_player_index(player_index){
	let mines = 0;
	for(let y = 0; y < gameState.minemap.height; y++){
		for(let x = 0; x < gameState.minemap.width; x++){
			if(gameState.minemap.map[y][x].owner == player_index){
				mines++;
			}
		}
	}
	return mines;
}


function get_active_players(){
	return gameState.players.filter(p => !p.isSpec);
}

function active_players_count(){
	let active = get_active_players();
	return active.length;
}

function advanceToNextPlayer() {
    if (gameState.players.length === 0) return;
    const activePlayers = get_active_players();
    if (activePlayers.length === 0) {
        // No active players left, end the game.
        gameState.gameOver = true;
        gameState.winner = null;
        gameState.ties = [];
        return;
    }
	
    let nextIndex = gameState.currentPlayerIndex;
    do {
        nextIndex = (nextIndex + 1) % gameState.players.length;
    } while (gameState.players[nextIndex].isSpec);
    gameState.currentPlayerIndex = nextIndex;
	
	updateGameInfo();
}




function add_log(move){
	gameState.history.push(move);
	//console.log(gameState.history);
}


function isFirstMove(player){
	return player.firstMove;
}

function isLosingPlayer(player) {
  let playerId = player.id;
  if (!gameState?.players?.length) return false;
  console.log("active_players_count()");
  console.log(active_players_count());
  
  if(active_players_count() == 1){
	player.firstMove = true; // set this as first move so bomb placement rules work always.
	return true; // single player always allow bomb.
  }

  //const player = gameState.players.find(p => p.id === playerId);
  //if (!player){
	//return false;
  //} // player not found

  const playerMines = player.minesFound;

  for (const other of gameState.players) {
    if (other.playerId !== playerId && other.minesFound > playerMines) {
      return true; // someone has more mines → losing
    }
  }

  // No one has more mines (tie or leading)
  return false;
}




function handlePlayerMove(move) {
	let {x, y, playerId, weapon} = move;
	
    if (gameState.gameOver){
		return;
	}

    
    const player = gameState.players[gameState.currentPlayerIndex];
    if (player.id !== playerId) return;


	gameState.lastMoveFailed = false;
	
	if(weapon == MOVE_TYPE_NORMAL){
		// dont allow clicking on blocked cell
		if(!gameState.minemap.map[y][x].visible && !gameState.minemap.map[y][x].isBlocked){
			revealZeros(gameState.minemap, x, y, gameState.grid);
			
			if(gameState.minemap.map[y][x].type >= TYPE_EMPTY){
				// no mine hit, end turn, next turn is first move again:
				player.firstMove = true;
                advanceToNextPlayer();
			}else{
				// mine hit, no longer first move (cannot use bomb after found a mine)
				player.firstMove = false;
				gameState.minemap.map[y][x].owner = gameState.currentPlayerIndex;
				gameState.minesRemaining = get_remaining_mines();
				let currentPlayerMinesFound = get_mines_by_player_index(gameState.currentPlayerIndex);
				player.minesFound = currentPlayerMinesFound;
			}
			
			setLastMoveByPlayer(x, y, player.id, weapon);

			gameState.lastMoveFailed = false;
		}else{
			
			gameState.lastMoveFailed = true;
		}

		

	}else if(weapon == MOVE_TYPE_BOMB){
		//console.warn("MOVE_TYPE_BOMB: player.firstMove = "+player.firstMove);
		// allow bomb only when you are not leading.
		if(isLosingPlayer(player) && isFirstMove(player) && player.bombsUsed < gameState.totalBombs){
			let bombStyle = 0;
			if(bombStyle == 0){
				revealBombZeros(gameState.minemap, x, y, gameState.grid);
			}else{
				revealBombAirplaneZeros(gameState.minemap, x, y, gameState.grid);
			}
			

			
			gameState.minesRemaining = get_remaining_mines();
			let currentPlayerMinesFound = get_mines_by_player_index(gameState.currentPlayerIndex);
			player.minesFound = currentPlayerMinesFound;
			player.bombsUsed++;

			// end turn, next turn is first move again:
			player.firstMove = true;
            advanceToNextPlayer();
			
			setLastMoveByPlayer(x, y, player.id, weapon);
			
			gameState.lastMoveFailed = false;
		}else{
			
			gameState.lastMoveFailed = true;
		}
	}
	
	if(!gameState.lastMoveFailed){
		add_log(move);
	
		
		let endState = checkEndState();
		
		if(endState.winner){
			gameState.gameOver = true;
			gameState.winner = endState.winner;
		}else if(endState.ties && endState.ties.length > 0){
			gameState.gameOver = true;
			gameState.winner = null;
			gameState.ties = endState.ties;
		}
		
		// update darker water map:
		count_map_numbers_around(gameState.minemap);
		mark_percentages();
		
		broadcast({ type: 'game_state', state: gameState });
		handleMessage({ type: 'game_state', state: gameState });
		checkForAITurn(); // Check if the next player is an AI
	}else{
		console.log("lastMoveFailed");
	}
}



let PLAYER_CHANCE_NONE = 0;
let PLAYER_CHANCE_TIE = 1;
let PLAYER_CHANCE_WIN = 2;


let PLAYER_STATUS_NONE = 0;
let PLAYER_STATUS_TIE = 1;
let PLAYER_STATUS_WIN = 2;


function countChances(playerStatuses){
	let winnerList = [];
	let tieList = [];
	let noneList = [];
	for(const playerId in playerStatuses){
		let playerStatus = playerStatuses[playerId];
		
		// check how many win statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_WIN){
			winnerList.push(playerId);
		}
		// check how many tie statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_TIE){
			tieList.push(playerId);
		}
		// check how many none statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_NONE){
			noneList.push(playerId);
		}
	}
	return {none: noneList, tie: tieList, win: winnerList};
}


function createPlayersState(minesRemaining, playersMinesFound){
	let testData = {
		minesRemaining: minesRemaining, 
		players: [],
	};
	for(let i = 0; i < playersMinesFound.length; i++){
		let player = {
			id: "p"+(i+1),
			minesFound: playersMinesFound[i],
		};
		testData.players.push(player);
	}
	return testData;
}

function testWin(minesRemaining, playersMinesFound){
	let testData = createPlayersState(minesRemaining, playersMinesFound);
	//console.log("testData:");
	//console.log(testData);

	let endstate = checkEndState(testData);
	//console.log("endstate:");
	//console.log(endstate);
		
	let resultList = {};
	// initialize:
	for(let i = 0; i < playersMinesFound.length; i++){
		let player = testData.players[i];
		resultList[player.id] = `${player.id}: ${player.minesFound} (NO)`;
	}
	// add ties:
	if(endstate.ties.length > 0){

		for(let i = 0; i < endstate.ties.length; i++){
			let player = endstate.ties[i];
			
			resultList[player.id] = `${player.id}: ${player.minesFound} (TIE)`;
		}
	}
	// add winner:
	if(endstate.winner){
		let player = endstate.winner;
		resultList[player.id] = `${player.id}: ${player.minesFound} (WIN)`;
	}
	
	//console.log("resultList");
	//console.log(structuredClone(resultList));
	
	let resultsArr = [];
	for (const value of Object.values(resultList)) {
	  resultsArr.push(value);
	}
	
	let resjoin = resultsArr.join(",  ");
	
	console.log(resjoin);
	
	return resjoin;
}





function checkEndState(testData = null){
	let minesRemaining = 0;
	let playersListRaw;
	
	if(testData){
		minesRemaining = testData.minesRemaining;
		playersListRaw = testData.players;
	}else{
		minesRemaining = gameState.minesRemaining;
		playersListRaw = gameState.players;
	}

	// get only active players:
    const playersList = playersListRaw.filter(p => !p.isSpec);

    if (playersList.length === 0) {
        return { ties: [], winner: null };
    }
	
	let playerStatuses = {};
	for (const player of playersList) {
		playerStatuses[player.id] = {chance: PLAYER_CHANCE_NONE, status: PLAYER_STATUS_NONE};
	}

	//console.log("playerStatuses1:");
	//console.log(structuredClone(playerStatuses));
	
	// find max mines of any player:
	let maxPlayerMines = -1;
	for (const player of playersList) {
		if(player.minesFound > maxPlayerMines){
			maxPlayerMines = player.minesFound;
		}
	}
	//console.log("maxPlayerMines = "+maxPlayerMines);
	
	let tieList = [];
	let winnerPlayer = null;
	
	if(playersList.length == 1){
		//console.log("playersList.length == 1");
		// allow playing alone until all mines found:
		if(minesRemaining == 0){
			winnerPlayer = playersList[0];
		}
	}else{
		
		if(minesRemaining == 0){
			
			//console.log("minesRemaining == 0");
			
			// check end state when no mines are remaining:
			for (const player of playersList) {
				let playerStatus = playerStatuses[player.id];

				// 2=none, 2=none, 4=tie, 4=tie

				if(player.minesFound < maxPlayerMines){
					playerStatus.chance = PLAYER_CHANCE_NONE;
				}else if(player.minesFound == maxPlayerMines){
					playerStatus.chance = PLAYER_CHANCE_WIN;
				}
			}
			
			//console.log("playerStatuses2a:");
			//console.log(structuredClone(playerStatuses));
			
			let chances = countChances(playerStatuses);
			
			//console.log("chances2a:");
			//console.log(structuredClone(chances));
			
			// clear winner if only one "win" found:
			// 2=none, 2=none, 4=tie
			if(chances.win.length == 1){
				//console.log("chances.win.length == 1");
				//playerStatuses[chances.win[0]].status = PLAYER_STATUS_WIN;
				winnerPlayer = getPlayerById(chances.win[0], playersList);
			}else{
				//console.log("chances.win.length > 1");
				
				// no winner, multiple winners found:
				// 2=none, 2=none, 4=tie, 4=tie
				for(let i = 0; i < chances.win.length; i++){
					//playerStatuses[chances.win[i]].status = PLAYER_STATUS_TIE;
					tieList.push(getPlayerById(chances.win[i], playersList));
				}
			}
			
		}else{
			// check if game could still continue due to tie or win chance:
			for (const player of playersList) {
				let playerStatus = playerStatuses[player.id];
				
				let nextTurnPossibleMove = player.minesFound + minesRemaining;

				// minesRemaining: 2
				// maxplayer: 4
				// before: 0,2,3,4
				//  after: 2,4,5,6
				//         N,T,W,W
				
				if(player.minesFound < maxPlayerMines){
					if(nextTurnPossibleMove < maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_NONE;
					}else if(nextTurnPossibleMove == maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_TIE;
					}else if(nextTurnPossibleMove > maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_WIN;
					}
				}else{
					playerStatus.chance = PLAYER_CHANCE_WIN;
				}
			}
			
			//console.log("playerStatuses2b:");
			//console.log(structuredClone(playerStatuses));
			
			let chances = countChances(playerStatuses);
			
			//console.log("chances2b:");
			//console.log(structuredClone(chances));
			
			// clear winner:
			// 2=none, 2=none, 4=win
			if(chances.win.length == 1){
				if(chances.tie.length == 0){
					//playerStatuses[chances.tie[0]].status = PLAYER_STATUS_WIN;
					winnerPlayer = getPlayerById(chances.win[0], playersList);
					//console.log("chances.win[0]");
					//console.log(chances.win[0]);
					//console.log("playersList");
					//console.log(playersList);
					//console.log("winnerPlayer");
					//console.log(winnerPlayer);
					
				}
			}
			// tie is not possible when mines are still remaining.
		}
	}
	
	
	return {ties: tieList, winner: winnerPlayer};
}






function hexToRgba(hex, alpha = 1) {
  // Remove leading # if present
  hex = hex.replace(/^#/, '');

  // Parse short form #abc
  if (hex.length === 3) {
    hex = hex.split('').map(c => c + c).join('');
  }

  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}


// updateui update ui
function updateGameInfo() {
    if (!gameState.gameStarted) return;

	const currentPlayer = gameState.players[gameState.currentPlayerIndex];
	
	createGameStateElements();

    if (gameState.gameOver) {

        if (gameState.winner) {
			gameInfo.style.backgroundColor = hexToRgba(gameState.winner.colors.color, 0.6);
			
			if(gameState.winner.id === localPlayer.id){
				gameInfo.textContent = `You won the game!`;
			}else{
				gameInfo.textContent = `${gameState.winner.name} won the game!`;
			}
        } else {
			gameInfo.style.backgroundColor = hexToRgba("#000000", 0.6);
			
			if(gameState.ties && gameState.ties.length > 0){
				let tieListStr = "It's a tie for players: ";
				let tieListNames = gameState.ties.map(p => p.name);
				gameInfo.textContent = tieListStr + tieListNames.join(", ");
			} else {
                gameInfo.textContent = "Game Over. No winner.";
            }
        }
		
		addRestartMessage();

    } else {
		gameInfo.style.backgroundColor = hexToRgba(currentPlayer.colors.color, 0.6);
		let turnText = "";
		if(currentPlayer.id === localPlayer.id){
			turnText = "Your Turn";
		}else{
			turnText = `${currentPlayer.name}'s Turn`;
		}
        gameInfo.textContent = `${turnText}`;
    }
	
	
	// update scores for all players:
	for(let i = 0; i < gameState.players.length; i++){
		let playerMinesValue = document.getElementById(`gameStateValue-${gameState.players[i].id}`);
		if(playerMinesValue){
			playerMinesValue.textContent = ": "+gameState.players[i].minesFound;
			
			let playerNameElem = document.getElementById(`gameStateName-${gameState.players[i].id}`);
			playerNameElem.classList.remove("focusedPlayer");
			if(gameState.currentPlayerIndex == i){
				playerNameElem.classList.add("focusedPlayer");
			}
		}
	}
	
	let remainingMinesValue = document.getElementById(`gameStateValue-mines`);
	remainingMinesValue.textContent = ": "+gameState.minesRemaining;
	
	
}


// ---------- CANVAS DRAWING & INTERACTION ---------- //
let viewport = {
    x: 0, y: 0, scale: 1,
    minScale: 0.2, maxScale: 5,
};
let panState = {
    isPanning: false,
    startX: 0, startY: 0,
};
let lastTap = 0;
let cellSize = 50;

let startTime = Date.now();



function hasMoveAt(x, y) {
  return Object.entries(gameState.lastMoves).some(([playerId, move]) => {
    if (playerId === localPlayer.id) return false; // ignore self
    return move.x === x && move.y === y;
  });
}



const fps = 70;
let lastTime = 0;
let frameDuration = 1000 / fps; // target 60 FPS
let frameCount = 0;
let fpsSum = 0;
let lastFpsUpdate = 0;
let averageFps = 0;




function gameLoop(timestamp) {
  // First frame setup
  if (!lastTime) lastTime = timestamp;

  // Calculate delta time
  const delta = timestamp - lastTime;

  // Update FPS calculations every frame
  const fps = 1000 / delta;
  fpsSum += fps;
  frameCount++;

  // Update average every second
  if (timestamp - lastFpsUpdate >= 2000) {
    averageFps = fpsSum / frameCount;
	if(gameState.gameStarted){
		console.log("Average FPS:", averageFps.toFixed(1));
	}
    // reset counters
    frameCount = 0;
    fpsSum = 0;
    lastFpsUpdate = timestamp;
  }

  // Game update
  if (delta >= frameDuration) {
    lastTime = timestamp;
    draw();
  }

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);









let sounds = {
	miss:      {filename: "sounds/miss.mp3",      gain: 1,   filter: false},
	miss_long: {filename: "sounds/miss_long.mp3", gain: 1,   filter: false},
	hit:       {filename: "sounds/hit.mp3",       gain: 0.3, filter: true},
	bigsplash: {filename: "sounds/bigsplash.mp3", gain: 1,   filter: false},
	victory:   {filename: "sounds/victory.mp3",   gain: 1,   filter: false},
	warning:   {filename: "sounds/warning.mp3",   gain: 1,   filter: false},
	startgame: {filename: "sounds/startgame.mp3", gain: 0.2,   filter: false},
};

// Preload all sounds
for (const key in sounds) {
  loadSound(sounds[key].filename); // call your loadSound function for each file
}


const context = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds

function loadSound(src) {
  return fetch(src)
    .then(res => res.arrayBuffer())
    .then(data => context.decodeAudioData(data))
    .then(decoded => {
      soundBuffers[src] = decoded; // store buffer by filename
      return decoded; // also return it
    });
}


function playSound(src) {
	let sound = sounds[src];
	const buffer = soundBuffers[sound.filename];
	if (!buffer) return; // sound not loaded yet

	const source = context.createBufferSource();
	source.buffer = buffer;

	// Create a gain node for volume control
	const gainNode = context.createGain();
	gainNode.gain.value = sound.gain; // 1.0 = 100%, 0.5 = 50%, etc.

	if (sound.filter) {
		// Create and use filter
		const filter = context.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = 3000; // let only frequencies below ~3kHz pass

		source.connect(filter);
		filter.connect(gainNode);
	} else {
		// Connect directly
		source.connect(gainNode);
	}

	gainNode.connect(context.destination);
	source.start();
}


const img_water_tilemap = new Image();
//img_water_tilemap.src = "images/homm3-water-padded.webp";






const img_water1 = new Image();
img_water1.src = "images/water1.png";
const img_water2 = new Image();
img_water2.src = "images/water2.png";
const img_water3 = new Image();
img_water3.src = "images/water3.png";

const img_empty = new Image();
img_empty.src = "images/empty.png";
const img_empty2 = new Image();
img_empty2.src = "images/empty2.png";


const img_flag_red = new Image();
img_flag_red.src = "images/red1.png";
const img_flag_blue = new Image();
img_flag_blue.src = "images/blue1.png";
const img_flag_yellow = new Image();
img_flag_yellow.src = "images/yellow1.png";
const img_flag_green = new Image();
img_flag_green.src = "images/green1.png";
const img_flag_gray = new Image();
img_flag_gray.src = "images/gray.png";

const img_flag_pirate = new Image();
img_flag_pirate.src = "images/pirate.png";

/*
const img_flag_red = new Image();
img_flag_red.src = "newimgs/red.png";
const img_flag_blue = new Image();
img_flag_blue.src = "newimgs/blue.png";
const img_flag_yellow = new Image();
img_flag_yellow.src = "newimgs/yellow.png";
const img_flag_green = new Image();
img_flag_green.src = "newimgs/green.png";
*/

const img_mine = new Image();
img_mine.src = "images/mine-dark-rotated-small-pad.png";

const img_cursor = new Image();
img_cursor.src = "images/cursor.png";

/*
const img_n1 = new Image(); img_n1.src = "images/numbers/1.png";
const img_n2 = new Image(); img_n2.src = "images/numbers/2.png";
const img_n3 = new Image(); img_n3.src = "images/numbers/3.png";
const img_n4 = new Image(); img_n4.src = "images/numbers/4.png";
const img_n5 = new Image(); img_n5.src = "images/numbers/5.png";
const img_n6 = new Image(); img_n6.src = "images/numbers/6.png";
const img_n7 = new Image(); img_n7.src = "images/numbers/7.png";
const img_n8 = new Image(); img_n8.src = "images/numbers/8.png";
*/

let images = {
	water: [img_water1, img_water2, img_water3],
	empty: img_empty,
	empty2: img_empty2,
	//numbers: [null, img_n1, img_n2, img_n3, img_n4, img_n5, img_n6, img_n7, img_n8],
	flag: {
		red: img_flag_red,
		blue: img_flag_blue,
		yellow: img_flag_yellow,
		green: img_flag_green,
		gray: img_flag_gray,
		pirate: img_flag_pirate,
	},
	mine: img_mine,
	cursor: img_cursor,
};


let numbercolors = [
	"",
	"#050DA5", // 1
	"#246100", // 2
	"#BC0C00", // 3
	"#0E0C71", // 4
	"#733F00", // 5
	"#FF0F8B", // 6 magentaish
	"#83FF5D", // 7 light yellow
	"#FFFFFF"  // 8
];

function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}



document.fonts.load('16px "Nimbus Sans L"').then(() => {console.log('font loaded: Nimbus Sans L (normal)');});
document.fonts.load('bold 16px "Nimbus Sans L"').then(() => {console.log('font loaded: Nimbus Sans L (bold)');});



  
/*
function drawImage(ctx, image, offsetX, offsetY, x, y, cellSize, scale){
	ctx.drawImage(
		image,
		offsetX + x*cellSize - 0.5,
		offsetY + y*cellSize - 0.5,
		cellSize + 1,
		cellSize + 1
	);
}*/


// these renders differently on mobile and pc... had to put add1=0.5 so it looks better on mobile.
let add1 = 0.5; // was 1, didnt render symmetrically.
let add2 = 0; // was -0.5, useless... only adjusts font position basically.

function drawImage(ctx, image, offsetX, offsetY, x, y, cellSize, scale = 1) {
  // Target width/height after scaling
  const drawSize = cellSize * scale+add1;

  // Center the scaled image inside the square
  const posX = offsetX + x * cellSize + (cellSize - drawSize) / 2+add2;
  const posY = offsetY + y * cellSize + (cellSize - drawSize) / 2+add2;

  ctx.drawImage(image, posX, posY, drawSize, drawSize);
}



// for numbers drawing (not used)
function drawImageCustom(ctx, image, offsetX, offsetY, x, y, cellSize, drawSizeX, drawSizeY, scale = 1) {
  // Center the scaled image inside the square
  const posX = offsetX + x * cellSize + (cellSize - drawSizeX) / 2-0.5;
  const posY = offsetY + y * cellSize + (cellSize - drawSizeY) / 2-0.5;

  ctx.drawImage(image, posX, posY, drawSizeX, drawSizeY);
}


let ad1 = -0.5; // was -1 for somer reason
let ad2 = 0; // was 2 for somer reason

function drawTransparentSquare(ctx, x, y, size, color, alpha = 0.5) {
  ctx.save();
  ctx.globalAlpha = alpha;  // set transparency
  ctx.fillStyle = color;    // e.g. "red" or "#00ff00"
  ctx.fillRect(x+ad1, y+ad1, size+ad2, size+ad2);
  ctx.restore();
}



let MAX_CELL_FRAMES = 20;

let DEBUG_STATS = 0;
let USE_FONT = 1;

let WATER_STYLE = 0;

function draw_water_tile(ctx, mapcell, offsetX, offsetY, x, y, cellSize){
	if(WATER_STYLE == 0){
		drawImage(ctx, images.water[mapcell.waternum%3], offsetX, offsetY, x, y, cellSize);
	}else{
		let destX = offsetX + x * cellSize;
		let destY = offsetY + y * cellSize;
		//drawRandomTile(ctx, mapcell, img_water_tilemap, destX, destY, cellSize);
	}
}


function drawRandomTile(ctx, mapcell, bigImage, destX, destY, destSize = 50) {
	const tilesX = 7;
	const tilesY = 7;
	const tileSize = 128;
	const padding = 1;
	
	let ran = mapcell.waternum % 49;

	const randomX = ran % tilesX;    // x-coordinate in grid
	const randomY = Math.floor(ran / tilesX); // y-coordinate in grid


	const sourceX = padding + randomX * tileSize;
	const sourceY = padding + randomY * tileSize;

	ctx.drawImage(
		bigImage,
		sourceX, sourceY,
		tileSize, tileSize,
		destX, destY,
		destSize, destSize
	);
}




function worldToScreen(wx, wy, viewport, canvas) {
    // Apply same transforms in reverse
    let sx = (wx + viewport.x) * viewport.scale + canvas.width / 2;
    let sy = (wy + viewport.y) * viewport.scale + canvas.height / 2;
    return { x: sx, y: sy };
}


// draw circles pointers suuntimat drawoverlay
function drawMoveDirectionsOverlay(ctx, offsetX, offsetY, cellSize, pulse) {
	ctx.save();

	for (const playerId in gameState.lastMoves) {
		const move = gameState.lastMoves[playerId];
		let player = getPlayerById(playerId);
		
		// dont show your own move pointer.
		if(playerId == localPlayer.id){
			continue;
		}
		// dont show for quitters (set as specs)
		if(player.isSpec){
			continue;
		}
	
		let worldX = offsetX + move.x*cellSize + cellSize/2;
		let worldY = offsetY + move.y*cellSize + cellSize/2;
		
		const { x, y } = worldToScreen(worldX, worldY, viewport, canvas);

		// Check if outside screen
		if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
			continue; // it's visible, no need to draw edge indicator
		}

		// Find intersection point on canvas edge
		let edgeX = x;
		let edgeY = y;

		// Clamp to screen bounds
		if (x < 0) edgeX = 0;
		if (x > canvas.width) edgeX = canvas.width;
		if (y < 0) edgeY = 0;
		if (y > canvas.height) edgeY = canvas.height;


		let opacity = 1;
		
		// black edges for visibility:
		ctx.beginPath();
		ctx.arc(edgeX, edgeY, 25*pulse, 0, Math.PI * 2);
		ctx.fillStyle = `rgba(0,0,0, ${opacity})`;
		ctx.fill();
		
		drawCircle(ctx, 0, 0, edgeX, edgeY, 20*pulse, 3, `rgba(255,255,255, ${opacity})`);
		
		// draw with player color:
		ctx.beginPath();
		ctx.arc(edgeX, edgeY, 17*pulse, 0, Math.PI * 2);
		ctx.fillStyle = hexToRgba(player.colors.color, opacity);
		ctx.fill();
	}
	
	ctx.restore();
}




function draw_flag(ctx, mapcell, animcell, offsetX, offsetY, x, y, cellSize, scale){
	if(gameState.players[mapcell.owner]){
		let playerFlag = gameState.players[mapcell.owner].colors.flag;
		if(images.flag[playerFlag]){
			drawImage(ctx, images.flag[playerFlag], offsetX, offsetY, x, y, cellSize, scale);
		}else{
			// pirate = not found
			drawImage(ctx, images.flag["pirate"], offsetX, offsetY, x, y, cellSize, scale);
		}
	}else{
		// pirate = not found
		drawImage(ctx, images.flag["pirate"], offsetX, offsetY, x, y, cellSize, scale);
	}
	
	/*
	// todo: fix flag colors, will rely on player index, they can differ when specs added etc.
	if(mapcell.owner == 0){
		drawImage(ctx, images.flag.red, offsetX, offsetY, x, y, cellSize, scale);
	}else if(mapcell.owner == 1){
		drawImage(ctx, images.flag.blue, offsetX, offsetY, x, y, cellSize, scale);
	}else if(mapcell.owner == 2){
		drawImage(ctx, images.flag.yellow, offsetX, offsetY, x, y, cellSize, scale);
	}else{
		// rest of the players have same flag color:
		drawImage(ctx, images.flag.green, offsetX, offsetY, x, y, cellSize, scale);
	}
	*/
}



// render()
function draw() {
    if (!gameState.gameStarted) return;
	
	const time = (Date.now() - startTime) / 1000; // seconds
	const pulse = 1 + 0.4 * Math.sin(time * 4);   // oscillates between 0.8–1.2
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(viewport.scale, viewport.scale);
    ctx.translate(viewport.x, viewport.y);

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    // Draw symbols
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${cellSize * 0.7}px sans-serif`;
    
    for (let y = 0; y < gameState.gridSize.y; y++) {
        for (let x = 0; x < gameState.gridSize.x; x++) {
			let drawCell = true;
			// World coordinates of the cell (before scaling/translation)
			const worldX = offsetX + x * cellSize;
			const worldY = offsetY + y * cellSize;

			// Convert to screen coordinates
			const screenX = (worldX + viewport.x) * viewport.scale + canvas.width / 2;
			const screenY = (worldY + viewport.y) * viewport.scale + canvas.height / 2;
			const screenSize = cellSize * viewport.scale;
			
			const mapcell = gameState.minemap.map[y][x];
			const animcell = localState.animations.map[y][x];
			
			// check if square is inside visible screen area:
			const margin = 0; 
			if (
			  screenX + screenSize < 0 + margin ||    // left (shrink visible area)
			  screenY + screenSize < 0 + margin ||    // top
			  screenX > canvas.width - margin ||      // right
			  screenY > canvas.height - margin        // bottom
			) {
			  drawCell = false; // skip drawing this cell
			}
			
			if(mapcell.isBlocked){
				drawCell = false;
			}
	
			
			let scale = 1;
			
			if(mapcell.visible){
				scale = (animcell.frame/MAX_CELL_FRAMES);
			}
			
			
			if(drawCell){

				if(mapcell.visible){
				
					// draw numbers or empty:
					if (mapcell.type >= TYPE_EMPTY){
						// draw water under the numbers first:
						if(animcell.frame < MAX_CELL_FRAMES){
							//drawImage(ctx, images.water[mapcell.waternum%3], offsetX, offsetY, x, y, cellSize);
							draw_water_tile(ctx, mapcell, offsetX, offsetY, x, y, cellSize);
						}
						// draw empty background under numbers:
						if(mapcell.type == TYPE_EMPTY){
							drawImage(ctx, images.empty2, offsetX, offsetY, x, y, cellSize, scale);
						}else{
							drawImage(ctx, images.empty, offsetX, offsetY, x, y, cellSize, scale);
						}
					}else{
						// draw mines:
						
						// draw water first:
						//drawImage(ctx, images.water[mapcell.waternum%3], offsetX, offsetY, x, y, cellSize);
						draw_water_tile(ctx, mapcell, offsetX, offsetY, x, y, cellSize);
						
						
						draw_flag(ctx, mapcell, animcell, offsetX, offsetY, x, y, cellSize, scale);
						
						
		
					}

				}else{
					// draw water only:
					//drawImage(ctx, images.water[mapcell.waternum%3], offsetX, offsetY, x, y, cellSize);
					draw_water_tile(ctx, mapcell, offsetX, offsetY, x, y, cellSize);
					
					// draw remaining mines if game ended:
					if(gameState.gameOver){
						if(mapcell.type < TYPE_EMPTY){
							drawImage(ctx, images.mine, offsetX, offsetY, x, y, cellSize, 1);
						}
					}
					
					// draw dark layer over dark water areas:
					if(mapcell.numbersAround == 0 && !mapcell.isBlocked){
						drawTransparentSquare(ctx, offsetX+x*cellSize, offsetY+y*cellSize, cellSize, "#000088", alpha = 0.4); 
					}
				}
				
				if(mapcell.isBlocked){
					drawTransparentSquare(ctx, offsetX+x*cellSize, offsetY+y*cellSize, cellSize, "#000000", alpha = 0.8); 
				}

				// draw numbers:
				if (gameState.grid[y] && gameState.grid[y][x]) {
					if(USE_FONT){
						let baseSize = cellSize * (scale*0.8);
						let fontSize = baseSize;

						ctx.font = `bold ${fontSize}px Nimbus Sans L`;
						ctx.fillStyle = numbercolors[mapcell.type];
						ctx.fillText(
						  gameState.grid[y][x],
						  offsetX + x * cellSize + cellSize / 2,
						  offsetY + y * cellSize + cellSize / 2+5
						);
					
					}else{
						let baseSize = cellSize * (scale*0.6);
						let drawSizeX = (133/188)*baseSize;
						let drawSizeY = baseSize;
						//drawImageCustom(ctx, images.numbers[gameState.grid[y][x]], offsetX, offsetY, x, y, cellSize, drawSizeX, drawSizeY, scale);
					
					}
				}
				
				
				if(DEBUG_STATS){
					if(gameState.minemap.chances[y][x].checked && !gameState.minemap.map[y][x].visible){
						let percent = Math.round(gameState.minemap.chances[y][x].percent*100);
						ctx.font = `bold 15px sans-serif`;
						ctx.fillStyle = gameState.minemap.chances[y][x].color;
						ctx.fillText(
						  percent,
						  offsetX + x * cellSize + cellSize / 2,
						  offsetY + y * cellSize + cellSize / 2
						);
					}
					
					
					if(gameState.minemap.chances2[y][x].checked){
						ctx.font = `bold 13px sans-serif`;
						ctx.fillStyle = "red";
						ctx.fillText(
						  gameState.minemap.chances2[y][x].mines,
						  offsetX + x * cellSize + cellSize/2 - cellSize/3,
						  offsetY + y * cellSize + cellSize/2 - cellSize/4
						);
						
						ctx.font = `bold 13px sans-serif`;
						ctx.fillStyle = "blue";
						ctx.fillText(
						  gameState.minemap.chances2[y][x].empty,
						  offsetX + x * cellSize + cellSize/2 - cellSize/3,
						  offsetY + y * cellSize + cellSize/2 + cellSize/4
						);
					}
				
				}
			}
			
			
			if(mapcell.visible){
				animcell.frame++;
				if(animcell.frame >= MAX_CELL_FRAMES){
					animcell.frame = MAX_CELL_FRAMES;
				}
			}
        }
    }
	
	
	// draw last moves circles and crosshairs:
	for (const playerId in gameState.lastMoves) {
		const move = gameState.lastMoves[playerId];
		let player = getPlayerById(playerId);
		// dont show for quitters: (set as specs)
		if(!player.isSpec){
			drawCorners(ctx, 
				offsetX+move.x*cellSize, 
				offsetY+move.y*cellSize, cellSize, player.colors.color, pulse*0.9
			);
		}
		
		/*
		if(!gameState.gameOver && player.id !== localPlayer.id){
			
			let maxsize = Math.max(gameState.gridSize.x, gameState.gridSize.y)*cellSize;
			
			const pulse2 = 0.1+(1+Math.sin(time * 4))/2;
    
	
			// shadow
			drawCircle(ctx, offsetX, offsetY, 
				move.x*cellSize+cellSize/2, 
				move.y*cellSize+cellSize/2, maxsize*pulse2, 7, "rgba(0,0,0,0.2)"
			);
			drawCircle(ctx, offsetX, offsetY, 
				move.x*cellSize+cellSize/2, 
				move.y*cellSize+cellSize/2, maxsize*pulse2, 3, hexToRgba(player.colors.color, 1)
			);
		}*/

	}

 
	// draw cursor:
	if(renderMouse){
		drawImage(ctx, images.cursor, offsetX, offsetY, mousePos.x, mousePos.y, cellSize, 1.25);
	}



    ctx.restore();
	
	
	drawMoveDirectionsOverlay(ctx, offsetX, offsetY, cellSize, pulse*0.8);
}

// randomname random name random nick
function randomPlayerName() {
	const prefixes = [
		"al", "bel", "cor", "dar", "el", "fen", "gal", "hal", "jor", "kal",
		"lin", "mor", "nor", "or", "pel", "quil", "ron", "sel", "tor", "val"
	];

	const middles = [
		"a", "e", "i", "o", "u", "ae", "ia", "eo", "ou", "ai"
	];

	const suffixes = [
		"dor", "mar", "ric", "tan", "ven", "win", "bar", "dris", "lith", "zor",
		"thus", "mir", "gorn", "las", "thar", "mond"
	];

	const endings = [
		"son", "ton", "ley", "well", "ford", "smith", "shire", "worth", "more", "vell"
	];

	function capitalize(word) {
		return word.charAt(0).toUpperCase() + word.slice(1);
	}

	const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
	const middle = middles[Math.floor(Math.random() * middles.length)];
	const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
	const ending = endings[Math.floor(Math.random() * endings.length)];

	return capitalize(prefix + middle + suffix);
}






function drawCorners(ctx, x, y, cellSize, color, scale = 1) {
	const lineWidth = 5 * scale;
	const len = (cellSize / 5) * scale; // "leg" length scaled
	const half = cellSize / 2;

	ctx.save();
	
		ctx.translate(x + half, y + half); // move origin to center
		ctx.scale(scale, scale);           // scale relative to center
		ctx.translate(-half, -half);       // move back

		ctx.strokeStyle = "rgba(0,0,0, 1)";
		ctx.lineWidth = lineWidth+2;
		
		ctx.beginPath();

			// Top-left corner
			ctx.moveTo(0, len);
			ctx.lineTo(0, 0);
			ctx.lineTo(len, 0);

			// Top-right corner
			ctx.moveTo(cellSize - len, 0);
			ctx.lineTo(cellSize, 0);
			ctx.lineTo(cellSize, len);

			// Bottom-right corner
			ctx.moveTo(cellSize, cellSize - len);
			ctx.lineTo(cellSize, cellSize);
			ctx.lineTo(cellSize - len, cellSize);

			// Bottom-left corner
			ctx.moveTo(len, cellSize);
			ctx.lineTo(0, cellSize);
			ctx.lineTo(0, cellSize - len);

		ctx.stroke();
	
	
		ctx.strokeStyle = hexToRgba(color, 1);
		ctx.lineWidth = lineWidth;
		
		ctx.beginPath();

			// Top-left corner
			ctx.moveTo(0, len);
			ctx.lineTo(0, 0);
			ctx.lineTo(len, 0);

			// Top-right corner
			ctx.moveTo(cellSize - len, 0);
			ctx.lineTo(cellSize, 0);
			ctx.lineTo(cellSize, len);

			// Bottom-right corner
			ctx.moveTo(cellSize, cellSize - len);
			ctx.lineTo(cellSize, cellSize);
			ctx.lineTo(cellSize - len, cellSize);

			// Bottom-left corner
			ctx.moveTo(len, cellSize);
			ctx.lineTo(0, cellSize);
			ctx.lineTo(0, cellSize - len);

		ctx.stroke();
		
	ctx.restore();
}



function adjustCanvasSize() {
 const chat = document.getElementById('chat');
  const canvas = document.getElementById('game-canvas');

  // get height of chat box
  const chatHeight = chat.offsetHeight;

  // move canvas below it
  canvas.style.top = chatHeight + 'px';

  // set canvas display size
  canvas.style.height = (window.innerHeight - chatHeight) + 'px';
  canvas.style.width = '100%';

  // match internal pixel size (this fixes stretching)
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
}
//window.addEventListener('load', adjustCanvasSize);



function resizeCanvas() {



    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
	
	//adjustCanvasSize();

	
    if (gameState.gameStarted) {
        draw();
    }
	
	
}


let mousePos = { x: 0, y: 0 };
let renderMouse = true;

function mouseInsideMap(){
	if(mousePos.x >= 0 && mousePos.x < gameState.gridSize.x){
		if(mousePos.y >= 0 && mousePos.y < gameState.gridSize.y){
			return true;
		}
	}
	return false;
}

function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
	
	//mousePos.x = e.clientX - rect.left;
	//mousePos.y = e.clientY - rect.top;
	mousePos = getGridCoords(e.clientX - rect.left, e.clientY - rect.top);
	renderMouse = true;
	if(!mouseInsideMap()){
		renderMouse = false;
	}
	//console.log(mousePos);
    if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function getGridCoords(canvasX, canvasY) {
    // Inverse transform canvas coordinates to world coordinates
    const worldX = (canvasX - canvas.width / 2) / viewport.scale - viewport.x;
    const worldY = (canvasY - canvas.height / 2) / viewport.scale - viewport.y;

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    const gridX = Math.floor((worldX - offsetX) / cellSize);
    const gridY = Math.floor((worldY - offsetY) / cellSize);

    return { x: gridX, y: gridY };
}



// Canvas event listeners
let panStart = { x: 0, y: 0 };
let isPanning = false;

function onPointerDown(e) {
    if (e.touches && e.touches.length > 1) return;
    isPanning = true;
    const pos = getTouchPos(e);
    panStart.x = pos.x - viewport.x * viewport.scale;
    panStart.y = pos.y - viewport.y * viewport.scale;
}

function onPointerMove(e) {    
	const pos = getTouchPos(e);
	//console.log(pos);
    if (!isPanning || (e.touches && e.touches.length > 1)) return;

    viewport.x = (pos.x - panStart.x) / viewport.scale;
    viewport.y = (pos.y - panStart.y) / viewport.scale;
}

function onPointerUp(e) {
    isPanning = false;
    let currentTime = new Date().getTime();
    if (currentTime - lastTap < 300) {
       onDoubleClick(e);
    }
    lastTap = currentTime;
}

const MOVE_TYPE_NORMAL = 0;
const MOVE_TYPE_BOMB = 1;


function onRightClick(e){
    if (localPlayer.isSpec) return;
    e.preventDefault(); // stops the browser context menu
    if (gameState.gameOver) return;
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (currentPlayer.id !== localPlayer.id) return;
	
	console.log("onRightClick");
	
    const pos = getTouchPos(e);
    const { x, y } = getGridCoords(pos.x, pos.y);

    if (x >= 0 && x < gameState.gridSize.x && y >= 0 && y < gameState.gridSize.y) {
        const move = { x, y, playerId: localPlayer.id, weapon: MOVE_TYPE_BOMB };
        if (isHost) {
            handlePlayerMove(move);
        } else {
            sendToHost({ type: 'player_move', move });
        }
    }
	
}



function onDoubleClick(e) {
    if (localPlayer.isSpec) return;
    if (gameState.gameOver) return;
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (currentPlayer.id !== localPlayer.id) return;
	
	console.log("onDoubleClick");

    const pos = getTouchPos(e);
    const { x, y } = getGridCoords(pos.x, pos.y);


    if (x >= 0 && x < gameState.gridSize.x && y >= 0 && y < gameState.gridSize.y) {
        const move = { x, y, playerId: localPlayer.id, weapon: MOVE_TYPE_NORMAL};
        if (isHost) {
            handlePlayerMove(move);
        } else {
            sendToHost({ type: 'player_move', move });
        }
    }
}

let lastDist = 0;
function onTouchStart(e) {
    if (e.touches.length > 1) { 
        isPanning = false; 
        lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
    } else { 
        onPointerDown(e);
    }
}

function onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length > 1) {
        const newDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        const scaleFactor = newDist / lastDist;
        const newScale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
        viewport.scale = newScale;
        lastDist = newDist;
    } else {
        onPointerMove(e);
    }
}

canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
canvas.addEventListener('touchend', onPointerUp);

canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
canvas.addEventListener('mouseup', onPointerUp);
canvas.addEventListener('mouseleave', () => isPanning = false);
canvas.addEventListener('dblclick', onDoubleClick);
canvas.addEventListener('contextmenu', onRightClick);

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    viewport.scale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
}, { passive: false });


// ---------- INITIALIZATION ---------- //
hostBtn.addEventListener('click', hostGame);
joinBtn.addEventListener('click', joinGame);
joinSpectatorBtn.addEventListener('click', joinAsSpectator);
startGameBtn.addEventListener('click', startGame);
//changeSymbolBtn.addEventListener('click', attemptSetSymbol);
window.addEventListener('resize', resizeCanvas);






customSymbolInput.addEventListener('input', attemptSetSymbol);

</script>
</body>
</html>