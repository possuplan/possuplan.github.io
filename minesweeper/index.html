<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Wi-Fi Minesweeper</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

<script src="riffwave.js"></script>
<script src="sfxr.js"></script>
<!--
todo: 
- lis√§√§ warning √§√§ni jos en√§√§ pari miinaa j√§ljell√§.
- lis√§√§ automaattinen miinojen m√§√§r√§n laskija: tee luvusta jaoton pelaajien m√§√§r√§n mukaan jolloin ei voi tulla tasapeli√§.

- tee sieniversio miss√§ v√§ltell√§√§n tappavan myrkyllisi√§ sieni√§. siin√§ voisi k√§vell√§ mets√§ss√§ ja kokeilla "kaivaa" jolloin se kertoo kuinka monta myrkkysient√§ on l√§hell√§. tai sit niin ett√§ etit√§√§n kaikkia sieni√§, mutta pit√§√§ osata v√§ltt√§√§ myrkkysieni√§, ja sit puuston ja maaston perusteella voi menn√§ l√∂yt√§m√§√§n tiettyj√§ sieni√§. ja sit pit√§√§ teh√§ ruokaa niist√§ ett√§ jaksaa etsi√§ lis√§√§ sieni√§.

-->
<style>
:root {
	--bg-color: #121212;
	--surface-color: #1e1e1e;
	--primary-text: #e0e0e0;
	--secondary-text: #a0a0a0;
	--border-color: #333;
	--accent-color: #03dac6;
	--grid-line-color: #444;
	--win-line-color: #ffeb3b;
}

* {
	box-sizing: border-box;
	-webkit-tap-highlight-color: transparent;
}

body {
	background-color: var(--bg-color);
	color: var(--primary-text);
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
	margin: 0;
	padding: 0;
	overflow: hidden;
	display: flex;
	justify-content: center;
	align-items: center;
	height: 100vh;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

.screen {
	display: none;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	width: 100%;
	max-width: 400px;
	padding: 20px;
	text-align: center;
}

.screen.active {
	display: flex;
}

h1, h2 {
	margin-top: 0;
	font-weight: 500;
}

.input-group {
	width: 100%;
	margin-bottom: 15px;
}

input[type="text"], input[type="number"], select {
	width: 100%;
	padding: 12px;
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: 8px;
	color: var(--primary-text);
	font-size: 16px;
}

input::placeholder {
	color: var(--secondary-text);
}

button {
	width: 100%;
	padding: 14px;
	border: none;
	border-radius: 8px;
	background-color: var(--accent-color);
	color: #000;
	font-size: 18px;
	font-weight: bold;
	cursor: pointer;
	transition: background-color 0.2s;
}

button:disabled {
	background-color: #555;
	color: #888;
	cursor: not-allowed;
}

button.secondary {
	background-color: var(--surface-color);
	color: var(--accent-color);
	border: 1px solid var(--accent-color);
}

.symbol-select-group {
	display: flex;
	align-items: center;
	gap: 10px;
	width: 100%;
}

#symbol-select {
	flex-grow: 1;
}

#custom-symbol-input {
	width: 80px;
	text-align: center;
	font-size: 20px;
}

#player-list {
	list-style: none;
	padding: 0;
	width: 100%;
	margin-top: 20px;
	max-height: 150px;
	overflow-y: auto;
}

#player-list li {
	background-color: var(--surface-color);
	padding: 10px;
	border-radius: 5px;
	margin-bottom: 5px;
	font-size: 18px;
}

#game-screen {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	display: none; /* Managed by JS */
	flex-direction: column;
}

#game-canvas {
	touch-action: none; /* Disables default browser gestures */
	background-color: #000;
	width: 100%;
	height: 100%;
}

#game-info {
	position: absolute;
	display:flex;
	align-items: center; 
	top: 0;
	left: 0;
	width: 100%;

	font-size: 1.2em;
	color: white;
	pointer-events: none; /* Clicks go through it */
	z-index: 10;
}

#infopadding {
	width:100px;
}

#game-status {
  flex: 1;               /* take all remaining horizontal space */
  text-align:right;
  padding-right:10px;
  
    height: 37px;
}

#bomb-button {
    width: 40px;
    height: 33px;
    padding: 0;
    margin: 0;
	background: green;
	border: none;
	cursor: pointer;
	display:none;
}

#bomb-button img {
    width: 25px;
}

#chat {
	position: absolute;
	top: 0;
	left: 0;             /* start from the left edge */
	right: 0;            /* stretch to the right edge */
	display: flex;
	/*gap: 5px;*/
	align-items: center;  /* vertically center children */

	box-sizing: border-box; /* include padding in width */
}

#chatMessages {
	flex: 1;               /* takes all remaining space */
	border: 1px solid #888;
	border-left:0;
	border-top:0;
	padding: 5px;
	overflow: hidden;
	/*white-space: nowrap;*/
		
	white-space: normal;     /* allow line breaks */
	word-break: break-word;  /* break long words if needed */
	overflow-wrap: anywhere; /* modern way to force wrapping */

	/*text-overflow: ellipsis;*/
	height:71px;
	padding-top:71px;
	background-color: rgba(0, 0, 0, 0.8);
	overflow-x: hidden;           /* prevent horizontal scroll */
	overflow-y: auto;         /* enable vertical scrolling */
	scrollbar-width: none;    /* hide scrollbar in Firefox */
	
	position: relative;   /* must be positioned for z-index to work */
	top:0;
	z-index: 1;           /* normal */
	outline: none;        /* remove blue focus outline if you don‚Äôt want it */
	font-size:11px;
}
#chatMessages:focus {
	z-index: 9999;        /* bring on top when focused */
	border-color:white;
}

#chatMessages::-webkit-scrollbar {
	display: none;            /* hide scrollbar in Chrome/Safari/Edge */
}



#game-state-list {
	width: 100px;
	border: 1px solid #888;
	border-left:0;
	border-top:0;
	padding-left: 5px;
	overflow: hidden;
	/*white-space: nowrap;*/
		
	white-space: normal;     /* allow line breaks */
	word-break: break-word;  /* break long words if needed */
	overflow-wrap: anywhere; /* modern way to force wrapping */

	/*text-overflow: ellipsis;*/
	height:76px;
	/*padding-top:71px;*/
	background-color: rgba(0, 0, 0, 0.8);
	overflow-x: hidden;           /* prevent horizontal scroll */
	overflow-y: auto;         /* enable vertical scrolling */
	scrollbar-width: none;    /* hide scrollbar in Firefox */
	
	position: relative;   /* must be positioned for z-index to work */
	top:0;
	z-index: 1;           /* normal */
	outline: none;        /* remove blue focus outline if you don‚Äôt want it */
	
	font-size:11px;
}
#game-state-list:focus {
	z-index: 9999;        /* bring on top when focused */
	border-color:white;
}

#game-state-list::-webkit-scrollbar {
	display: none;            /* hide scrollbar in Chrome/Safari/Edge */
}



#chatInput {
	width: 65px;           /* fixed sizes */
	position: relative;
	top: 18px;
	border-radius:0;
	height: 39px;
	padding-left: 3px;
	padding-right: 3px;
	font-size:11px;
}

#chatSend {
	width: 56px;           /* fixed width */
	position: relative;
	top: 18px;
	border-radius:0;
	height: 39px;
	padding:0;
}


.my-turn {
	background-color: rgba(0,0,255,0.3);
}
.opponent-turn {
	background-color: rgba(255,0,0,0.3);
}


/*howtoplay-btn*/
.infobutton {
    background-color: #468627;
    width: 150px;
    margin-top: 10px;
}



  
 /* Overlay background */
  .modal {
    display: none; /* hidden by default */
    position: fixed;
    z-index: 1000;
    left: 0; top: 0;
    width: 100%; height: 100%;
    background-color: rgba(0,0,0,0.8);
  }

  /* Centered box */
  .modal-content {
    background: #000;
    margin: 5% auto;
    padding: 20px;
    width: 100%;
    max-height: 100%;        /* limit height */
    border-radius: 20px;
	border:1px solid yellow;
    overflow-y: auto;       /* scrollbar if content is too tall */
  }

  .close {
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    position: relative;
    top: -13px;
  }

  .instructions {
    line-height: 1.5;
  }
  
  
</style>
	
	
	






<style>
/*
  body { 
    font-family: sans-serif; 
    margin: 20px; 
    background: #121212; 
    color: #eee;
  }
  select, input { 
    font-size: 16px; 
    padding: 5px; 
    background: #1e1e1e;
    color: #eee;
    border: 1px solid #555;
  }
  */
  
  #emojiView {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #1a1a1a;
    overflow-y: auto;
    display: none;
    padding: 5px;
    box-sizing: border-box;
    z-index: 1000;
    color: #eee;
    padding-top: 65px;
  }
#emojiGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, 50px);
  gap: 0;
}

.emojiSquare {
  width: 50px;
  height: 50px;
  outline: 1px solid #555; /* outline doesn‚Äôt double up */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;
  cursor: pointer;
  background: #222;
  color: #eee;
}
  .emojiSquare:hover {
	  background: #ff0000;
	  color: #fff;
  }
  #emojiControls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
  }
#closeBtn {
    position: fixed;
    top: 4px;
    right: 11px;
    cursor: pointer;
    font-weight: bold;
    font-size: 29px;
    padding: 5px 12px;
    background: #333;
    border: 3px solid #DDD;
    color: #eee;
    border-radius: 4px;
    box-shadow: 0 0 15px 10px rgba(0,0,0,0.75);
}

  #closeBtn:hover { background: #ff4d4d; color: #fff; }
  #searchOptions { display: flex; align-items: center; gap: 5px; }
  #searchOptions input, #searchOptions button {
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 5px 8px;
    border-radius: 4px;
  }
  #searchOptions button:hover { background: #ff4d4d; color: #fff; }
  
  
</style>


</head>
<body>


    <div id="home-screen" class="screen active">
        <h1>Wi-Fi Minesweeper</h1>
        <div class="input-group">
            <input type="text" id="game-name-input" value="DefaultGameName" placeholder="Enter Game Name">
        </div>
        <div class="input-group">
            <input type="text" id="player-name-input" placeholder="Enter Your Name">
        </div>
        <button id="host-btn">Host Game</button>
        <br>
        <button id="join-btn" class="secondary">Join Game</button>
        <p id="home-error" style="color: #FF00FF;"></p>
    </div>

    <div id="lobby-screen" class="screen">
        <h2 id="lobby-game-name"></h2>
		
        <div id="host-controls">
            <h3>Game Settings</h3>
            <div class="input-group" style="display: flex; gap: 10px; align-items: center;">
				<label for="grid-x-input">Width:</label>
                <input type="number" id="grid-x-input" value="16" min="3">
				<label for="grid-y-input">Height:</label>
                <input type="number" id="grid-y-input" value="16" min="3">
            </div>
            <div class="input-group">
             
				<label for="total-mines-input">Total mines:</label>
                <input type="number" id="total-mines-input" value="51" min="1">
				
				Bombs:
				<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
					<label for="total-bombs-input">Total:</label>
					<input type="number" id="total-bombs-input" value="1" min="0">
					
					<label for="bomb-radius-input">Radius:</label>
					<input type="number" id="bomb-radius-input" value="2" min="1">
				</div>
				
                <input type="number" id="win-condition-input" value="500" min="3" hidden>
            </div>
            <button id="start-game-btn">Start Game</button>
        </div>
		
		<button id="howtoplay-btn" class="infobutton">? How to play</button>
        
        <h3>Players in Lobby</h3>
        <ul id="player-list"></ul>
        
        <div class="input-group" style="display:none">
            <label>Your Symbol</label>
            <div class="symbol-select-group">
                <select id="symbol-select"></select>

					<label for="groupSelect">Group:</label>
					<select id="groupSelect">
					  <option value=""></option>
					  <option value="search">--Search--</option>
					</select>
					<!--<input type="text" id="selectedEmoji" placeholder="Selected Emoji">-->

					<div id="emojiView">
					  <div id="emojiControls">
						<div id="searchOptions" style="display:none;">
						  <input type="text" id="searchInput" placeholder="Search...">
						  <button id="matchModeBtn">Word</button>
						  <button id="searchBtn">Search</button>
						</div>
						<div id="closeBtn">‚úñ</div>
					  </div>
					  <div id="emojiGrid"></div>
					</div>



                <input type="text" id="custom-symbol-input" maxlength="16" placeholder="Unicode">
            </div>
        </div>
		

		<!-- Modal -->
		<div id="howtoplay-modal" class="modal">
		  <div class="modal-content">
			<span class="close">&times;</span>
			<h2>How to Play</h2>
			<div class="instructions">
			  <p>1. Find the mines by Double Left Click or a Single Tap! You get a new turn if you found a mine. Mines are flagged with flags after they are found.</p>
			  <p>2. The numbers tell how many mines are around that number: vertically, horizontally and diagonally (maximum of 8 possible mines around a number).</p>
			  <p>3. Right Click or Long Press activates the bomb, which creates 5x5 explosion by default (radius = 2).</p>
			  <p>4. Winner is the player who found most mines. A tie is also possible depending on settings.</p>
			  <p>5. The game also ends if the other players doesn't have a chance anymore to find more mines than the leading player. Leading player becomes the winner and the remaining mines are revealed.</p>
			  
			  
			</div>
		  </div>
		</div>


        <!--<button id="change-symbol-btn">Set Symbol</button>-->
        <p id="lobby-error" style="color: red;"></p>
    </div>

    <div id="game-screen">
		<div id="game-info">
			<span id="infopadding"></span>
		  <span id="game-status"></span>
		  <button id="bomb-button">
			<img src="images/bomb-big96.png" alt="bomb" width="90"/>
		  </button>
		</div>
        <canvas id="game-canvas"></canvas>
		

		 <!-- Chat box -->
		<div id="chat">
			<div id="game-state-list" tabindex="0"></div>
			<div id="chatMessages" tabindex="0"></div>
			<input id="chatInput" type="text" placeholder="Type message...">
			<button id="chatSend">Send</button>
		</div>
    </div>



<script>

var CACHED_SOUND_EFFECTS = {};


var SOUNDS = {
	//undo: [1,0,0,0.145,0,0.432,0.468603,0,-0.212,0,0,0,0,0,0.548476,0,0,0,0,0.756234,0,0,0,0,0.061],
	changestyle: [1,0,0,0.066307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.623612,0,0,1,0,0,0,0,0.11],
	showhide: [1,3,0.219375,0.070448,0.264728,0.246,0.940782,0,-0.359019,0,0.276075,0.558813,0,0,0,0,0,0,0,1,0,0,0.909348,0,0.252],
	complete: [1,0,0,0.414,0.092,0.851,0.269,0,0.391888,0,0,0.787,0.027,0.033,0.082,-0.489,0.463,0.002,0.001,1,0,0,0,0,0.13],
	explosion: [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	hint: [1,3,0.2034,0.519972,0.079301,0.420554,0.503805,0,0.019718,-0.113554,0.02742,-0.960806,0.437405,-0.928749,0.31182,0.242098,-0.059401,0.008261,-0.0102,0.205988,0.046432,0.574843,0.114387,0.001109,0.1068],
	already: [1,1,0,0.115,0.431,0.526,0.311,0,0,-0.266,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.184],
	tie: [1,0,0,0.66307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.423612,0,0,1,0,0,0,0,0.11],
	fail: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,-0.352,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	really: [1,0,0,0.382534,0,0.663,0.318,0,0.115469,-0.138,0,0,0,0,0.31911,0,0,0,0,0.642664,0,0,0,0,0.1068],
	kill: [1,0,0,0.089127,0,0.441,0.494,0,-0.333792,0,0,0,0,0,0.080034,0,0,0,0,1,0,0,0.013473,0,0.09],
	next: [1,0,0,0.362553,0,0.454,0.501627,0,0.205054,0,0,0,0,0,0.578561,0,0,0,0,0.902463,0,0,0.157574,0,0.1068],
	clear: [1,3,0,0.233,0.316,0.438,0.301,0,-0.294087,0,0,0,0.319083,0.897748,0,0,0.670729,0,0,1,0,0,0,0,0.1068],
	score: [1,0,0,0.353496,0,0.472,0.404228,0,0.391888,0,0,0,0,0,0.174445,0,0.527907,0,0,1,0,0,0,0,0.1068],
	click: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,0,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	shuffle: [1,1,0,0.19396,0,0.463777,0.225533,0,0.307713,0,0,0,0,0,1,0,0.578735,0,0,1,0,0,0,0,0.134],
}




/////////////////////////////////
// JSFXR

var SOUNDS_ENABLED = true;
var PARAMS;
if(typeof Params !== "undefined"){
	PARAMS = new Params();
}else{
	SOUNDS_ENABLED = false;
}
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;

// JSFXR
/////////////////////////////////




function generate_sounds(){
	if(SOUNDS_ENABLED){
		for(var soundName in SOUNDS) {
			if(SOUNDS.hasOwnProperty(soundName)){
				console.log("Generating sound "+soundName);
				generate_sound_caches(soundName);
			}
		}
	}
}


function generate_sound_caches(soundName){
	if(SOUNDS_ENABLED){
		let newPARAMS = SOUNDS[soundName];
		
		if(newPARAMS[0] != 1){
			console.log("unknown sound version '"+newPARAMS[0]+"'");
			console.log(newPARAMS);
			return;
		}
		
		let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
		
		let output = {};
		output['oldParams'] = true;
		output['sample_rate'] = 44100;
		output['sample_size'] = 8;

		for(let i = 1; i < order.length; i++){
			output[order[i]] = newPARAMS[i];
		}

		PARAMS.fromJSON(output);
		
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName] = {};
		}
		
		SOUND = new SoundEffect(PARAMS).generate();
		CACHED_SOUND_EFFECTS[soundName]['sound'] = SOUND;
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	}
}


function play_sound(soundName){
	if(SOUNDS_ENABLED){
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			return;
		}
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'];
		SOUND.getAudio().play();
		console.log("play_sound: "+soundName);
		
		//console.log("CACHED_SOUND_EFFECTS:");
		//console.log(CACHED_SOUND_EFFECTS);
	}
}

generate_sounds();




// Draw a 2px-thick circle in the center; the canvas background remains transparent
function drawCircle(ctx, offsetX, offsetY, cx, cy, radius, lineWidth = 10, strokeStyle = '#ff0000') {
	ctx.beginPath();
	
	ctx.arc(offsetX+cx, offsetY+cy, radius, 0, Math.PI * 2);
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = strokeStyle;
	
	ctx.stroke();
}




const playerColors = [
	"#e6194B", // red
	"#4363d8", // blue
	"#ffe119", // yellow
	"#3cb44b", // dark green
	"#f58231", // orange
	"#911eb4", // purple
	"#42d4f4", // cyan
	"#f032e6", // magenta
	"#bfef45", // lime
	"#469990", // teal
	"#9A6324", // brown
	"#808000", // olive
	"#000075", // navy
	"#a9a9a9", // gray
	"#000000"  // black
];

let typeToValue = {
	"-1": "", // üö©
};

let TYPE_MINE = -1;
let TYPE_EMPTY = 0;

function set_mine(data, x, y, type){
	data.map[y][x].type = type;
	data.map[y][x].value = typeToValue[data.map[y][x].type] ?? "X";
}


function generate_map(width, height, total_mines){
	let data = {
		width: width,
		height: height,
		map: Array.from({length: height}, () => Array.from({length: width}, () => ({
			type: TYPE_EMPTY,
			value: "", 
			visible: 0, 
			frame: 0,
			owner: -1,
			numbersAround: 0,
			waternum: random(0,2)
		}))),
	};
	
	/*
	states:
	-3 ...
	-2 other item (for later use)
	-1 mine
	0 empty
	1 (number of mines around)
	2 (number of mines around)
	3...
	*/
	
	// add mines:
	let placed = 0;
	while (placed < total_mines) {
		let x = Math.floor(Math.random() * width);
		let y = Math.floor(Math.random() * height);

		if (data.map[y][x].type === TYPE_EMPTY) {
			set_mine(data, x, y, TYPE_MINE);
			placed++;
		}
	}
	
	// count mines around each spot:
	for(let y = 0; y < height; y++){
		for(let x = 0; x < width; x++){
			if(data.map[y][x].type === TYPE_EMPTY){
				data.map[y][x].type = count_mines_around(data, x, y);
			}
		}	
	}
	



	return data;
}


function count_map_numbers_around(data){
	// check if this should be rendered as dark water (no visible numbers around it)
	for(let y = 0; y < data.height; y++){
		for(let x = 0; x < data.width; x++){
			data.map[y][x].numbersAround = count_numbers_around(data, x, y);
		}	
	}
}


function count_mines_around(data, xp, yp){
	let count = 0;
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(data.map[yy][xx].type < TYPE_EMPTY){
						count++;
					}
				}
			}
		}
	}
	return count;
}

function count_numbers_around(data, xp, yp){
	let count = 0;
	for(let y = -1; y <= 1; y++){
		for(let x = -1; x <= 1; x++){
			let xx = xp+x;
			let yy = yp+y;
			if(x == 0 && y == 0){
				continue; // skip middle square.
			}
			if(xx >= 0 && xx < data.width){
				if(yy >= 0 && yy < data.height){
					if(data.map[yy][xx].type > TYPE_EMPTY && data.map[yy][xx].visible){
						count++;
					}
				}
			}
		}
	}
	return count;
}


function revealZeros(data, startX, startY, grid) {
  let queue = [[startY, startX]];

  while (queue.length > 0) {
    let [y, x] = queue.shift();

    // Bounds check
    if (y < 0 || y >= data.height || x < 0 || x >= data.width) continue;

    let cell = data.map[y][x];
	
    // Already visible? skip
    if (cell.visible) continue;

    // Reveal this cell
    cell.visible = 1;
	if(cell.type < TYPE_EMPTY){
		grid[y][x] = cell.value;
	}else{
		if(cell.type === TYPE_EMPTY){
			grid[y][x] = "";
			
		}else{
			grid[y][x] = cell.type;
		}
	}

    // If it's not a zero, stop spreading from here
    if (cell.type !== TYPE_EMPTY) continue;

    // Spread to all 8 neighbors
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue; // skip self
        queue.push([y + dy, x + dx]);
      }
    }
  }
}


function revealBombZeros(data, startX, startY, grid) {
    let queue = [];
	let radius = gameState.bombRadius;

    // First, reveal 5x5 area around startX, startY
    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const y = startY + dy;
            const x = startX + dx;

            if (y < 0 || y >= data.height || x < 0 || x >= data.width) continue;

            let cell = data.map[y][x];
            if (cell.visible) continue;

            cell.visible = 1;
            if (cell.type < TYPE_EMPTY) {
                grid[y][x] = cell.value;
            } else {
                grid[y][x] = cell.type === TYPE_EMPTY ? "" : cell.type;
            }

            // If the cell is a zero, add it to the BFS queue
            if (cell.type === TYPE_EMPTY) {
                queue.push([y, x]);
            }
        }
    }

    // BFS for spreading zeros
    while (queue.length > 0) {
        let [y, x] = queue.shift();

        // Spread to all 8 neighbors
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const ny = y + dy;
                const nx = x + dx;

                if (ny < 0 || ny >= data.height || nx < 0 || nx >= data.width) continue;
                if (dx === 0 && dy === 0) continue;

                let neighbor = data.map[ny][nx];
                if (neighbor.visible) continue;

                neighbor.visible = 1;
                if (neighbor.type < TYPE_EMPTY) {
                    grid[ny][nx] = neighbor.value;
                } else {
                    grid[ny][nx] = neighbor.type === TYPE_EMPTY ? "" : neighbor.type;
                }

                // If neighbor is zero, add to queue
                if (neighbor.type === TYPE_EMPTY) {
                    queue.push([ny, nx]);
                }
            }
        }
    }
}





let emojiData = [];
let matchMode = 'word'; // or 'any'

async function loadEmojis() {
  const res = await fetch('emojis-all.json');
  emojiData = await res.json();

  const select = document.getElementById('groupSelect');
  emojiData.forEach(group => {
    const opt = document.createElement('option');
    opt.value = group.group;
    opt.textContent = group.group;
    select.appendChild(opt);
  });
}

function showEmojiView(items) {
  const grid = document.getElementById('emojiGrid');
  grid.innerHTML = '';
  items.forEach(([symbol, name]) => {
    const div = document.createElement('div');
    div.className = 'emojiSquare';
    div.textContent = symbol;
    div.title = name;
    div.addEventListener('click', () => {
      document.getElementById('custom-symbol-input').value = symbol;
      document.getElementById('emojiView').style.display = 'none';
	  attemptSetSymbol();
    });
    grid.appendChild(div);
  });
  document.getElementById('emojiView').style.display = 'block';
}

document.getElementById('groupSelect').addEventListener('change', (e) => {
  const val = e.target.value;
  const searchOptions = document.getElementById('searchOptions');
  if(val === 'search') {
    searchOptions.style.display = 'flex';
    document.getElementById('emojiGrid').innerHTML = '';
    document.getElementById('emojiView').style.display = 'block';
  } else {
    searchOptions.style.display = 'none';
    const group = emojiData.find(g => g.group === val);
    if(group) showEmojiView(group.list);
  }
});

document.getElementById('closeBtn').addEventListener('click', () => {
  document.getElementById('emojiView').style.display = 'none';
});

document.getElementById('matchModeBtn').addEventListener('click', () => {
  matchMode = matchMode === 'word' ? 'any' : 'word';
  document.getElementById('matchModeBtn').textContent = matchMode.charAt(0).toUpperCase() + matchMode.slice(1);
});

document.getElementById('searchBtn').addEventListener('click', () => {
  const query = document.getElementById('searchInput').value.toLowerCase();
  if(!query) return;
  let results = [];
  emojiData.forEach(group => {
    group.list.forEach(([symbol,name]) => {
      const lname = name.toLowerCase();
      if((matchMode==='word' && lname.split(' ').includes(query)) ||
         (matchMode==='any' && lname.includes(query))) {
        results.push([symbol,name]);
      }
    });
  });
  showEmojiView(results);
});

loadEmojis();
</script>


<script>
// ---------- CONFIG & STATE ---------- //
const PREDEFINED_SYMBOLS = ['X', 'O', '#', '%'];

let peer;
let myPeerId;
let hostId;
let connections = {}; // key: peerId, value: connection object
let isHost = false;

let lastMoves = {};

let localPlayer = {
    id: null,
    name: "Player",
    symbol: '',
    isReady: false,
};

let gameState = {
    players: [],
    grid: [],
    gridSize: { x: 10, y: 10 },
    winCondition: 4,
	totalMines: 30,
	totalBombs: 1,
	bombRadius: 2,
    currentPlayerIndex: 0,
    gameStarted: false,
    gameOver: false,
    winner: null,
	ties: null,
	lastMoveFailed: false,
	minemap: [],
	minesRemaining: 0,
};

// ---------- UI ELEMENT REFERENCES ---------- //
const screens = {
    home: document.getElementById('home-screen'),
    lobby: document.getElementById('lobby-screen'),
    game: document.getElementById('game-screen'),
};
const gameNameInput = document.getElementById('game-name-input');
const playerNameInput = document.getElementById('player-name-input');
playerNameInput.value = randomPlayerName();

const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const homeError = document.getElementById('home-error');

const lobbyGameName = document.getElementById('lobby-game-name');
const hostControls = document.getElementById('host-controls');
const startGameBtn = document.getElementById('start-game-btn');
const playerList = document.getElementById('player-list');
const symbolSelect = document.getElementById('symbol-select');
const customSymbolInput = document.getElementById('custom-symbol-input');
//const changeSymbolBtn = document.getElementById('change-symbol-btn');
const lobbyError = document.getElementById('lobby-error');
const gridXInput = document.getElementById('grid-x-input');
const gridYInput = document.getElementById('grid-y-input');
const winConditionInput = document.getElementById('win-condition-input');
const totalMinesInput = document.getElementById('total-mines-input');
const totalBombsInput = document.getElementById('total-bombs-input');
const bombRadiusInput = document.getElementById('bomb-radius-input');


const gameInfo = document.getElementById('game-status');
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const chatMessages = document.getElementById("chatMessages");
const gameStateList = document.getElementById("game-state-list");
const chatInput = document.getElementById("chatInput");
const chatSend = document.getElementById("chatSend");



const howToPlayBtn = document.getElementById('howtoplay-btn');
const modal = document.getElementById('howtoplay-modal');
const closeBtn = modal.querySelector('.close');

howToPlayBtn.addEventListener('click', () => {
	modal.style.display = 'block';
});

closeBtn.addEventListener('click', () => {
	modal.style.display = 'none';
});

window.addEventListener('click', (e) => {
	if (e.target === modal) {
		modal.style.display = 'none';
	}
});

// Close modal by pressing Escape
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && modal.style.display === 'block') {
    modal.style.display = 'none';
  }
});



function setTotalMines() {
	let width = parseInt(gridXInput.value);
	let height = parseInt(gridYInput.value);
	let ratio = 51/256;
	let val = Math.round(width*height*ratio);
	if(val < 0) val = 1;
	totalMinesInput.value = val;
}

gridXInput.addEventListener("input", setTotalMines);
gridYInput.addEventListener("input", setTotalMines);



// ---------- UI MANAGEMENT ---------- //
function showScreen(screenName) {
    Object.values(screens).forEach(screen => screen.classList.remove('active'));
    if(screenName === 'game') {
        screens.game.style.display = 'flex';
        screens.home.style.display = 'none';
        screens.lobby.style.display = 'none';
    } else {
        screens.game.style.display = 'none';
        screens[screenName].classList.add('active');
    }
}

function updateLobbyUI() {
    lobbyGameName.textContent = `Game: ${gameNameInput.value}`;
    hostControls.style.display = isHost ? 'block' : 'none';
    
    const me = gameState.players.find(p => p.id === localPlayer.id);
    if (me) {
        localPlayer = { ...localPlayer, ...me };
    }

    playerList.innerHTML = '';
    gameState.players.forEach(p => {
        const li = document.createElement('li');
		const safeName = document.createTextNode(p.name);
		li.innerHTML = `<span style="color:${p.color}"></span>`;
		li.querySelector("span").appendChild(safeName);
        playerList.appendChild(li);
    });

    const usedSymbols = gameState.players.map(p => p.symbol);
    const availableSymbols = PREDEFINED_SYMBOLS.filter(s => !usedSymbols.includes(s) || s === localPlayer.symbol);

    symbolSelect.innerHTML = availableSymbols.map(s => `<option value="${s}" ${s === localPlayer.symbol ? 'selected' : ''}>${s}</option>`).join('');

}

function updateGameUI() {
    if (gameState.gameStarted) {
        updateGameInfo();
        draw();
		console.log("updateGameUI draw()");
    }
}

// ---------- NETWORKING (PeerJS) ---------- //
function initializePeer(peerId) {
    myPeerId = peerId || 'tictactoe-' + Math.random().toString(36).substr(2, 9);
    localPlayer.id = myPeerId;
    peer = new Peer(myPeerId, { debug: 2 });

    peer.on('open', id => {
        console.log('My peer ID is: ' + id);
    });

    peer.on('connection', conn => {
        setupConnection(conn);
    });

    peer.on('error', err => {
        console.error("PeerJS Error:", err);
        homeError.textContent = `Error: ${err.message}. Try a different Game Name.`;
        joinBtn.disabled = false;
        hostBtn.disabled = false;
    });
}

function setupConnection(conn) {
    conn.on('open', () => {
        console.log(`Connected to ${conn.peer}`);
        connections[conn.peer] = conn;

        if (isHost) {
            conn.send({ type: 'game_state', state: gameState });
        }
    });

    conn.on('data', data => handleMessage(data, conn.peer));
    conn.on('close', () => {
        console.log(`Connection closed with ${conn.peer}`);
        delete connections[conn.peer];
        if (isHost) {
            gameState.players = gameState.players.filter(p => p.id !== conn.peer);
            broadcast({ type: 'game_state', state: gameState });
            updateLobbyUI(); // Host updates its own view
        }
    });
}



function newPlayerColor(){
	let colorIndex = gameState.players.length % playerColors.length;
	return playerColors[colorIndex];
}



function hostGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
    localPlayer.name = playerName;
    isHost = true;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
    initializePeer(gameName); 
    
    localPlayer.symbol = PREDEFINED_SYMBOLS[0];
    localPlayer.isReady = true;
	localPlayer.color = newPlayerColor();
	localPlayer.minesFound = 0;
	localPlayer.bombsUsed = 0;
	localPlayer.lastMoveFailed = false;
    gameState.players.push(localPlayer); 
    
    showScreen('lobby');
    updateLobbyUI();
}



function joinGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
    localPlayer.name = playerName;
    isHost = false;
    hostId = gameName;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
    initializePeer();

    setTimeout(() => { 
        if (!peer || !peer.id) return;
        const conn = peer.connect(hostId, { reliable: true });
        if(conn) {
            setupConnection(conn);
        } else {
            homeError.textContent = "Could not connect to host. Check Game Name.";
            hostBtn.disabled = false;
            joinBtn.disabled = false;
        }
    }, 1000);
}

function broadcast(data) {
    if (!isHost) return;
    Object.values(connections).forEach(conn => {
        conn.send(data);
    });
}

function sendToHost(data) {
    if (isHost) return;
    const conn = connections[hostId];
    if (conn) {
        conn.send(data);
    }
}

/*
changestyle
showhide hyv√§
already ok
fail ok 
already lol
kill hyv√§
next hassu
clear hyv√§
score ok
click ok
shuffle ok

complete : voitit pelin
explosion : h√§visit
*/

function getMoveType(x, y){
	return gameState.minemap.map[y][x].type;
}



function handleMessage(data, peerId) {
    //console.log('Received:', data.type);
	
	console.log(data.type);
	
    switch (data.type) {
        case 'game_state':
            gameState = data.state;
			console.log("gameState:");
			console.log(gameState);
			
			if (gameState.gameOver) {
				if (gameState.winner) {
					if(gameState.winner.id === localPlayer.id){
						playSound("victory");
					}else{
						playSound("bigsplash");
					}
				} else {
					play_sound("tie");
				}
			}
			
			

			if (gameState.lastMove) {
				
				
				if(!gameState.lastMoveFailed){
					
					console.log("!gameState.lastMoveFailed");
				
					//console.log("gameState.lastMove");
					//console.log(gameState.lastMove);
					const lastmove = gameState.lastMove;
					
					if(lastmove.weapon == MOVE_TYPE_BOMB){
						if (lastmove.playerId === localPlayer.id) {
							playSound("bigsplash"); // you made the move
						} else {
							playSound("bigsplash"); // opponent move
						}
					}else{
					
						let type = getMoveType(gameState.lastMove.x, gameState.lastMove.y);
						let moveSound = "miss";
						if(type < 0){
							moveSound = "hit";
						}else if(type == 0){
							moveSound = "miss_long";
						}
						
						if (lastmove.playerId === localPlayer.id) {
							playSound(moveSound); // you made the move
						} else {
							playSound(moveSound); // opponent move
						}
					}
				}
			}

			
            if (!isHost && !localPlayer.isReady) {
                showScreen('lobby');
                sendToHost({ type: 'player_join', player: localPlayer });
                localPlayer.isReady = true; 
            }
            if (gameState.gameStarted) {
                showScreen('game');
                resizeCanvas();
                updateGameUI();
            } else {
                updateLobbyUI();
            }
			
            break;
        case 'player_join':
            if (isHost) {
                // ** THE BUG FIX IS HERE **
                // Check if player already exists before adding
                if (gameState.players.some(p => p.id === data.player.id)) {
                    //console.warn(`Player ${data.player.id} tried to join again. Ignoring.`);
                    // Resend state just in case they missed it
                    connections[data.player.id]?.send({ type: 'game_state', state: gameState });
                    return; 
                }

                let newPlayer = data.player;
                const usedSymbols = gameState.players.map(p => p.symbol);
                const nextSymbol = PREDEFINED_SYMBOLS.find(s => !usedSymbols.includes(s));
                newPlayer.symbol = nextSymbol || '';
				newPlayer.color = newPlayerColor();
				newPlayer.minesFound = 0;
				newPlayer.bombsUsed = 0;
				newPlayer.lastMoveFailed = false;
                
                gameState.players.push(newPlayer);
                broadcast({ type: 'game_state', state: gameState });
                updateLobbyUI();
            }
            break;
        case 'player_update':
             if (isHost) {
                const playerIndex = gameState.players.findIndex(p => p.id === peerId);
                if (playerIndex > -1) {
                    const requestedSymbol = data.player.symbol;
                    if (gameState.players.some((p, i) => p.symbol === requestedSymbol && i !== playerIndex)) {
                        connections[peerId].send({type: 'symbol_taken'});
                    } else {
                        gameState.players[playerIndex].symbol = data.player.symbol;
                        broadcast({ type: 'game_state', state: gameState });
                        updateLobbyUI();
                    }
                }
            }
            break;
        case 'symbol_taken':
            lobbyError.textContent = "Symbol is already taken!";
            setTimeout(() => lobbyError.textContent = "", 2000);
            break;
        case 'player_move':
            if (isHost) {
                handlePlayerMove(data.move);
            }
            break;
		case "player_message":
		  if (isHost) {
			// Rebroadcast to everyone else, but NOT back to the original sender
			broadcast(data, peerId); // assuming your broadcast supports excluding peerId
		  }

		  // Show the message (all peers including host)
		  addChatMessage(data.playerId, data.text);
		  break;
    }
}


// Send message when clicking the button
chatSend.addEventListener("click", sendChatMessage);

// Or when pressing Enter
chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter") sendChatMessage();
});

function sendChatMessage() {
  const text = chatInput.value.trim();
  if (!text) return;

  const msg = {
    type: "player_message",
    playerId: localPlayer.id,
    text
  };

  if (isHost) {
    // Host only needs to broadcast, not handleMessage directly
    broadcast(msg);
    addChatMessage(msg.playerId, msg.text); // add to host UI only
  } else {
    sendToHost(msg);
    //addChatMessage(msg.playerId, msg.text); // add immediately for sender
  }

  chatInput.value = "";
}

function getPlayerById(id, myArray = null) {
	if(myArray){
		return myArray.find(p => p.id === id) || null;
	}else{
		return gameState.players.find(p => p.id === id) || null;
	}
}


function addChatMessage(playerId, text) {

	let player = getPlayerById(playerId);

	const div = document.createElement("div");

	// Player name in color
	const nameSpan = document.createElement("span");
	nameSpan.style.color = player.color;
	nameSpan.textContent = player.name; // safe

	div.appendChild(nameSpan);

	// Colon + message
	div.appendChild(document.createTextNode(": " + text));

	chatMessages.appendChild(div);


	// scroll to bottom
	chatMessages.scrollTop = chatMessages.scrollHeight;
}






// ---------- GAME LOGIC ---------- //
function attemptSetSymbol() {
    const selectedSymbol = String(symbolSelect.value);
    const customSymbol = String(customSymbolInput.value);
	
	console.log("attemptSetSymbol selectedSymbol:'"+selectedSymbol+"', customSymbol:'"+customSymbol+"'");
    
    let symbolToSet = customSymbol || selectedSymbol;
    if (!symbolToSet || localPlayer.symbol === symbolToSet) return;
	
	console.log("attemptSetSymbol 2");

    let updatedPlayer = { ...localPlayer, symbol: symbolToSet };
    
    const payload = { type: 'player_update', player: updatedPlayer };

    if (isHost) {
		console.log("attemptSetSymbol 3");
        const playerIndex = gameState.players.findIndex(p => p.id === localPlayer.id);
        if (playerIndex > -1) {
            if (gameState.players.some((p, i) => p.symbol === symbolToSet && i !== playerIndex)) {
                lobbyError.textContent = "Symbol is already taken!";
				console.log(lobbyError.textContent);
                setTimeout(() => lobbyError.textContent = "", 2000);
            } else {
                gameState.players[playerIndex].symbol = symbolToSet;
                broadcast({ type: 'game_state', state: gameState });
				console.log("set symbol: "+symbolToSet);
                updateLobbyUI();
            }
        }
    } else {
		console.log("attemptSetSymbol 4");
        sendToHost(payload);
    }
}



function addGameStateElement(playerId, playerColor, playerName, text) {
	const div = document.createElement("div");
	div.id = `gameState-${playerId}`;

	// Player name in color
	const nameSpan = document.createElement("span");
	nameSpan.style.color = playerColor;
	nameSpan.textContent = playerName;

	// Colon + message in white
	const textSpan = document.createElement("span");
	textSpan.style.color = "white";
	textSpan.textContent = text;
	textSpan.id = `gameStateValue-${playerId}`;

	// Add both spans into the div
	div.appendChild(nameSpan);
	div.appendChild(textSpan);

	// Add div to the list
	gameStateList.appendChild(div);

	// Scroll to bottom
	gameStateList.scrollTop = gameStateList.scrollHeight;
}

function createGameStateElements(){
	if(!document.getElementById(`gameStateValue-mines`)){
		addGameStateElement("mines", "white", "Remaining", `: ${gameState.totalMines}`);
		for(let i = 0; i < gameState.players.length; i++){
			addGameStateElement(gameState.players[i].id, gameState.players[i].color, gameState.players[i].name, ": 0");
		}
		gameStateList.scrollTop = gameStateList.scrollHeight;
	}
}
	

function startGame() {
    if (!isHost) return;

    gameState.gridSize = { x: parseInt(gridXInput.value), y: parseInt(gridYInput.value) };
    gameState.winCondition = parseInt(winConditionInput.value);
	gameState.totalMines = Math.max(1, Math.min(parseInt(totalMinesInput.value), gameState.gridSize.x*gameState.gridSize.y)); // minimum = 1, max = w*h
	gameState.totalBombs = Math.max(0, parseInt(totalBombsInput.value)); // minimum = 0
	gameState.bombRadius = Math.max(1, parseInt(bombRadiusInput.value)); // minimum = 1
    gameState.grid = Array(gameState.gridSize.y).fill(null).map(() => Array(gameState.gridSize.x).fill(null));
    gameState.currentPlayerIndex = Math.floor(Math.random() * gameState.players.length);
    gameState.gameStarted = true;
    gameState.gameOver = false;
    gameState.winner = null;
	gameState.ties = null;
	gameState.lastMoveFailed = false;
	gameState.minemap = generate_map(gameState.gridSize.x, gameState.gridSize.y, gameState.totalMines);
	gameState.minesRemaining = get_remaining_mines();


    broadcast({ type: 'game_state', state: gameState });
    handleMessage({ type: 'game_state', state: gameState }); // Update host locally
}



function setLastMoveByPlayer(x, y, playerId, weapon) {
    gameState.lastMoves = gameState.lastMoves || {};
    gameState.lastMoves[playerId] = { x, y, weapon};
	gameState.lastMove = { x, y, playerId, weapon};
}


function get_remaining_mines(){
	let mines = 0;
	for(let y = 0; y < gameState.minemap.height; y++){
		for(let x = 0; x < gameState.minemap.width; x++){
			if(gameState.minemap.map[y][x].type < TYPE_EMPTY && gameState.minemap.map[y][x].owner == -1){
				mines++;
			}
		}
	}
	return mines;
}


function get_mines_by_player_index(player_index){
	let mines = 0;
	for(let y = 0; y < gameState.minemap.height; y++){
		for(let x = 0; x < gameState.minemap.width; x++){
			if(gameState.minemap.map[y][x].owner == player_index){
				mines++;
			}
		}
	}
	return mines;
}


function handlePlayerMove({x, y, playerId, weapon}) {
	
    if (gameState.gameOver){
		//console.log("cant move, game ended, winner:");
		//console.log(gameState.winner);
		
		return;
	}
    
    const player = gameState.players[gameState.currentPlayerIndex];
    if (player.id !== playerId) return;

    //gameState.grid[y][x] = player.symbol;

	
	gameState.lastMoveFailed = false;
	
	
    //if (checkWin(x, y) !== null) {
	//	console.log("game has ended alredy");
    //} else {
		
	if(weapon == MOVE_TYPE_NORMAL){
		
		if(!gameState.minemap.map[y][x].visible){
			revealZeros(gameState.minemap, x, y, gameState.grid);
			
			// if missed, go to next player turn:
			if(gameState.minemap.map[y][x].type >= TYPE_EMPTY){
				gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
			}else{
				// mark this mine found by current player:
				//if(gameState.minemap.map[y][x].type == TYPE_MINE){
				gameState.minemap.map[y][x].owner = gameState.currentPlayerIndex;
				gameState.minesRemaining = get_remaining_mines();
				let currentPlayerMinesFound = get_mines_by_player_index(gameState.currentPlayerIndex);
				gameState.players[gameState.currentPlayerIndex].minesFound = currentPlayerMinesFound;


				//}
				// keep player turn if hit a mine or empty spot
			}
			
			setLastMoveByPlayer(x, y, player.id, weapon);

			gameState.lastMoveFailed = false;
		}else{
			
			gameState.lastMoveFailed = true;
		}

		

	}else if(weapon == MOVE_TYPE_BOMB){
		
		if(gameState.players[gameState.currentPlayerIndex].bombsUsed < gameState.totalBombs){
			revealBombZeros(gameState.minemap, x, y, gameState.grid);
			
			// set owner for found mines:
			let radius = gameState.bombRadius;
			for(let yy = -radius; yy <= radius; yy++){
				for(let xx = -radius; xx <= radius; xx++){
					let xp = xx+x;
					let yp = yy+y;
					if(xp >= 0 && xp < gameState.minemap.width){
						if(yp >= 0 && yp < gameState.minemap.height){
							if(gameState.minemap.map[yp][xp].type < TYPE_EMPTY){
								gameState.minemap.map[yp][xp].owner = gameState.currentPlayerIndex;
							}
						}
					}
				}
			}
			
			gameState.minesRemaining = get_remaining_mines();
			let currentPlayerMinesFound = get_mines_by_player_index(gameState.currentPlayerIndex);
			gameState.players[gameState.currentPlayerIndex].minesFound = currentPlayerMinesFound;

			gameState.players[gameState.currentPlayerIndex].bombsUsed++;

			// next player turn:
			gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
			

			
			setLastMoveByPlayer(x, y, player.id, weapon);
			
			gameState.lastMoveFailed = false;
		}else{
			
			gameState.lastMoveFailed = true;
		}
	}
	
	// check winner:
	
	//return {isTie: isTie, topPlayer: topPlayer};
	
	let endState = checkEndState();
	console.log("endState:");
	console.log(endState);

	
	if(endState.winner){
		gameState.gameOver = true;
		gameState.winner = endState.winner;
	}else if(endState.ties.length > 1){
		gameState.gameOver = true;
		gameState.winner = null;
		gameState.ties = endState.ties;
	}
	
    //}
	
	// update darker water map:
	count_map_numbers_around(gameState.minemap);
    
    broadcast({ type: 'game_state', state: gameState });
    handleMessage({ type: 'game_state', state: gameState });
}



let PLAYER_CHANCE_NONE = 0;
let PLAYER_CHANCE_TIE = 1;
let PLAYER_CHANCE_WIN = 2;


let PLAYER_STATUS_NONE = 0;
let PLAYER_STATUS_TIE = 1;
let PLAYER_STATUS_WIN = 2;


function countChances(playerStatuses){
	let winnerList = [];
	let tieList = [];
	let noneList = [];
	for(const playerId in playerStatuses){
		let playerStatus = playerStatuses[playerId];
		
		// check how many win statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_WIN){
			winnerList.push(playerId);
		}
		// check how many tie statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_TIE){
			tieList.push(playerId);
		}
		// check how many none statuses are:
		if(playerStatus.chance == PLAYER_CHANCE_NONE){
			noneList.push(playerId);
		}
	}
	return {none: noneList, tie: tieList, win: winnerList};
}


function createPlayersState(minesRemaining, playersMinesFound){
	let testData = {
		minesRemaining: minesRemaining, 
		players: [],
	};
	for(let i = 0; i < playersMinesFound.length; i++){
		let player = {
			id: "p"+(i+1),
			minesFound: playersMinesFound[i],
		};
		testData.players.push(player);
	}
	return testData;
}

function testWin(minesRemaining, playersMinesFound){
	let testData = createPlayersState(minesRemaining, playersMinesFound);
	//console.log("testData:");
	//console.log(testData);

	let endstate = checkEndState(testData);
	//console.log("endstate:");
	//console.log(endstate);
		
	let resultList = {};
	// initialize:
	for(let i = 0; i < playersMinesFound.length; i++){
		let player = testData.players[i];
		resultList[player.id] = `${player.id}: ${player.minesFound} (NO)`;
	}
	// add ties:
	if(endstate.ties.length > 0){

		for(let i = 0; i < endstate.ties.length; i++){
			let player = endstate.ties[i];
			
			resultList[player.id] = `${player.id}: ${player.minesFound} (TIE)`;
		}
	}
	// add winner:
	if(endstate.winner){
		let player = endstate.winner;
		resultList[player.id] = `${player.id}: ${player.minesFound} (WIN)`;
	}
	
	//console.log("resultList");
	//console.log(structuredClone(resultList));
	
	let resultsArr = [];
	for (const value of Object.values(resultList)) {
	  resultsArr.push(value);
	}
	
	let resjoin = resultsArr.join(",  ");
	
	console.log(resjoin);
	
	return resjoin;
}





function checkEndState(testData = null){
	let minesRemaining = 0;
	let playersList = {};
	
	if(testData){
		minesRemaining = testData.minesRemaining;
		playersList = testData.players;
	}else{
		minesRemaining = gameState.minesRemaining;
		playersList = gameState.players;
	}
	
	let playerStatuses = {};
	for (const player of playersList) {
		playerStatuses[player.id] = {chance: PLAYER_CHANCE_NONE, status: PLAYER_STATUS_NONE};
	}

	//console.log("playerStatuses1:");
	//console.log(structuredClone(playerStatuses));
	
	// find max mines of any player:
	let maxPlayerMines = -1;
	for (const player of playersList) {
		if(player.minesFound > maxPlayerMines){
			maxPlayerMines = player.minesFound;
		}
	}
	//console.log("maxPlayerMines = "+maxPlayerMines);
	
	let tieList = [];
	let winnerPlayer = null;
	
	if(playersList.length == 1){
		//console.log("playersList.length == 1");
		// allow playing alone until all mines found:
		if(minesRemaining == 0){
			winnerPlayer = playersList[0];
		}
	}else{
		
		if(minesRemaining == 0){
			
			//console.log("minesRemaining == 0");
			
			// check end state when no mines are remaining:
			for (const player of playersList) {
				let playerStatus = playerStatuses[player.id];

				// 2=none, 2=none, 4=tie, 4=tie

				if(player.minesFound < maxPlayerMines){
					playerStatus.chance = PLAYER_CHANCE_NONE;
				}else if(player.minesFound == maxPlayerMines){
					playerStatus.chance = PLAYER_CHANCE_WIN;
				}
			}
			
			//console.log("playerStatuses2a:");
			//console.log(structuredClone(playerStatuses));
			
			let chances = countChances(playerStatuses);
			
			//console.log("chances2a:");
			//console.log(structuredClone(chances));
			
			// clear winner if only one "win" found:
			// 2=none, 2=none, 4=tie
			if(chances.win.length == 1){
				//console.log("chances.win.length == 1");
				//playerStatuses[chances.win[0]].status = PLAYER_STATUS_WIN;
				winnerPlayer = getPlayerById(chances.win[0], playersList);
			}else{
				//console.log("chances.win.length > 1");
				
				// no winner, multiple winners found:
				// 2=none, 2=none, 4=tie, 4=tie
				for(let i = 0; i < chances.win.length; i++){
					//playerStatuses[chances.win[i]].status = PLAYER_STATUS_TIE;
					tieList.push(getPlayerById(chances.win[i], playersList));
				}
			}
			
		}else{
			// check if game could still continue due to tie or win chance:
			for (const player of playersList) {
				let playerStatus = playerStatuses[player.id];
				
				let nextTurnPossibleMove = player.minesFound + minesRemaining;

				// minesRemaining: 2
				// maxplayer: 4
				// before: 0,2,3,4
				//  after: 2,4,5,6
				//         N,T,W,W
				
				if(player.minesFound < maxPlayerMines){
					if(nextTurnPossibleMove < maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_NONE;
					}else if(nextTurnPossibleMove == maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_TIE;
					}else if(nextTurnPossibleMove > maxPlayerMines){
						playerStatus.chance = PLAYER_CHANCE_WIN;
					}
				}else{
					playerStatus.chance = PLAYER_CHANCE_WIN;
				}
			}
			
			//console.log("playerStatuses2b:");
			//console.log(structuredClone(playerStatuses));
			
			let chances = countChances(playerStatuses);
			
			//console.log("chances2b:");
			//console.log(structuredClone(chances));
			
			// clear winner:
			// 2=none, 2=none, 4=win
			if(chances.win.length == 1){
				if(chances.tie.length == 0){
					//playerStatuses[chances.tie[0]].status = PLAYER_STATUS_WIN;
					winnerPlayer = getPlayerById(chances.win[0], playersList);
					//console.log("chances.win[0]");
					//console.log(chances.win[0]);
					//console.log("playersList");
					//console.log(playersList);
					//console.log("winnerPlayer");
					//console.log(winnerPlayer);
					
				}
			}
			// tie is not possible when mines are still remaining.
		}
	}
	
	
	return {ties: tieList, winner: winnerPlayer};
}






function hexToRgba(hex, alpha = 1) {
  // Remove leading # if present
  hex = hex.replace(/^#/, '');

  // Parse short form #abc
  if (hex.length === 3) {
    hex = hex.split('').map(c => c + c).join('');
  }

  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}



function updateGameInfo() {
    if (!gameState.gameStarted) return;

	const currentPlayer = gameState.players[gameState.currentPlayerIndex];

    if (gameState.gameOver) {

        if (gameState.winner) {
			gameInfo.style.backgroundColor = hexToRgba(gameState.winner.color, 0.6);
			
			if(gameState.winner.id === localPlayer.id){
				gameInfo.textContent = `You won the game!`;
			}else{
				gameInfo.textContent = `${gameState.winner.name} won the game!`;
			}
        } else {
			gameInfo.style.backgroundColor = hexToRgba("#000000", 0.6);
			
			if(gameState.players.length == 2){
				gameInfo.textContent = "It's a tie!";
			}else{
				let tieListStr = "It's a tie for players: ";
				let tieListNames = [];
				for(let i = 0; i < gameState.ties.length; i++){
					tieListNames.push(gameState.ties[i].name);
				}
				gameInfo.textContent = tieListStr+tieListNames.join(", ");
			}
        }
		
		for(let i = 0; i < gameState.players.length; i++){
			let playerMinesValue = document.getElementById(`gameStateValue-${gameState.players[i].id}`);
			playerMinesValue.textContent = ": "+gameState.players[i].minesFound;
		}
		
		let remainingMinesValue = document.getElementById(`gameStateValue-mines`);
		remainingMinesValue.textContent = ": "+gameState.minesRemaining;
		
    } else {
		gameInfo.style.backgroundColor = hexToRgba(currentPlayer.color, 0.6);
		let turnText = "";
		if(currentPlayer.id === localPlayer.id){
			turnText = "Your Turn";
			
			//gameInfo.classList.add("my-turn");
			//gameInfo.classList.remove("opponent-turn");
		}else{
			turnText = `${currentPlayer.name}'s Turn`;
			//gameInfo.classList.remove("my-turn");
			//gameInfo.classList.add("opponent-turn");
		}
        //const turnText = currentPlayer.id === localPlayer.id ? "Your Turn" : `${currentPlayer.name}'s Turn`;
        gameInfo.textContent = `${turnText}`;
		
		createGameStateElements();
		
		let playerMinesValue = document.getElementById(`gameStateValue-${currentPlayer.id}`);
		playerMinesValue.textContent = ": "+gameState.players[gameState.currentPlayerIndex].minesFound;
		
		let remainingMinesValue = document.getElementById(`gameStateValue-mines`);
		remainingMinesValue.textContent = ": "+gameState.minesRemaining;
    }
}


// ---------- CANVAS DRAWING & INTERACTION ---------- //
let viewport = {
    x: 0, y: 0, scale: 1,
    minScale: 0.2, maxScale: 5,
};
let panState = {
    isPanning: false,
    startX: 0, startY: 0,
};
let lastTap = 0;
let cellSize = 50;

let startTime = Date.now();



function hasMoveAt(x, y) {
  return Object.entries(gameState.lastMoves).some(([playerId, move]) => {
    if (playerId === localPlayer.id) return false; // ignore self
    return move.x === x && move.y === y;
  });
}


let lastTime = 0;
const fps = 60;
const frameDuration = 1000 / fps;

function gameLoop(timestamp) {
  if (timestamp - lastTime >= frameDuration) {
    lastTime = timestamp;
    draw();
  }
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);









let sounds = {
	miss:      {filename: "sounds/miss.mp3",      gain: 1,   filter: false},
	miss_long: {filename: "sounds/miss_long.mp3", gain: 1,   filter: false},
	hit:       {filename: "sounds/hit.mp3",       gain: 0.3, filter: true},
	bigsplash: {filename: "sounds/bigsplash.mp3", gain: 1,   filter: false},
	victory:   {filename: "sounds/victory.mp3",   gain: 1,   filter: false},
	warning:   {filename: "sounds/warning.mp3",   gain: 1,   filter: false},
};

// Preload all sounds
for (const key in sounds) {
  loadSound(sounds[key].filename); // call your loadSound function for each file
}


const context = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds

function loadSound(src) {
  return fetch(src)
    .then(res => res.arrayBuffer())
    .then(data => context.decodeAudioData(data))
    .then(decoded => {
      soundBuffers[src] = decoded; // store buffer by filename
      return decoded; // also return it
    });
}


function playSound(src) {
	let sound = sounds[src];
	const buffer = soundBuffers[sound.filename];
	if (!buffer) return; // sound not loaded yet

	const source = context.createBufferSource();
	source.buffer = buffer;

	// Create a gain node for volume control
	const gainNode = context.createGain();
	gainNode.gain.value = sound.gain; // 1.0 = 100%, 0.5 = 50%, etc.

	if (sound.filter) {
		// Create and use filter
		const filter = context.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = 3000; // let only frequencies below ~3kHz pass

		source.connect(filter);
		filter.connect(gainNode);
	} else {
		// Connect directly
		source.connect(gainNode);
	}

	gainNode.connect(context.destination);
	source.start();
}



const img_water1 = new Image();
img_water1.src = "images/water1.png";
const img_water2 = new Image();
img_water2.src = "images/water2.png";
const img_water3 = new Image();
img_water3.src = "images/water3.png";

const img_empty = new Image();
img_empty.src = "images/empty.png";

const img_flag_red = new Image();
img_flag_red.src = "images/flag-red.png";
const img_flag_blue = new Image();
img_flag_blue.src = "images/flag-blue.png";
const img_flag_yellow = new Image();
img_flag_yellow.src = "images/flag-yellow.png";
const img_flag_green = new Image();
img_flag_green.src = "images/flag-green.png";

const img_mine = new Image();
img_mine.src = "images/mine.png";

const img_turn_red = new Image();
img_turn_red.src = "images/turn-red.png";
const img_turn_blue = new Image();
img_turn_blue.src = "images/turn-blue.png";
const img_cursor = new Image();
img_cursor.src = "images/cursor.png";

let images = {
	water: [img_water1, img_water2, img_water3],
	empty: img_empty,
	flag: {
		red: img_flag_red,
		blue: img_flag_blue,
		yellow: img_flag_yellow,
		green: img_flag_green,
	},
	mine: img_mine,
	turn: {
		red: img_turn_red,
		blue: img_turn_blue,
	},
	cursor: img_cursor,
};


let numbercolors = [
	"",
	"#050DA5", // 1
	"#246100", // 2
	"#BC0C00", // 3
	"#0E0C71", // 4
	"#733F00", // 5
	"#FF0F8B", // 6 magentaish
	"#83FF5D", // 7 light yellow
	"#FFFFFF"  // 8
];

function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/*
function drawImage(ctx, image, offsetX, offsetY, x, y, cellSize, scale){
	ctx.drawImage(
		image,
		offsetX + x*cellSize - 0.5,
		offsetY + y*cellSize - 0.5,
		cellSize + 1,
		cellSize + 1
	);
}*/
function drawImage(ctx, image, offsetX, offsetY, x, y, cellSize, scale = 1) {
  // Target width/height after scaling
  const drawSize = cellSize * scale+1;

  // Center the scaled image inside the square
  const posX = offsetX + x * cellSize + (cellSize - drawSize) / 2-0.5;
  const posY = offsetY + y * cellSize + (cellSize - drawSize) / 2-0.5;

  ctx.drawImage(image, posX, posY, drawSize, drawSize);
}

function drawTransparentSquare(ctx, x, y, size, color, alpha = 0.5) {
  ctx.save();
  ctx.globalAlpha = alpha;  // set transparency
  ctx.fillStyle = color;    // e.g. "red" or "#00ff00"
  ctx.fillRect(x-1, y-1, size+2, size+2);
  ctx.restore();
}



let MAX_CELL_FRAMES = 10;

function draw() {
    if (!gameState.gameStarted) return;
	
	const time = (Date.now() - startTime) / 1000; // seconds
	const pulse = 1 + 0.4 * Math.sin(time * 4);   // oscillates between 0.8‚Äì1.2
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(viewport.scale, viewport.scale);
    ctx.translate(viewport.x, viewport.y);

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    // Draw symbols
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${cellSize * 0.7}px sans-serif`;
    
    for (let y = 0; y < gameState.gridSize.y; y++) {
        for (let x = 0; x < gameState.gridSize.x; x++) {
			let drawCell = true;
			// World coordinates of the cell (before scaling/translation)
			const worldX = offsetX + x * cellSize;
			const worldY = offsetY + y * cellSize;

			// Convert to screen coordinates
			const screenX = (worldX + viewport.x) * viewport.scale + canvas.width / 2;
			const screenY = (worldY + viewport.y) * viewport.scale + canvas.height / 2;
			const screenSize = cellSize * viewport.scale;
			
			// check if square is inside visible screen area:
			const margin = 0; 
			if (
			  screenX + screenSize < 0 + margin ||    // left (shrink visible area)
			  screenY + screenSize < 0 + margin ||    // top
			  screenX > canvas.width - margin ||      // right
			  screenY > canvas.height - margin        // bottom
			) {
			  drawCell = false; // skip drawing this cell
			}
	
			const mapcell = gameState.minemap.map[y][x];
			
			let scale = 1;
			
			if(mapcell.visible){
				scale = (mapcell.frame/MAX_CELL_FRAMES);
			}
			
			if(drawCell){

				if(mapcell.visible){
					// draw numbers
				
					if (mapcell.type >= TYPE_EMPTY){
						if(mapcell.frame < MAX_CELL_FRAMES){
							drawImage(ctx, images.water[mapcell.waternum], offsetX, offsetY, x, y, cellSize);
						}
						drawImage(ctx, images.empty, offsetX, offsetY, x, y, cellSize, scale);
					}else{
						drawImage(ctx, images.water[mapcell.waternum], offsetX, offsetY, x, y, cellSize);
						if(mapcell.owner == 0){
							drawImage(ctx, images.flag.red, offsetX, offsetY, x, y, cellSize, scale);
						}else if(mapcell.owner == 1){
							drawImage(ctx, images.flag.blue, offsetX, offsetY, x, y, cellSize, scale);
						}else if(mapcell.owner == 2){
							drawImage(ctx, images.flag.yellow, offsetX, offsetY, x, y, cellSize, scale);
						}else{
							drawImage(ctx, images.flag.green, offsetX, offsetY, x, y, cellSize, scale);
						}
					}

				}else{
					drawImage(ctx, images.water[mapcell.waternum], offsetX, offsetY, x, y, cellSize);
						
					if(gameState.gameOver){
						if(mapcell.type < TYPE_EMPTY){
							drawImage(ctx, images.mine, offsetX, offsetY, x, y, cellSize, 1);
						}
					}
					
					if(mapcell.numbersAround == 0){
						drawTransparentSquare(ctx, offsetX+x*cellSize, offsetY+y*cellSize, cellSize, "#000088", alpha = 0.4); 
					}
				}
				
				if (gameState.grid[y] && gameState.grid[y][x]) {
					const symbol = gameState.grid[y][x];
					const playerIndex = gameState.players.findIndex(p => p.symbol === symbol);


					let baseSize = cellSize * (scale*0.8);
					let fontSize = baseSize;


					ctx.font = `bold ${fontSize}px sans-serif`;

					// Draw symbol
					//ctx.fillStyle = playerIndex > -1 ? `hsl(${playerIndex * 60}, 80%, 70%)` : "black";
					ctx.fillStyle = numbercolors[mapcell.type];
					

					ctx.fillText(
					  symbol,
					  offsetX + x * cellSize + cellSize / 2,
					  offsetY + y * cellSize + cellSize / 2+3
					);
				}
			}
			
			
			if(mapcell.visible){
				mapcell.frame++;
				if(mapcell.frame > MAX_CELL_FRAMES){
					mapcell.frame = MAX_CELL_FRAMES;
				}
			}
        }
    }
	
	
	// draw last moves circles and crosshairs:
	for (const playerId in gameState.lastMoves) {
		const move = gameState.lastMoves[playerId];
		let player = getPlayerById(playerId);
		drawCorners(ctx, 
			offsetX+move.x*cellSize, 
			offsetY+move.y*cellSize, cellSize, hexToRgba(player.color, 0.8), pulse*1.1
		);
		
		/*
		if(!gameState.gameOver && player.id !== localPlayer.id){
			
			let maxsize = Math.max(gameState.gridSize.x, gameState.gridSize.y)*cellSize;
			
			const pulse2 = 0.1+(1+Math.sin(time * 4))/2;
    
	
			// shadow
			drawCircle(ctx, offsetX, offsetY, 
				move.x*cellSize+cellSize/2, 
				move.y*cellSize+cellSize/2, maxsize*pulse2, 7, "rgba(0,0,0,0.2)"
			);
			drawCircle(ctx, offsetX, offsetY, 
				move.x*cellSize+cellSize/2, 
				move.y*cellSize+cellSize/2, maxsize*pulse2, 3, hexToRgba(player.color, 1)
			);
		}*/

	}

 
	// draw cursor:
	if(renderMouse){
		drawImage(ctx, images.cursor, offsetX, offsetY, mousePos.x, mousePos.y, cellSize, 1.25);
	}


    ctx.restore();
}


function randomPlayerName() {
	const prefixes = [
		"al", "bel", "cor", "dar", "el", "fen", "gal", "hal", "jor", "kal",
		"lin", "mor", "nor", "or", "pel", "quil", "ron", "sel", "tor", "val"
	];

	const middles = [
		"a", "e", "i", "o", "u", "ae", "ia", "eo", "ou", "ai"
	];

	const suffixes = [
		"dor", "mar", "ric", "tan", "ven", "win", "bar", "dris", "lith", "zor",
		"thus", "mir", "gorn", "las", "thar", "mond"
	];

	const endings = [
		"son", "ton", "ley", "well", "ford", "smith", "shire", "worth", "more", "vell"
	];

	function capitalize(word) {
		return word.charAt(0).toUpperCase() + word.slice(1);
	}

	const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
	const middle = middles[Math.floor(Math.random() * middles.length)];
	const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
	const ending = endings[Math.floor(Math.random() * endings.length)];

	return capitalize(prefix + middle + suffix + ending);
}

// Example: generate 5 names
for (let i = 0; i < 5; i++) {
  console.log(randomPlayerName());
}




function drawCorners(ctx, x, y, cellSize, color, scale = 1) {
	const lineWidth = 5 * scale;
	const len = (cellSize / 5) * scale; // "leg" length scaled
	const half = cellSize / 2;

	ctx.save();
	ctx.translate(x + half, y + half); // move origin to center
	ctx.scale(scale, scale);           // scale relative to center
	ctx.translate(-half, -half);       // move back

	ctx.strokeStyle = color;
	ctx.lineWidth = lineWidth;
	ctx.beginPath();

	// Top-left corner
	ctx.moveTo(0, len);
	ctx.lineTo(0, 0);
	ctx.lineTo(len, 0);

	// Top-right corner
	ctx.moveTo(cellSize - len, 0);
	ctx.lineTo(cellSize, 0);
	ctx.lineTo(cellSize, len);

	// Bottom-right corner
	ctx.moveTo(cellSize, cellSize - len);
	ctx.lineTo(cellSize, cellSize);
	ctx.lineTo(cellSize - len, cellSize);

	// Bottom-left corner
	ctx.moveTo(len, cellSize);
	ctx.lineTo(0, cellSize);
	ctx.lineTo(0, cellSize - len);

	ctx.stroke();
	ctx.restore();
}




function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (gameState.gameStarted) {
        draw();
    }
}


let mousePos = { x: 0, y: 0 };
let renderMouse = true;

function mouseInsideMap(){
	if(mousePos.x >= 0 && mousePos.x < gameState.gridSize.x){
		if(mousePos.y >= 0 && mousePos.y < gameState.gridSize.y){
			return true;
		}
	}
	return false;
}

function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
	
	//mousePos.x = e.clientX - rect.left;
	//mousePos.y = e.clientY - rect.top;
	mousePos = getGridCoords(e.clientX - rect.left, e.clientY - rect.top);
	renderMouse = true;
	if(!mouseInsideMap()){
		renderMouse = false;
	}
	//console.log(mousePos);
    if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function getGridCoords(canvasX, canvasY) {
    // Inverse transform canvas coordinates to world coordinates
    const worldX = (canvasX - canvas.width / 2) / viewport.scale - viewport.x;
    const worldY = (canvasY - canvas.height / 2) / viewport.scale - viewport.y;

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    const gridX = Math.floor((worldX - offsetX) / cellSize);
    const gridY = Math.floor((worldY - offsetY) / cellSize);

    return { x: gridX, y: gridY };
}



// Canvas event listeners
let panStart = { x: 0, y: 0 };
let isPanning = false;

function onPointerDown(e) {
    if (e.touches && e.touches.length > 1) return;
    isPanning = true;
    const pos = getTouchPos(e);
    panStart.x = pos.x - viewport.x * viewport.scale;
    panStart.y = pos.y - viewport.y * viewport.scale;
}

function onPointerMove(e) {    
	const pos = getTouchPos(e);
	//console.log(pos);
    if (!isPanning || (e.touches && e.touches.length > 1)) return;

    viewport.x = (pos.x - panStart.x) / viewport.scale;
    viewport.y = (pos.y - panStart.y) / viewport.scale;
    //draw();
}

function onPointerUp(e) {
    isPanning = false;
    let currentTime = new Date().getTime();
    if (currentTime - lastTap < 300) {
       onDoubleClick(e);
    }
    lastTap = currentTime;
}

const MOVE_TYPE_NORMAL = 0;
const MOVE_TYPE_BOMB = 1;


function onRightClick(e){
    e.preventDefault(); // stops the browser context menu
    if (gameState.gameOver) return;
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (currentPlayer.id !== localPlayer.id) return;
	
	console.log("onRightClick");
	
    const pos = getTouchPos(e);
    const { x, y } = getGridCoords(pos.x, pos.y);

    if (x >= 0 && x < gameState.gridSize.x && y >= 0 && y < gameState.gridSize.y) {
        const move = { x, y, playerId: localPlayer.id, weapon: MOVE_TYPE_BOMB };
        if (isHost) {
            handlePlayerMove(move);
        } else {
            sendToHost({ type: 'player_move', move });
        }
    }
	
}



function onDoubleClick(e) {
    if (gameState.gameOver) return;
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (currentPlayer.id !== localPlayer.id) return;
	
	console.log("onDoubleClick");

    const pos = getTouchPos(e);
    const { x, y } = getGridCoords(pos.x, pos.y);


    if (x >= 0 && x < gameState.gridSize.x && y >= 0 && y < gameState.gridSize.y) {
        const move = { x, y, playerId: localPlayer.id, weapon: MOVE_TYPE_NORMAL};
        if (isHost) {
            handlePlayerMove(move);
        } else {
            sendToHost({ type: 'player_move', move });
        }
    }
}

let lastDist = 0;
function onTouchStart(e) {
    if (e.touches.length > 1) { 
        isPanning = false; 
        lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
    } else { 
        onPointerDown(e);
    }
}

function onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length > 1) {
        const newDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        const scaleFactor = newDist / lastDist;
        const newScale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
        viewport.scale = newScale;
        lastDist = newDist;
		//console.log(newDist);
        //draw();
    } else {
        onPointerMove(e);
    }
}

canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
canvas.addEventListener('touchend', onPointerUp);

canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
canvas.addEventListener('mouseup', onPointerUp);
canvas.addEventListener('mouseleave', () => isPanning = false);
canvas.addEventListener('dblclick', onDoubleClick);
canvas.addEventListener('contextmenu', onRightClick);

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    viewport.scale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
    //draw();
}, { passive: false });


// ---------- INITIALIZATION ---------- //
hostBtn.addEventListener('click', hostGame);
joinBtn.addEventListener('click', joinGame);
startGameBtn.addEventListener('click', startGame);
//changeSymbolBtn.addEventListener('click', attemptSetSymbol);
window.addEventListener('resize', resizeCanvas);

customSymbolInput.addEventListener('input', attemptSetSymbol);

</script>
</body>
</html>