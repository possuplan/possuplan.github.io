<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wi-Fi Tic-Tac-Toe</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
	
	<script src="riffwave.js"></script>
	<script src="sfxr.js"></script>
	<!--
	todo: 
	- tasapeliä ei tarksiteta ollenkaan. pitää tehä uus tsekkaus sitä varten. play_sound("tie");
	-->
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-text: #e0e0e0;
            --secondary-text: #a0a0a0;
            --border-color: #333;
            --accent-color: #03dac6;
            --grid-line-color: #444;
            --win-line-color: #ffeb3b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--primary-text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 400px;
            padding: 20px;
            text-align: center;
        }

        .screen.active {
            display: flex;
        }

        h1, h2 {
            margin-top: 0;
            font-weight: 500;
        }

        .input-group {
            width: 100%;
            margin-bottom: 15px;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--primary-text);
            font-size: 16px;
        }

        input::placeholder {
            color: var(--secondary-text);
        }

        button {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            background-color: var(--accent-color);
            color: #000;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:disabled {
            background-color: #555;
            color: #888;
            cursor: not-allowed;
        }

        button.secondary {
            background-color: var(--surface-color);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }

        .symbol-select-group {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        #symbol-select {
            flex-grow: 1;
        }

        #custom-symbol-input {
            width: 80px;
            text-align: center;
            font-size: 20px;
        }
        
        #player-list {
            list-style: none;
            padding: 0;
            width: 100%;
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
        }

        #player-list li {
            background-color: var(--surface-color);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 18px;
        }
        
        #game-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Managed by JS */
            flex-direction: column;
        }

        #game-canvas {
            touch-action: none; /* Disables default browser gestures */
            background-color: #000;
            width: 100%;
            height: 100%;
        }

        #game-info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 5px;
            text-align: center;
            font-size: 1.2em;
            color: white;
            pointer-events: none; /* Clicks go through it */
            z-index: 10;
        }
		
#chat {
  position: absolute;
  top: 0;
  left: 0;             /* start from the left edge */
  right: 0;            /* stretch to the right edge */
  display: flex;
  gap: 5px;
  align-items: center;  /* vertically center children */
  padding: 0 10px;     /* optional horizontal padding */
  box-sizing: border-box; /* include padding in width */
}


#chatMessages {
  flex: 1;               /* takes all remaining space */
  border: 1px solid #ccc;
  padding: 5px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  height:90px;
}

#chatInput {
  width: 100px;           /* fixed sizes */
    position: relative;
    top: 20px;
}


#chatSend {
  width: 80px;           /* fixed width */
    position: relative;
    top: 20px;
}


		.my-turn {
            background-color: rgba(0,0,255,0.5);
		}
		.opponent-turn {
            background-color: rgba(255,0,0,0.5);
		}
    </style>
	
	
	






<style>
/*
  body { 
    font-family: sans-serif; 
    margin: 20px; 
    background: #121212; 
    color: #eee;
  }
  select, input { 
    font-size: 16px; 
    padding: 5px; 
    background: #1e1e1e;
    color: #eee;
    border: 1px solid #555;
  }
  */
  
  #emojiView {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #1a1a1a;
    overflow-y: auto;
    display: none;
    padding: 5px;
    box-sizing: border-box;
    z-index: 1000;
    color: #eee;
    padding-top: 65px;
  }
#emojiGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, 50px);
  gap: 0;
}

.emojiSquare {
  width: 50px;
  height: 50px;
  outline: 1px solid #555; /* outline doesn’t double up */
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 40px;
  cursor: pointer;
  background: #222;
  color: #eee;
}
  .emojiSquare:hover {
	  background: #ff0000;
	  color: #fff;
  }
  #emojiControls {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
  }
#closeBtn {
    position: fixed;
    top: 4px;
    right: 11px;
    cursor: pointer;
    font-weight: bold;
    font-size: 29px;
    padding: 5px 12px;
    background: #333;
    border: 3px solid #DDD;
    color: #eee;
    border-radius: 4px;
    box-shadow: 0 0 15px 10px rgba(0,0,0,0.75);
}

  #closeBtn:hover { background: #ff4d4d; color: #fff; }
  #searchOptions { display: flex; align-items: center; gap: 5px; }
  #searchOptions input, #searchOptions button {
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 5px 8px;
    border-radius: 4px;
  }
  #searchOptions button:hover { background: #ff4d4d; color: #fff; }
</style>


</head>
<body>


    <div id="home-screen" class="screen active">
        <h1>Wi-Fi Tic-Tac-Toe</h1>
        <div class="input-group">
            <input type="text" id="game-name-input" value="DefaultGameName" placeholder="Enter Game Name">
        </div>
        <div class="input-group">
            <input type="text" id="player-name-input" placeholder="Enter Your Name">
        </div>
        <button id="host-btn">Host Game</button>
        <br>
        <button id="join-btn" class="secondary">Join Game</button>
        <p id="home-error" style="color: #FF00FF;"></p>
    </div>

    <div id="lobby-screen" class="screen">
        <h2 id="lobby-game-name"></h2>
        <div id="host-controls">
            <h3>Game Settings</h3>
            <div class="input-group" style="display: flex; gap: 10px;">
                <input type="number" id="grid-x-input" value="30" min="3">
                <input type="number" id="grid-y-input" value="30" min="3">
            </div>
            <div class="input-group">
                <label for="win-condition-input">Symbols in a row to win:</label>
                <input type="number" id="win-condition-input" value="5" min="3">
            </div>
            <button id="start-game-btn">Start Game</button>
        </div>
        
        <h3>Players in Lobby</h3>
        <ul id="player-list"></ul>
        
        <div class="input-group">
            <label>Your Symbol</label>
            <div class="symbol-select-group">
                <select id="symbol-select"></select>

<label for="groupSelect">Group:</label>
<select id="groupSelect">
  <option value=""></option>
  <option value="search">--Search--</option>
</select>
<!--<input type="text" id="selectedEmoji" placeholder="Selected Emoji">-->

<div id="emojiView">
  <div id="emojiControls">
    <div id="searchOptions" style="display:none;">
      <input type="text" id="searchInput" placeholder="Search...">
      <button id="matchModeBtn">Word</button>
      <button id="searchBtn">Search</button>
    </div>
    <div id="closeBtn">✖</div>
  </div>
  <div id="emojiGrid"></div>
</div>



                <input type="text" id="custom-symbol-input" maxlength="16" placeholder="Unicode">
            </div>
        </div>
        <!--<button id="change-symbol-btn">Set Symbol</button>-->
        <p id="lobby-error" style="color: red;"></p>
    </div>

    <div id="game-screen">
        <div id="game-info"></div>
        <canvas id="game-canvas"></canvas>
		

		 <!-- Chat box -->
		<div id="chat">
			<div id="chatMessages"></div>
			<input id="chatInput" type="text" placeholder="Type message...">
			<button id="chatSend">Send</button>
		</div>
    </div>



<script>

var CACHED_SOUND_EFFECTS = {};


var SOUNDS = {
	//undo: [1,0,0,0.145,0,0.432,0.468603,0,-0.212,0,0,0,0,0,0.548476,0,0,0,0,0.756234,0,0,0,0,0.061],
	changestyle: [1,0,0,0.066307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.623612,0,0,1,0,0,0,0,0.11],
	showhide: [1,3,0.219375,0.070448,0.264728,0.246,0.940782,0,-0.359019,0,0.276075,0.558813,0,0,0,0,0,0,0,1,0,0,0.909348,0,0.252],
	complete: [1,0,0,0.414,0.092,0.851,0.269,0,0.391888,0,0,0.787,0.027,0.033,0.082,-0.489,0.463,0.002,0.001,1,0,0,0,0,0.13],
	explosion: [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	hint: [1,3,0.2034,0.519972,0.079301,0.420554,0.503805,0,0.019718,-0.113554,0.02742,-0.960806,0.437405,-0.928749,0.31182,0.242098,-0.059401,0.008261,-0.0102,0.205988,0.046432,0.574843,0.114387,0.001109,0.1068],
	already: [1,1,0,0.115,0.431,0.526,0.311,0,0,-0.266,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.184],
	tie: [1,0,0,0.66307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.423612,0,0,1,0,0,0,0,0.11],
	fail: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,-0.352,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	really: [1,0,0,0.382534,0,0.663,0.318,0,0.115469,-0.138,0,0,0,0,0.31911,0,0,0,0,0.642664,0,0,0,0,0.1068],
	kill: [1,0,0,0.089127,0,0.441,0.494,0,-0.333792,0,0,0,0,0,0.080034,0,0,0,0,1,0,0,0.013473,0,0.09],
	next: [1,0,0,0.362553,0,0.454,0.501627,0,0.205054,0,0,0,0,0,0.578561,0,0,0,0,0.902463,0,0,0.157574,0,0.1068],
	clear: [1,3,0,0.233,0.316,0.438,0.301,0,-0.294087,0,0,0,0.319083,0.897748,0,0,0.670729,0,0,1,0,0,0,0,0.1068],
	score: [1,0,0,0.353496,0,0.472,0.404228,0,0.391888,0,0,0,0,0,0.174445,0,0.527907,0,0,1,0,0,0,0,0.1068],
	click: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,0,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	shuffle: [1,1,0,0.19396,0,0.463777,0.225533,0,0.307713,0,0,0,0,0,1,0,0.578735,0,0,1,0,0,0,0,0.134],
}




/////////////////////////////////
// JSFXR

var SOUNDS_ENABLED = true;
var PARAMS;
if(typeof Params !== "undefined"){
	PARAMS = new Params();
}else{
	SOUNDS_ENABLED = false;
}
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;

// JSFXR
/////////////////////////////////




function generate_sounds(){
	if(SOUNDS_ENABLED){
		for(var soundName in SOUNDS) {
			if(SOUNDS.hasOwnProperty(soundName)){
				console.log("Generating sound "+soundName);
				generate_sound_caches(soundName);
			}
		}
	}
}


function generate_sound_caches(soundName){
	if(SOUNDS_ENABLED){
		let newPARAMS = SOUNDS[soundName];
		
		if(newPARAMS[0] != 1){
			console.log("unknown sound version '"+newPARAMS[0]+"'");
			console.log(newPARAMS);
			return;
		}
		
		let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
		
		let output = {};
		output['oldParams'] = true;
		output['sample_rate'] = 44100;
		output['sample_size'] = 8;

		for(let i = 1; i < order.length; i++){
			output[order[i]] = newPARAMS[i];
		}

		PARAMS.fromJSON(output);
		
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName] = {};
		}
		
		SOUND = new SoundEffect(PARAMS).generate();
		CACHED_SOUND_EFFECTS[soundName]['sound'] = SOUND;
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	}
}


function play_sound(soundName){
	if(SOUNDS_ENABLED){
		if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
			return;
		}
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'];
		SOUND.getAudio().play();
		console.log("play_sound: "+soundName);
		
		//console.log("CACHED_SOUND_EFFECTS:");
		//console.log(CACHED_SOUND_EFFECTS);
	}
}

generate_sounds();



let emojiData = [];
let matchMode = 'word'; // or 'any'

async function loadEmojis() {
  const res = await fetch('emojis-all.json');
  emojiData = await res.json();

  const select = document.getElementById('groupSelect');
  emojiData.forEach(group => {
    const opt = document.createElement('option');
    opt.value = group.group;
    opt.textContent = group.group;
    select.appendChild(opt);
  });
}

function showEmojiView(items) {
  const grid = document.getElementById('emojiGrid');
  grid.innerHTML = '';
  items.forEach(([symbol, name]) => {
    const div = document.createElement('div');
    div.className = 'emojiSquare';
    div.textContent = symbol;
    div.title = name;
    div.addEventListener('click', () => {
      document.getElementById('custom-symbol-input').value = symbol;
      document.getElementById('emojiView').style.display = 'none';
	  attemptSetSymbol();
    });
    grid.appendChild(div);
  });
  document.getElementById('emojiView').style.display = 'block';
}

document.getElementById('groupSelect').addEventListener('change', (e) => {
  const val = e.target.value;
  const searchOptions = document.getElementById('searchOptions');
  if(val === 'search') {
    searchOptions.style.display = 'flex';
    document.getElementById('emojiGrid').innerHTML = '';
    document.getElementById('emojiView').style.display = 'block';
  } else {
    searchOptions.style.display = 'none';
    const group = emojiData.find(g => g.group === val);
    if(group) showEmojiView(group.list);
  }
});

document.getElementById('closeBtn').addEventListener('click', () => {
  document.getElementById('emojiView').style.display = 'none';
});

document.getElementById('matchModeBtn').addEventListener('click', () => {
  matchMode = matchMode === 'word' ? 'any' : 'word';
  document.getElementById('matchModeBtn').textContent = matchMode.charAt(0).toUpperCase() + matchMode.slice(1);
});

document.getElementById('searchBtn').addEventListener('click', () => {
  const query = document.getElementById('searchInput').value.toLowerCase();
  if(!query) return;
  let results = [];
  emojiData.forEach(group => {
    group.list.forEach(([symbol,name]) => {
      const lname = name.toLowerCase();
      if((matchMode==='word' && lname.split(' ').includes(query)) ||
         (matchMode==='any' && lname.includes(query))) {
        results.push([symbol,name]);
      }
    });
  });
  showEmojiView(results);
});

loadEmojis();
</script>


<script>
// ---------- CONFIG & STATE ---------- //
const PREDEFINED_SYMBOLS = ['X', 'O', '#', '%'];

let peer;
let myPeerId;
let hostId;
let connections = {}; // key: peerId, value: connection object
let isHost = false;

let lastMoves = {};

let localPlayer = {
    id: null,
    name: "Player",
    symbol: '',
    isReady: false,
};

let gameState = {
    players: [],
    grid: [],
    gridSize: { x: 10, y: 10 },
    winCondition: 4,
    currentPlayerIndex: 0,
    gameStarted: false,
    gameOver: false,
    winner: null,
};


// ---------- UI ELEMENT REFERENCES ---------- //
const screens = {
    home: document.getElementById('home-screen'),
    lobby: document.getElementById('lobby-screen'),
    game: document.getElementById('game-screen'),
};
const gameNameInput = document.getElementById('game-name-input');
const playerNameInput = document.getElementById('player-name-input');
const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const homeError = document.getElementById('home-error');

const lobbyGameName = document.getElementById('lobby-game-name');
const hostControls = document.getElementById('host-controls');
const startGameBtn = document.getElementById('start-game-btn');
const playerList = document.getElementById('player-list');
const symbolSelect = document.getElementById('symbol-select');
const customSymbolInput = document.getElementById('custom-symbol-input');
//const changeSymbolBtn = document.getElementById('change-symbol-btn');
const lobbyError = document.getElementById('lobby-error');
const gridXInput = document.getElementById('grid-x-input');
const gridYInput = document.getElementById('grid-y-input');
const winConditionInput = document.getElementById('win-condition-input');

const gameInfo = document.getElementById('game-info');
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;

const chatMessages = document.getElementById("chatMessages");
const chatInput = document.getElementById("chatInput");
const chatSend = document.getElementById("chatSend");



// ---------- UI MANAGEMENT ---------- //
function showScreen(screenName) {
    Object.values(screens).forEach(screen => screen.classList.remove('active'));
    if(screenName === 'game') {
        screens.game.style.display = 'flex';
        screens.home.style.display = 'none';
        screens.lobby.style.display = 'none';
    } else {
        screens.game.style.display = 'none';
        screens[screenName].classList.add('active');
    }
}

function updateLobbyUI() {
    lobbyGameName.textContent = `Game: ${gameNameInput.value}`;
    hostControls.style.display = isHost ? 'block' : 'none';
    
    const me = gameState.players.find(p => p.id === localPlayer.id);
    if (me) {
        localPlayer = { ...localPlayer, ...me };
    }

    playerList.innerHTML = '';
    gameState.players.forEach(p => {
        const li = document.createElement('li');
        li.textContent = `${p.symbol} - ${p.name}`;
        playerList.appendChild(li);
    });

    const usedSymbols = gameState.players.map(p => p.symbol);
    const availableSymbols = PREDEFINED_SYMBOLS.filter(s => !usedSymbols.includes(s) || s === localPlayer.symbol);

    symbolSelect.innerHTML = availableSymbols.map(s => `<option value="${s}" ${s === localPlayer.symbol ? 'selected' : ''}>${s}</option>`).join('');
/*
	// bugged. doesnt sometimes allow setting the symbol.
    if (availableSymbols.length > 0) {
        symbolSelect.disabled = false;
        customSymbolInput.value = PREDEFINED_SYMBOLS.includes(localPlayer.symbol) ? '' : localPlayer.symbol;
		
		console.log("availableSymbols.length > 0");
		console.log(PREDEFINED_SYMBOLS);
		console.log(localPlayer.symbol);
    } else {
        symbolSelect.disabled = true;
        symbolSelect.innerHTML = '<option>All taken</option>';
        customSymbolInput.value = localPlayer.symbol;
		
		console.log("availableSymbols.length <= 0");
		console.log(PREDEFINED_SYMBOLS);
		console.log(localPlayer.symbol);
    }*/
}

function updateGameUI() {
    if (gameState.gameStarted) {
        updateGameInfo();
        draw();
		console.log("updateGameUI draw()");
    }
}

// ---------- NETWORKING (PeerJS) ---------- //
function initializePeer(peerId) {
    myPeerId = peerId || 'tictactoe-' + Math.random().toString(36).substr(2, 9);
    localPlayer.id = myPeerId;
    peer = new Peer(myPeerId, { debug: 2 });

    peer.on('open', id => {
        console.log('My peer ID is: ' + id);
    });

    peer.on('connection', conn => {
        setupConnection(conn);
    });

    peer.on('error', err => {
        console.error("PeerJS Error:", err);
        homeError.textContent = `Error: ${err.message}. Try a different Game Name.`;
        joinBtn.disabled = false;
        hostBtn.disabled = false;
    });
}

function setupConnection(conn) {
    conn.on('open', () => {
        console.log(`Connected to ${conn.peer}`);
        connections[conn.peer] = conn;

        if (isHost) {
            conn.send({ type: 'game_state', state: gameState });
        }
    });

    conn.on('data', data => handleMessage(data, conn.peer));
    conn.on('close', () => {
        console.log(`Connection closed with ${conn.peer}`);
        delete connections[conn.peer];
        if (isHost) {
            gameState.players = gameState.players.filter(p => p.id !== conn.peer);
            broadcast({ type: 'game_state', state: gameState });
            updateLobbyUI(); // Host updates its own view
        }
    });
}

function hostGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
    localPlayer.name = playerName;
    isHost = true;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
    initializePeer(gameName); 
    
    localPlayer.symbol = PREDEFINED_SYMBOLS[0];
    localPlayer.isReady = true;
    gameState.players.push(localPlayer); 
    
    showScreen('lobby');
    updateLobbyUI();
}

function joinGame() {
    const gameName = gameNameInput.value.trim();
    const playerName = playerNameInput.value.trim();
    if (!gameName || !playerName) {
        homeError.textContent = "Game Name and Your Name cannot be empty.";
        return;
    }
    localPlayer.name = playerName;
    isHost = false;
    hostId = gameName;
    hostBtn.disabled = true;
    joinBtn.disabled = true;
    initializePeer();

    setTimeout(() => { 
        if (!peer || !peer.id) return;
        const conn = peer.connect(hostId, { reliable: true });
        if(conn) {
            setupConnection(conn);
        } else {
            homeError.textContent = "Could not connect to host. Check Game Name.";
            hostBtn.disabled = false;
            joinBtn.disabled = false;
        }
    }, 1000);
}

function broadcast(data) {
    if (!isHost) return;
    Object.values(connections).forEach(conn => {
        conn.send(data);
    });
}

function sendToHost(data) {
    if (isHost) return;
    const conn = connections[hostId];
    if (conn) {
        conn.send(data);
    }
}

/*

var SOUNDS = {
	//undo: [1,0,0,0.145,0,0.432,0.468603,0,-0.212,0,0,0,0,0,0.548476,0,0,0,0,0.756234,0,0,0,0,0.061],
	changestyle: [1,0,0,0.066307,0,0.489649,0.468196,0,0.396335,0,0,0,0,0,0.555478,0,0.623612,0,0,1,0,0,0,0,0.11],
	showhide: [1,3,0.219375,0.070448,0.264728,0.246,0.940782,0,-0.359019,0,0.276075,0.558813,0,0,0,0,0,0,0,1,0,0,0.909348,0,0.252],
	complete: [1,0,0,0.414,0.092,0.851,0.269,0,0.391888,0,0,0.787,0.027,0.033,0.082,-0.489,0.463,0.002,0.001,1,0,0,0,0,0.204],
	explosion: [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	hint: [1,3,0.2034,0.519972,0.079301,0.420554,0.503805,0,0.019718,-0.113554,0.02742,-0.960806,0.437405,-0.928749,0.31182,0.242098,-0.059401,0.008261,-0.0102,0.205988,0.046432,0.574843,0.114387,0.001109,0.1068],
	already: [1,1,0,0.115,0.431,0.526,0.311,0,0,-0.266,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.184],
	fail: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,-0.352,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	really: [1,0,0,0.382534,0,0.663,0.318,0,0.115469,-0.138,0,0,0,0,0.31911,0,0,0,0,0.642664,0,0,0,0,0.1068],
	kill: [1,0,0,0.089127,0,0.441,0.494,0,-0.333792,0,0,0,0,0,0.080034,0,0,0,0,1,0,0,0.013473,0,0.09],
	next: [1,0,0,0.362553,0,0.454,0.501627,0,0.205054,0,0,0,0,0,0.578561,0,0,0,0,0.902463,0,0,0.157574,0,0.1068],
	clear: [1,3,0,0.233,0.316,0.438,0.301,0,-0.294087,0,0,0,0.319083,0.897748,0,0,0.670729,0,0,1,0,0,0,0,0.1068],
	score: [1,0,0,0.353496,0,0.472,0.404228,0,0.391888,0,0,0,0,0,0.174445,0,0.527907,0,0,1,0,0,0,0,0.1068],
	click: [1,1,0,0.081582,0.588936,0.495,0.623,0,0,0,0,0,0.542421,0.624539,0,0,0,0,0,1,0,0,0,0,0.1068],
	shuffle: [1,1,0,0.19396,0,0.463777,0.225533,0,0.307713,0,0,0,0,0,1,0,0.578735,0,0,1,0,0,0,0,0.134],
}
changestyle
showhide hyvä
already ok
fail ok 
already lol
kill hyvä
next hassu
clear hyvä
score ok
click ok
shuffle ok

complete : voitit pelin
explosion : hävisit
*/
function handleMessage(data, peerId) {
    //console.log('Received:', data.type);
    switch (data.type) {
        case 'game_state':
            gameState = data.state;
			console.log("gameState");
			console.log(gameState);
			
			if (gameState.gameOver) {
				if (gameState.winner) {
					//gameInfo.textContent = `${gameState.winner.name} (${gameState.winner.symbol}) won the game!`;
					if(gameState.winner.id === localPlayer.id){
						play_sound("complete");
					}else{
						play_sound("explosion");
					}
				} else {
					play_sound("tie");
				}
			} else {
				if (gameState.lastMove) {
					const { playerId } = gameState.lastMove;
					if (playerId === localPlayer.id) {
						//play_sound("showhide"); // you made the move
					} else {
						play_sound("showhide"); // opponent move
					}
				}
			}
			
            if (!isHost && !localPlayer.isReady) {
                showScreen('lobby');
                sendToHost({ type: 'player_join', player: localPlayer });
                localPlayer.isReady = true; 
            }
            if (gameState.gameStarted) {
                showScreen('game');
                resizeCanvas();
                updateGameUI();
            } else {
                updateLobbyUI();
            }
			

            break;
        case 'player_join':
            if (isHost) {
                // ** THE BUG FIX IS HERE **
                // Check if player already exists before adding
                if (gameState.players.some(p => p.id === data.player.id)) {
                    //console.warn(`Player ${data.player.id} tried to join again. Ignoring.`);
                    // Resend state just in case they missed it
                    connections[data.player.id]?.send({ type: 'game_state', state: gameState });
                    return; 
                }

                let newPlayer = data.player;
                const usedSymbols = gameState.players.map(p => p.symbol);
                const nextSymbol = PREDEFINED_SYMBOLS.find(s => !usedSymbols.includes(s));
                newPlayer.symbol = nextSymbol || '';
                
                gameState.players.push(newPlayer);
                broadcast({ type: 'game_state', state: gameState });
                updateLobbyUI();
            }
            break;
        case 'player_update':
             if (isHost) {
                const playerIndex = gameState.players.findIndex(p => p.id === peerId);
                if (playerIndex > -1) {
                    const requestedSymbol = data.player.symbol;
                    if (gameState.players.some((p, i) => p.symbol === requestedSymbol && i !== playerIndex)) {
                        connections[peerId].send({type: 'symbol_taken'});
                    } else {
                        gameState.players[playerIndex].symbol = data.player.symbol;
                        broadcast({ type: 'game_state', state: gameState });
                        updateLobbyUI();
                    }
                }
            }
            break;
        case 'symbol_taken':
            lobbyError.textContent = "Symbol is already taken!";
            setTimeout(() => lobbyError.textContent = "", 2000);
            break;
        case 'game_start': // This case can be removed if game_state handles it all
            gameState.grid = data.grid;
            gameState.gridSize = data.gridSize;
            gameState.winCondition = data.winCondition;
            gameState.currentPlayerIndex = data.currentPlayerIndex;
            gameState.gameStarted = true;
            showScreen('game');
            resizeCanvas();
            updateGameUI();
            break;
        case 'player_move':
            if (isHost) {
                handlePlayerMove(data.move);
            }
            break;
		case "player_message":
		  if (isHost) {
			// Rebroadcast to everyone else, but NOT back to the original sender
			broadcast(data, peerId); // assuming your broadcast supports excluding peerId
		  }

		  // Show the message (all peers including host)
		  addChatMessage(data.playerId, data.text);
		  break;
    }
}


// Send message when clicking the button
chatSend.addEventListener("click", sendChatMessage);

// Or when pressing Enter
chatInput.addEventListener("keydown", e => {
  if (e.key === "Enter") sendChatMessage();
});

function sendChatMessage() {
  const text = chatInput.value.trim();
  if (!text) return;

  const msg = {
    type: "player_message",
    playerId: localPlayer.id,
    text
  };

  if (isHost) {
    // Host only needs to broadcast, not handleMessage directly
    broadcast(msg);
    addChatMessage(msg.playerId, msg.text); // add to host UI only
  } else {
    sendToHost(msg);
    //addChatMessage(msg.playerId, msg.text); // add immediately for sender
  }

  chatInput.value = "";
}



function addChatMessage(playerId, text) {
  const div = document.createElement("div");
  div.textContent = `${playerId}: ${text}`;
  chatMessages.appendChild(div);

  // scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// ---------- GAME LOGIC ---------- //
function attemptSetSymbol() {
    const selectedSymbol = String(symbolSelect.value);
    const customSymbol = String(customSymbolInput.value);
	
	console.log("attemptSetSymbol selectedSymbol:'"+selectedSymbol+"', customSymbol:'"+customSymbol+"'");
    
    let symbolToSet = customSymbol || selectedSymbol;
    if (!symbolToSet || localPlayer.symbol === symbolToSet) return;
	
	console.log("attemptSetSymbol 2");

    let updatedPlayer = { ...localPlayer, symbol: symbolToSet };
    
    const payload = { type: 'player_update', player: updatedPlayer };

    if (isHost) {
		console.log("attemptSetSymbol 3");
        const playerIndex = gameState.players.findIndex(p => p.id === localPlayer.id);
        if (playerIndex > -1) {
            if (gameState.players.some((p, i) => p.symbol === symbolToSet && i !== playerIndex)) {
                lobbyError.textContent = "Symbol is already taken!";
				console.log(lobbyError.textContent);
                setTimeout(() => lobbyError.textContent = "", 2000);
            } else {
                gameState.players[playerIndex].symbol = symbolToSet;
                broadcast({ type: 'game_state', state: gameState });
				console.log("set symbol: "+symbolToSet);
                updateLobbyUI();
            }
        }
    } else {
		console.log("attemptSetSymbol 4");
        sendToHost(payload);
    }
}

function startGame() {
    if (!isHost) return;

    gameState.gridSize = { x: parseInt(gridXInput.value), y: parseInt(gridYInput.value) };
    gameState.winCondition = parseInt(winConditionInput.value);
    gameState.grid = Array(gameState.gridSize.y).fill(null).map(() => Array(gameState.gridSize.x).fill(null));
    gameState.currentPlayerIndex = Math.floor(Math.random() * gameState.players.length);
    gameState.gameStarted = true;
    gameState.gameOver = false;
    gameState.winner = null;
    gameState.winLines = [];

    broadcast({ type: 'game_state', state: gameState });
    handleMessage({ type: 'game_state', state: gameState }); // Update host locally
}


function setLastMoveByPlayer(x, y, playerId) {
    gameState.lastMoves = gameState.lastMoves || {};
    gameState.lastMoves[playerId] = { x, y };
	gameState.lastMove = { x, y, playerId };
}

function handlePlayerMove({x, y, playerId}) {
    if (gameState.gameOver || gameState.grid[y][x] !== null) return;
    
    const player = gameState.players[gameState.currentPlayerIndex];
    if (player.id !== playerId) return;

    gameState.grid[y][x] = player.symbol;
	setLastMoveByPlayer(x, y, player.id);
	
    const winResult = checkWin(x, y);
    if (winResult.won) {
        gameState.gameOver = true;
        gameState.winner = player;
        gameState.winLines = winResult.lines;
    } else {
        gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
    }
    
    broadcast({ type: 'game_state', state: gameState });
    handleMessage({ type: 'game_state', state: gameState });
}

function checkWin(x, y) {
    const symbol = gameState.grid[y][x];
    if (!symbol) return { won: false };
    
    const N = gameState.winCondition;
    const lines = [];

    const directions = [
        { dx: 1, dy: 0 },  // Horizontal
        { dx: 0, dy: 1 },  // Vertical
        { dx: 1, dy: 1 },  // Diagonal \
        { dx: 1, dy: -1 }  // Diagonal /
    ];

    for (const { dx, dy } of directions) {
        let line = [{x, y}];
        
        for (let i = 1; i < N; i++) {
            const newX = x + i * dx;
            const newY = y + i * dy;
            if (newX >= 0 && newX < gameState.gridSize.x && newY >= 0 && newY < gameState.gridSize.y && gameState.grid[newY][newX] === symbol) {
                line.push({x: newX, y: newY});
            } else {
                break;
            }
        }
        
        for (let i = 1; i < N; i++) {
            const newX = x - i * dx;
            const newY = y - i * dy;
            if (newX >= 0 && newX < gameState.gridSize.x && newY >= 0 && newY < gameState.gridSize.y && gameState.grid[newY][newX] === symbol) {
                line.push({x: newX, y: newY});
            } else {
                break;
            }
        }
        
        if (line.length >= N) {
            line.sort((a,b) => a.x - b.x || a.y - b.y);
            for (let i = 0; i <= line.length - N; i++) {
                 lines.push({ start: line[i], end: line[i + N - 1] });
            }
        }
    }
    
    return { won: lines.length > 0, lines: lines };
}

function updateGameInfo() {
    if (!gameState.gameStarted) return;
    
    if (gameState.gameOver) {
        if (gameState.winner) {
			if(gameState.winner.id === localPlayer.id){
				gameInfo.textContent = `You (${gameState.winner.symbol}) won the game!`;
			}else{
				gameInfo.textContent = `${gameState.winner.name} (${gameState.winner.symbol}) won the game!`;
			}
        } else {
            gameInfo.textContent = "It's a draw!";
        }
    } else {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
		let turnText = "";
		if(currentPlayer.id === localPlayer.id){
			turnText = "Your Turn";
			gameInfo.classList.add("my-turn");
			gameInfo.classList.remove("opponent-turn");
		}else{
			turnText = `${currentPlayer.name}'s Turn`;
			gameInfo.classList.remove("my-turn");
			gameInfo.classList.add("opponent-turn");
		}
        //const turnText = currentPlayer.id === localPlayer.id ? "Your Turn" : `${currentPlayer.name}'s Turn`;
        gameInfo.textContent = `${turnText} (${currentPlayer.symbol})`;
    }
}


// ---------- CANVAS DRAWING & INTERACTION ---------- //
let viewport = {
    x: 0, y: 0, scale: 1,
    minScale: 0.2, maxScale: 5,
};
let panState = {
    isPanning: false,
    startX: 0, startY: 0,
};
let lastTap = 0;
let cellSize = 50;

let startTime = Date.now();



function hasMoveAt(x, y) {
  return Object.entries(gameState.lastMoves).some(([playerId, move]) => {
    if (playerId === localPlayer.id) return false; // ignore self
    return move.x === x && move.y === y;
  });
}


let lastTime = 0;
const fps = 60;
const frameDuration = 1000 / fps;

function gameLoop(timestamp) {
  if (timestamp - lastTime >= frameDuration) {
    lastTime = timestamp;
    draw();
  }
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);


function draw() {
    if (!gameState.gameStarted) return;
	
	const time = (Date.now() - startTime) / 1000; // seconds
	const pulse = 1 + 0.15 * Math.sin(time * 4);   // oscillates between 0.8–1.2
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(viewport.scale, viewport.scale);
    ctx.translate(viewport.x, viewport.y);

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    // Draw grid lines
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 1 / viewport.scale;

    for (let i = 0; i <= gameState.gridSize.x; i++) {
        ctx.beginPath();
        ctx.moveTo(offsetX + i * cellSize, offsetY);
        ctx.lineTo(offsetX + i * cellSize, offsetY + gridHeight);
        ctx.stroke();
    }
    for (let i = 0; i <= gameState.gridSize.y; i++) {
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY + i * cellSize);
        ctx.lineTo(offsetX + gridWidth, offsetY + i * cellSize);
        ctx.stroke();
    }
    
    // Draw symbols
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${cellSize * 0.7}px sans-serif`;
    
    for (let y = 0; y < gameState.gridSize.y; y++) {
        for (let x = 0; x < gameState.gridSize.x; x++) {
            if (gameState.grid[y] && gameState.grid[y][x]) {
                const symbol = gameState.grid[y][x];
                const playerIndex = gameState.players.findIndex(p => p.symbol === symbol);
				
                //ctx.fillStyle = playerIndex > -1 ? ('hsl(' + (playerIndex * 60) + ', 80%, 70%)') : 'white';
                //ctx.fillText(symbol, offsetX + x * cellSize + cellSize / 2, offsetY + y * cellSize + cellSize / 2);
				let baseSize = cellSize * 0.7;
				let fontSize = baseSize;

				// If this is the last move, apply pulse
				if (hasMoveAt(x, y)) {
				  fontSize = baseSize * pulse;
				}

				ctx.font = `${fontSize}px sans-serif`;

				// Draw symbol
				ctx.fillStyle = playerIndex > -1
				  ? `hsl(${playerIndex * 60}, 80%, 70%)`
				  : "white";

				ctx.fillText(
				  symbol,
				  offsetX + x * cellSize + cellSize / 2,
				  offsetY + y * cellSize + cellSize / 2
				);
            }
        }
    }
    
    // Draw winning line(s)
    if (gameState.gameOver && gameState.winLines) {
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
        ctx.lineWidth = 40;
        ctx.lineCap = 'round';
        
        gameState.winLines.forEach(line => {
            const startX = offsetX + line.start.x * cellSize + cellSize / 2;
            const startY = offsetY + line.start.y * cellSize + cellSize / 2;
            const endX = offsetX + line.end.x * cellSize + cellSize / 2;
            const endY = offsetY + line.end.y * cellSize + cellSize / 2;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        });
    }

    ctx.restore();
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (gameState.gameStarted) {
        draw();
    }
}

function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
    if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    }
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function getGridCoords(canvasX, canvasY) {
    // Inverse transform canvas coordinates to world coordinates
    const worldX = (canvasX - canvas.width / 2) / viewport.scale - viewport.x;
    const worldY = (canvasY - canvas.height / 2) / viewport.scale - viewport.y;

    const gridWidth = gameState.gridSize.x * cellSize;
    const gridHeight = gameState.gridSize.y * cellSize;
    const offsetX = -gridWidth / 2;
    const offsetY = -gridHeight / 2;

    const gridX = Math.floor((worldX - offsetX) / cellSize);
    const gridY = Math.floor((worldY - offsetY) / cellSize);

    return { x: gridX, y: gridY };
}


// Canvas event listeners
let panStart = { x: 0, y: 0 };
let isPanning = false;

function onPointerDown(e) {
    if (e.touches && e.touches.length > 1) return;
    isPanning = true;
    const pos = getTouchPos(e);
    panStart.x = pos.x - viewport.x * viewport.scale;
    panStart.y = pos.y - viewport.y * viewport.scale;
}

function onPointerMove(e) {
    if (!isPanning || (e.touches && e.touches.length > 1)) return;
    const pos = getTouchPos(e);
    viewport.x = (pos.x - panStart.x) / viewport.scale;
    viewport.y = (pos.y - panStart.y) / viewport.scale;
    //draw();
}

function onPointerUp(e) {
    isPanning = false;
    let currentTime = new Date().getTime();
    if (currentTime - lastTap < 300) {
       onDoubleClick(e);
    }
    lastTap = currentTime;
}

function onDoubleClick(e) {
    if (gameState.gameOver) return;
    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
    if (currentPlayer.id !== localPlayer.id) return;
	
	console.log("onDoubleClick");

    const pos = getTouchPos(e);
    const { x, y } = getGridCoords(pos.x, pos.y);

    if (x >= 0 && x < gameState.gridSize.x && y >= 0 && y < gameState.gridSize.y) {
        const move = { x, y, playerId: localPlayer.id };
        if (isHost) {
            handlePlayerMove(move);
        } else {
            sendToHost({ type: 'player_move', move });
        }
    }
}

let lastDist = 0;
function onTouchStart(e) {
    if (e.touches.length > 1) { 
        isPanning = false; 
        lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
    } else { 
        onPointerDown(e);
    }
}

function onTouchMove(e) {
    e.preventDefault();
    if (e.touches.length > 1) {
        const newDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
        const scaleFactor = newDist / lastDist;
        const newScale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
        viewport.scale = newScale;
        lastDist = newDist;
        //draw();
    } else {
        onPointerMove(e);
    }
}

canvas.addEventListener('touchstart', onTouchStart, { passive: false });
canvas.addEventListener('touchmove', onTouchMove, { passive: false });
canvas.addEventListener('touchend', onPointerUp);

canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
canvas.addEventListener('mouseup', onPointerUp);
canvas.addEventListener('mouseleave', () => isPanning = false);
canvas.addEventListener('dblclick', onDoubleClick);

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    viewport.scale = Math.min(viewport.maxScale, Math.max(viewport.minScale, viewport.scale * scaleFactor));
    //draw();
}, { passive: false });


// ---------- INITIALIZATION ---------- //
hostBtn.addEventListener('click', hostGame);
joinBtn.addEventListener('click', joinGame);
startGameBtn.addEventListener('click', startGame);
//changeSymbolBtn.addEventListener('click', attemptSetSymbol);
window.addEventListener('resize', resizeCanvas);

customSymbolInput.addEventListener('input', attemptSetSymbol);

</script>
</body>
</html>