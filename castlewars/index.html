<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Castle Wars</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
	
	<!-- 
	TODO:
	- when killing enemy unit by adding new soldier on top of it, and then undoing, it will not give the land of enemy back to him.
	- when player left the room (disconnect), it shouldnt be shown in the list anymore. so disconnect set quitted true and filter quitted plyers from list.
	- show protected radiuses of units with white edges.
	- load game doesnt work for interrupted game. perhaps save doesnt work?
	- moving an unit gives instantly the income from your pool??? some crazy math there, gives more than 1 per tile.
	- undoing move doesnt update the possible tiles where you can move if the unit is still selected.
	- undoing fucks up the savings when moving to tile where not moved before. if i move again on same tile i moved on same turn after undo, it doesnt reduce savings anymore from that undo.
	- draw move ranges with outlines only?
	- new soldier placement doesnt remove tree (and probably not grass either)
	- add sell possibility.
	- make move sounds happen even when doesnt claim land. also add start / end move sounds.
	- add new unit as ghosted when placing it.
	- highlight possible areas where you can place new or old unit.
	- add protect sounds when unit cannot move due to higher level unit.
	- allow placing new higher level unit on top of lower level unit and kill it.
	- add map loader from original game maps. show preview of each map in selector list.

	- useimages = 1, for rendering textures. check if its much slower than without. check if their render makes any sense or is it doing useless things.

	- dont allow moving castles lol XD

	- allow selecting enemy pools as well. (with red edges).
	- dont close soldier add popup if the move was invalid, just play invalid move sound.
	
	-->
    
    <style>
        /* --- GLOBAL STYLES --- */
        :root {
            --bg-color: #1a1a1a;
            --text-color: #eee;
            --primary-color: #0a84ff;
            --border-color: #444;
            --input-bg: #2c2c2e;
            --btn-bg: #3a3a3c;
            --btn-hover-bg: #4a4a4c;
            --danger-color: #ff3b30;
            --warn-color: #ffcc00;
            --spec-color: #ffffff;
            --unclaimed-color: #555;
            --water-color: #003366;
            --land-color: #224422;
        }

        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .page {
            display: none;
            width: 100%;
            height: 100%;
            padding: 20px;
            overflow-y: auto;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .page.active {
            display: flex;
        }

        .container {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            background: #222;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        h1, h2, h3 {
            margin-top: 0;
            text-align: center;
            font-weight: 500;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 6px;
            font-size: 16px;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: var(--btn-bg);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
		
		.gamebutton {
		    padding:4px;
			font-size: 12px;
		}

        button:hover {
            background: var(--btn-hover-bg);
        }

        button:active {
            transform: scale(0.98);
        }
        
        button.primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        button.primary:hover {
            background-color: #007aff;
        }
        
        button.danger {
            background-color: var(--danger-color);
            color: white;
        }
        
        button.toggle-btn.active {
            background-color: var(--warn-color);
            color: #000;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .input-group > div {
            flex: 1;
        }
        
        .player-list {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border-radius: 6px;
            min-height: 100px;
            margin-top: 15px;
        }
        
        .player-list-item {
            padding: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .player-list-item:last-child {
            border-bottom: none;
        }
        
        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        
        .color-box.selected {
            border-color: white;
            box-shadow: 0 0 8px white;
        }
        
        .color-box.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .loaded-game-info {
            font-size: 14px;
            background: var(--input-bg);
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .loaded-player {
            cursor: pointer;
        }
        .loaded-player:hover {
            text-decoration: underline;
        }
        .loaded-player.taken {
            cursor: not-allowed;
            opacity: 0.5;
            text-decoration: line-through;
        }

        /* --- GAME PAGE --- */
        #game-page {
            padding: 0;
            margin: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0px;
        }
        
        .ui-panel {
            pointer-events: auto;
            background: rgba(34, 34, 34, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
			padding: 2px 6px 2px 6px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #ui-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px;
        }

		#ui-right {
			display: flex;
			flex-direction: column; /* stack rows vertically */
			---gap: 10px;
			width:500px;
			height: 96px; /* let it grow naturally */
			
			overflow-y: hidden;
			
			border-bottom-left-radius: 8px;
		}

		/* Top row: texts side by side */
		#ui-right .top-row {
			display: flex;
			flex-direction: row;
			justify-content: space-between; /* turn-info left, savings right */
			align-items: center;
			gap: 10px;
		}

		/* Optional: style buttons as a row */
		#ui-right .button-row {
			display: flex;
			flex-direction: row;
			gap: 10px;
		}

		/* Make buttons stretch evenly */
		#ui-right .button-row button {
			flex: 1;  /* each button takes equal width */
		}

		#player-ui-list {
			border-bottom-right-radius: 8px;
		}
		
        #player-ui-list .player-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .player-turn-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--warn-color);
            margin-right: 5px;
            visibility: hidden;
        }
        
        .player-list-item.current-turn .player-turn-indicator {
            visibility: visible;
        }
        
        #chat-ui {
            display: flex;
            flex-direction: column;
            height: 200px;
			
			border-top-right-radius: 8px;
			border-bottom-right-radius: 8px;
			
			padding-left: 4px;
        }
        
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            font-size: 13px;
            padding: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            margin-bottom: 5px;
			margin-top: 3px;
        }
        
        #chat-input {
            width: 100%;
            padding: 8px;
            font-size: 14px;
			margin-bottom: 4px;
        }
        
        #build-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            pointer-events: auto;
            width: 300px;
        }
        
        .build-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: var(--btn-bg);
            border-radius: 4px;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        .build-item:hover {
            background: var(--btn-hover-bg);
        }
        
        .build-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            background: #222;
        }
        
        .build-item .cost {
            color: var(--warn-color);
        }

    </style>
</head>
<body>

<div id="start-page" class="page active">
	<div class="container">
		<h1>Castle Wars</h1>
		<label for="player-name">Player Name</label>
		<input type="text" id="player-name" value="Player">
		
		<label for="room-name">Game Room Name</label>
		<input type="text" id="room-name" value="default-room">
		
		<button id="host-btn" class="primary">Host Game</button>
		<button id="join-btn">Join Game</button>
		<button id="spectate-btn">Join as Spectator</button>
		<div id="connection-status" style="text-align: center; margin-top: 10px; font-size: 14px;">Initializing...</div>
	</div>
</div>

<div id="host-page" class="page">
	<div class="container">
		<h2 id="host-room-name-title">Hosting: default-room</h2>
		
		<div class="input-group">
			<div>
				<label for="map-width">Map Width</label>
				<input type="number" id="map-width" value="24">
			</div>
			<div>
				<label for="map-height">Map Height</label>
				<input type="number" id="map-height" value="24">
			</div>
		</div>
		
		<label for="start-money">Starting Money</label>
		<input type="number" id="start-money" value="1000">

		<div class="input-group">
			<button id="add-ai-btn" style="flex: 2;">Add AI (Hardness: 1)</button>
			<button id="spectate-host-btn" class="toggle-btn" style="flex: 1;">Spectate</button>
		</div>
		
		<button id="load-game-btn">Load Game</button>
		<div id="loaded-game-info-container" class="loaded-game-info" style="display: none;">
			<p><strong>Saved Game:</strong> <span id="load-game-date"></span></p>
			<p><strong>Players:</strong></p>
			<ul id="load-game-players"></ul>
		</div>
		
		<button id="start-game-btn" class="primary">Start Game</button>
		
		<h3>Joined Players:</h3>
		<div id="host-player-list" class="player-list"></div>
	</div>
</div>

<div id="lobby-page" class="page">
	<div class="container">
		<h2 id="lobby-room-name-title">Joining: default-room</h2>
		
		<div id="lobby-game-settings">
			<p><strong>Map:</strong> <span id="lobby-map-size">...</span></p>
			<p><strong>Money:</strong> <span id="lobby-start-money">...</span></p>
		</div>
		
		<label for="lobby-player-name">Your Name</label>
		<input type="text" id="lobby-player-name" value="Player">
		
		<label>Choose Color</label>
		<div id="lobby-color-picker" class="color-picker"></div>
		
		<h3>Joined Players:</h3>
		<div id="lobby-player-list" class="player-list"></div>
		
		<p id="lobby-status" style="text-align: center;">Waiting for host to start...</p>
	</div>
</div>

<div id="game-page" class="page">
	<canvas id="game-canvas"></canvas>
	
	<div id="game-ui">
		<div id="ui-left">
			<div id="player-ui-list" class="ui-panel">
				</div>
			<div id="chat-ui" class="ui-panel">
				<div id="chat-messages"></div>
				<input type="text" id="chat-input" placeholder="Type message..." disabled>
			</div>
		</div>
		
		<div id="ui-right" class="ui-panel">
			<div class="top-row">
				<h3 id="turn-info">Turn 1</h3>
				<div id="player-savings">Savings: 0 G</div>
			</div>
			<div class="button-row">
				<button id="build-soldier-btn" class="gamebutton">Soldier</button>
				<button id="build-castle-btn" class="gamebutton">Castle</button>
				<button id="end-turn-btn" class="gamebutton primary">End<br>Turn</button>
				<button id="undo-btn" class="gamebutton">Undo</button>
			</div>
		</div>
	</div>
	
	<div id="build-popup" class="ui-panel" style="display: none;">
		<h3 id="build-popup-title">Build</h3>
		<div id="build-popup-list">
			</div>
		<button id="build-popup-close" style="margin-top: 10px;">Cancel</button>
	</div>
	
</div>

<script>
let useimages = 1;
let GS = 1.16; // hex texture size multi

const MIN_ZOOM = 0.02; // smaller value = more zoomed out
const MAX_ZOOM = 20;   // bigger value = more zoomed in

let bgImage = new Image();
let bgPattern = null;

bgImage.src = 'images/water.jpg';
bgImage.onload = () => {
	bgPattern = ctx.createPattern(bgImage, 'repeat');
	//draw(); // optional initial draw
};

function hexToHSL(hex) {
  // Remove '#' if present
  hex = hex.replace(/^#/, '');

  // Parse r, g, b values
  let bigint = parseInt(hex, 16);
  let r = (bigint >> 16) & 255;
  let g = (bigint >> 8) & 255;
  let b = bigint & 255;

  // Convert RGB to 0..1
  r /= 255;
  g /= 255;
  b /= 255;

  let max = Math.max(r, g, b);
  let min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
	h = s = 0; // achromatic
  } else {
	let d = max - min;
	s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	switch (max) {
	  case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	  case g: h = (b - r) / d + 2; break;
	  case b: h = (r - g) / d + 4; break;
	}
	h /= 6;
  }

  return {
	h: Math.round(h * 360), // 0 - 360 degrees
	s: parseFloat(s.toFixed(3)), // 0 - 1
	l: parseFloat(l.toFixed(3))  // 0 - 1
  };
}


let gameRules = {
	tileIncome: 1,
};
// sounds =
let gameSounds = {
	moveunit:{filename: "sounds/down.mp3",    gain: 1,   filter: false},
	starmove:{filename: "sounds/up.mp3",      gain: 1,   filter: false},
	info:    {filename: "sounds/info.mp3",    gain: 1,   filter: false},
	kill:    {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	destroy: {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	move:    {filename: "sounds/move.mp3",    gain: 1,   filter: false},
	protect: {filename: "sounds/protect.mp3", gain: 1,   filter: false},
	sea:     {filename: "sounds/sea.mp3",     gain: 1,   filter: false},
};

// Preload all sounds
for (const key in gameSounds) {
	loadSound(gameSounds[key].filename); // call your loadSound function for each file
}


const context = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds

function loadSound(src) {
  return fetch(src)
	.then(res => res.arrayBuffer())
	.then(data => context.decodeAudioData(data))
	.then(decoded => {
	  soundBuffers[src] = decoded; // store buffer by filename
	  return decoded; // also return it
	});
}




function playSound(src) {
	let sound = gameSounds[src];
	if(!sound){
		console.warn("sound not found: "+src);
		return;
	}
	console.warn("playSound: "+src);
	
	const buffer = soundBuffers[sound.filename];
	if (!buffer) return; // sound not loaded yet

	const source = context.createBufferSource();
	source.buffer = buffer;

	// Create a gain node for volume control
	const gainNode = context.createGain();
	gainNode.gain.value = sound.gain; // 1.0 = 100%, 0.5 = 50%, etc.

	if (sound.filter) {
		// Create and use filter
		const filter = context.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = 3000; // let only frequencies below ~3kHz pass

		source.connect(filter);
		filter.connect(gainNode);
	} else {
		// Connect directly
		source.connect(gainNode);
	}

	gainNode.connect(context.destination);
	source.start();
}


// --- Prevent default touch behavior for scrolling/zooming ---
document.body.addEventListener('touchstart', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });
document.body.addEventListener('touchmove', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });
document.body.addEventListener('touchend', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });

// --- CONSTANTS ---
const DB_NAME = 'HexWarlordsDB';
const DB_STORE_NAME = 'savedGames';
const PLAYER_COLORS = [
	'#FF3B30', '#FF9500', '#FFCC00', '#34C759', '#00C7BE', '#30B0C7', 
	'#32ADE6', '#007AFF', '#5856D6', '#AF52DE', '#FF2D55', '#A2845E'
];
const SPECTATOR_COLOR = '#FFFFFF';
const UNCLAIMED_COLOR = '#555555';
const WATER_COLOR = '#003366';
const LAND_COLOR = '#224422'; // Unclaimed land
const HEX_SIZE = 40; // Radius of hexagon
const SQRT3 = Math.sqrt(3);

// soldiers =
const SOLDIER_DATA = {
	"Peasant":  { name: "Peasant",  type:"soldier", level: 1, cost: 10, wage: 3, sell: 5, prefix: 'P' },
	"Knight":   { name: "Knight",   type:"soldier", level: 2, cost: 20, wage: 8, sell: 10, prefix: 'K' },
	"Horse":    { name: "Horse",    type:"soldier", level: 3, cost: 30, wage: 18, sell: 15, prefix: 'H' },
	"Dragon":   { name: "Dragon",   type:"soldier", level: 4, cost: 40, wage: 54, sell: 20, prefix: 'D' },
};
// cross becomes grass in... 4 turns
//grass Â´grows 1-3 pieces per turn, chance is 50 for one piece?
// trees grow more the more land there is, i think max is 2 per turn.

// castles =
const CASTLE_DATA = {
	"Hut":      { name: "Hut",      type:"castle", level: 1, cost: 10, prefix: 'h' },
	"Castle":   { name: "Castle",   type:"castle", level: 2, cost: 40, prefix: 'C' },
	"Fortress": { name: "Fortress", type:"castle", level: 3, cost: 200, prefix: 'F' },
};

// --- GLOBAL STATE ---
let peer = null;
let myPeerId = null;
let hostPeerId = null;
let connections = new Map(); // key: peerId, value: DataConnection
let localPlayer = {
	id: null,
	name: 'Player',
	color: PLAYER_COLORS[0],
	isSpectator: false,
	isHost: false
};
let db = null;
let loadedGameState = null;

// --- GAME STATE (synced by host) ---
let GAME_STATE = {
	gameStarted: false,
	settings: {
		mapWidth: 50,
		mapHeight: 50,
		startingMoney: 1000, // default 0 actually. for testing 1000.
		roomName: 'default-room'
	},
	players: [], // { id, name, color, isSpectator, isAI }
	map: { // Using axial coordinates (q, r)
		// tiles[q][r] = { type: 'land'/'water', ownerId: null, object: 'tree'/'grass'/null, savings: 0 }
		tiles: {}, 
	},
	units: [], // { id, type: 'Peasant', ownerId, level, q, r, hasMoved }
	turn: {
		currentPlayerIndex: 0,
		turnNumber: 1
	},
	// Economy pools are calculated, not stored directly
};

// --- CLIENT-SIDE STATE (not synced) ---
let canvas, ctx;
let viewport = { x: 0, y: 0, zoom: 1 };
let dragStart = null;
let isDragging = false;
let selectedHex = null; // {q, r}
let selectedUnit = null;
let placingUnit = null; // e.g., { type: 'Peasant', cost: 100 }
let currentTurnActions = []; // For undo

let shakingUnits = []; // { id, endTime }
let highlightedPool = []; // [{q, r}] for highlighting connected hexes
let validMoveHexes = []; // [{q, r}] for green move highlight
let invalidMoveHexes = []; // [{q, r}] for red move highlight
let myCurrentSavings = 0; // Client-side savings

// --- IMAGE CACHING ---
let imageCache = {};
let imageAssets;


function buildImageName(unitData){
	return `${unitData.type}${unitData.level}`; // soldier1
}

function getImagePath(unitData){
	return imageAssets[buildImageName(unitData)].path;
}

let use_orig = 1;

// images =
if(use_orig){
	imageAssets = {
		'land': {path:'images/land2.jpg', scale:1, offsetX: 0}, 
		'dirt': {path:'images/dirt2.jpg', scale:1, offsetX: 0},
		'water': {path:'images/water.jpg', scale:1, offsetX: 0},
		'dead': {path:'images/orig-scaled/dead.png', scale:1, offsetX: 0},
		'grass': {path:'images/orig-scaled/grass.png', scale:2, offsetX: 3, offsetY: 5},
		'tree': {path:'images/orig-scaled/tree.png', scale:2, offsetX: 2, offsetY: 5},
		'protect': {path:'images/orig-scaled/protect.png', scale:1, offsetX: 0},
		'select': {path:'images/orig-scaled/select.png', scale:1, offsetX: 0},
		'castle1': {path:'images/orig-scaled/castle1.png', scale:1.8, offsetX: 0},
		'castle2': {path:'images/orig-scaled/castle2.png', scale:1.8, offsetX: 0},
		'castle3': {path:'images/orig-scaled/castle3.png', scale:1.8, offsetX: 0},
		'soldier1': {path:'images/orig-scaled/soldier1.png', scale:1.8, offsetX: 0},
		'soldier2': {path:'images/orig-scaled/soldier2.png', scale:1.8, offsetX: 0},
		'soldier3': {path:'images/orig-scaled/soldier3.png', scale:1.8, offsetX: 0},
		'soldier4': {path:'images/orig-scaled/soldier4.png', scale:1.8, offsetX: 0, offsetY: 3},
	};
}else{
	imageAssets = {
		'land': {path:'images/land2.jpg', scale:1, offsetX: 0}, 
		'dirt': {path:'images/dirt2.jpg', scale:1, offsetX: 0},
		'water': {path:'images/water.jpg', scale:1, offsetX: 0},
		'dead': {path:'images/orig-scaled/dead.png', scale:1, offsetX: 0},
		'grass': {path:'images/orig-scaled/grass.png', scale:1, offsetX: 0},
		'tree': {path:'images/orig-scaled/tree.png', scale:1, offsetX: 0},
		'protect': {path:'images/orig-scaled/protect.png', scale:1, offsetX: 0},
		'select': {path:'images/orig-scaled/select.png', scale:1, offsetX: 0},
		'castle1': {path:'images/castle1.png', scale:0.7, offsetX: 0},
		'castle2': {path:'images/castle2.png', scale:1, offsetX: 0},
		'castle3': {path:'images/castle3.png', scale:1, offsetX: 0},
		'soldier1': {path:'images/soldier1.png', scale:1, offsetX: -5},
		'soldier2': {path:'images/soldier2.png', scale:1, offsetX: 0},
		'soldier3': {path:'images/soldier3.png', scale:1, offsetX: 5},
		'soldier4': {path:'images/soldier4.png', scale:1, offsetX: 0},
	};
}


// --- NEW FUNCTION: To load all images from imageAssets
function loadImages() {
	for (const [key, obj] of Object.entries(imageAssets)) {
		const img = new Image();
		img.src = obj.path;
		imageCache[key] = img;
		img.onload = () => {
			console.log(`Image loaded: ${key} from ${obj.path}`);
		}
		img.onerror = () => {
			console.error(`Failed to load image: ${obj.path}`);
		}
	}
}

// --- NEW FUNCTION: To get a loaded image from the cache
function getImage(key) {
	return imageCache[key];
}

function getImageSettings(key){
	return imageAssets[key];
}

// --- DOM ELEMENTS ---
const pages = {
	start: document.getElementById('start-page'),
	host: document.getElementById('host-page'),
	lobby: document.getElementById('lobby-page'),
	game: document.getElementById('game-page'),
};
const playerNameInput = document.getElementById('player-name');
const roomNameInput = document.getElementById('room-name');
const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const spectateBtn = document.getElementById('spectate-btn');
const connectionStatus = document.getElementById('connection-status');

// Host Page
const hostRoomNameTitle = document.getElementById('host-room-name-title');
const mapWidthInput = document.getElementById('map-width');
const mapHeightInput = document.getElementById('map-height');
const startMoneyInput = document.getElementById('start-money');
const addAiBtn = document.getElementById('add-ai-btn');
const spectateHostBtn = document.getElementById('spectate-host-btn');
const loadGameBtn = document.getElementById('load-game-btn');
const loadedGameInfoContainer = document.getElementById('loaded-game-info-container');
const loadGameDate = document.getElementById('load-game-date');
const loadGamePlayersList = document.getElementById('load-game-players');
const startGameBtn = document.getElementById('start-game-btn');
const hostPlayerList = document.getElementById('host-player-list');

// Lobby Page
const lobbyRoomNameTitle = document.getElementById('lobby-room-name-title');
const lobbyMapSize = document.getElementById('lobby-map-size');
const lobbyStartMoney = document.getElementById('lobby-start-money');
const lobbyPlayerNameInput = document.getElementById('lobby-player-name');
const lobbyColorPicker = document.getElementById('lobby-color-picker');
const lobbyPlayerList = document.getElementById('lobby-player-list');
const lobbyStatus = document.getElementById('lobby-status');

// Game Page
canvas = document.getElementById('game-canvas');
ctx = canvas.getContext('2d');
const playerUIList = document.getElementById('player-ui-list');
const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const turnInfo = document.getElementById('turn-info');
const playerSavings = document.getElementById('player-savings');
const buildSoldierBtn = document.getElementById('build-soldier-btn');
const buildCastleBtn = document.getElementById('build-castle-btn');
const endTurnBtn = document.getElementById('end-turn-btn');
const undoBtn = document.getElementById('undo-btn');
const buildPopup = document.getElementById('build-popup');
const buildPopupTitle = document.getElementById('build-popup-title');
const buildPopupList = document.getElementById('build-popup-list');
const buildPopupClose = document.getElementById('build-popup-close');


const uiRight = document.getElementById('ui-right');

// =================================================================
// --- UTILITY FUNCTIONS
// =================================================================

function showPage(pageId) {
	Object.values(pages).forEach(page => page.classList.remove('active'));
	if (pages[pageId]) {
		pages[pageId].classList.add('active');
	}
	if (pageId === 'game') {
		initCanvas();
		render();
	}
}



function sendToPlayer(playerId, data) {
	if (!localPlayer.isHost) return;
	
	if (playerId === localPlayer.id) {
		// It's the host, handle directly
		handleHostData(data);
	} else if (connections.has(playerId)) {
		connections.get(playerId).send(data);
	}
}

function sendToHost(data) {
	if (localPlayer.isHost) {
		// Host handles its own actions directly
		handleClientData(localPlayer.id, data);
	} else if (hostPeerId && connections.has(hostPeerId)) {
		connections.get(hostPeerId).send(data);
	}
}

function broadcast(data) {
	if (!localPlayer.isHost) return;
	// Send to all connected clients
	for (const [peerId, conn] of connections.entries()) {
		conn.send(data);
	}
	// Host handles its own data
	handleHostData(data);
}

function addChatMessage(from, message, color = '#FFF') {
	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};" class="msgfromtext"></strong><span class="msgtext"></span>`;
	
	const safeMsgFrom = document.createTextNode(`${from}:`);
	const safeMsg = document.createTextNode(` ${message}`);
	item.querySelector(".msgfromtext").appendChild(safeMsgFrom);
	item.querySelector(".msgtext").appendChild(safeMsg);

	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
}
		/*
    playerList.innerHTML = '';
    gameState.players.forEach((p, playerIndex) => {
        const li = document.createElement('li');
        const displayName = p.isSpec ? `${p.name} (Spectator)` : p.name;
		const safeName = document.createTextNode(displayName);
		li.innerHTML = `<span style="color:${p.colors.color}"></span>`;
		li.querySelector("span").appendChild(safeName);
        playerList.appendChild(li);
    });
	*/
function addSystemChatMessage(message, color = '#FFF') {
	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};">${message}</strong>`;
	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
}

function getUID() {
	return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function getPlayer(playerId) {
	return GAME_STATE.players.find(p => p.id === playerId);
}

function getMyPlayer() {
	return getPlayer(localPlayer.id);
}

// =================================================================
// --- HEXAGON MATH
// (Using "pointy top" axial coordinates)
// =================================================================

function axialToPixel(q, r) {
	const x = HEX_SIZE * (3/2 * q);
	const y = HEX_SIZE * (SQRT3/2 * q + SQRT3 * r);
	return { x, y };
}

function pixelToAxial(x, y) {
	// Apply viewport inverse transform
	const viewX = (x - viewport.x) / viewport.zoom;
	const viewY = (y - viewport.y) / viewport.zoom;
	
	const q = (2/3 * viewX) / HEX_SIZE;
	const r = (-1/3 * viewX + SQRT3/3 * viewY) / HEX_SIZE;
	return hexRound(q, r);
}

function hexRound(q, r) {
	const s = -q - r;
	let rq = Math.round(q);
	let rr = Math.round(r);
	let rs = Math.round(s);

	const q_diff = Math.abs(rq - q);
	const r_diff = Math.abs(rr - r);
	const s_diff = Math.abs(rs - s);

	if (q_diff > r_diff && q_diff > s_diff) {
		rq = -rr - rs;
	} else if (r_diff > s_diff) {
		rr = -rq - rs;
	}
	// `rs` is derived, so we just return `rq` and `rr`
	return { q: rq, r: rr };
}

function getHexNeighbors(q, r) {
	return [
		{ q: q + 1, r: r },     // bottom right 0
		{ q: q + 1, r: r - 1 }, // top right    1
		{ q: q,     r: r - 1 }, // top          2
		{ q: q - 1, r: r },     // top left     3
		{ q: q - 1, r: r + 1 }, // bottom left  4
		{ q: q,     r: r + 1 }, // bottom       5
	];
}

function getHexDistance(q1, r1, q2, r2) {
	const dq = q1 - q2;
	const dr = r1 - r2;
	const ds = (-q1 - r1) - (-q2 - r2);
	return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
}

// =================================================================
// --- CANVAS RENDERING
// =================================================================

function initCanvas() {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	
	// Center map initially
	const centerQ = Math.floor(GAME_STATE.settings.mapWidth / 2);
	const centerR = Math.floor(GAME_STATE.settings.mapHeight / 2);
	// This axial coordinate isn't the *center* of a rectangular map,
	// but it's good enough for a starting point.
	// A true center for an odd-q vertical layout is more complex.
	// Let's just center on 0,0.
	const centerPx = axialToPixel(0, 0); 
	viewport.x = canvas.width / 2 - centerPx.x;
	viewport.y = canvas.height / 2 - centerPx.y;
}



function getHexAnglePos(i, px, py){
	const angle = 2 * Math.PI / 6 * (i + 0.5); // +0.5 for pointy top
	const x = px + HEX_SIZE * Math.cos(angle+Math.PI/2);
	const y = py + HEX_SIZE * Math.sin(angle+Math.PI/2);
	return {x, y};
}


function drawHexLine(i, px, py){
	let p1 = getHexAnglePos(i, px, py);
	let p2 = getHexAnglePos(i+1, px, py);
	ctx.moveTo(p1.x, p1.y);
	ctx.lineTo(p2.x, p2.y);
}

// drawLines = array of values 0-5
// 0 = bottom left
// 1 = top left
// 2 = Top
// 3 = top right
// 4 = bottom right
// 5 = bottom
function drawHexagonPath(px, py, drawLines = null) {
	const neighToi = [4, 3, 2, 1, 0, 5]; // convert getHexNeighbors indexes to i multiplier value for calculations of angles.
	if(drawLines){
		if(drawLines.length > 0){
			ctx.beginPath();
			for(let i = 0; i < drawLines.length; i++){
				let ival = neighToi[drawLines[i]];
				// for 3d effect for map:
				//if(ival > 0 && ival < 4 ){
				//	continue;
				//}
				drawHexLine(ival, px, py);
			}
			ctx.closePath();
		}
	}else{
		ctx.beginPath();
		for (let i = 0; i < 6; i++) {
			const angle = 2 * Math.PI / 6 * (i + 0.5); // +0.5 for pointy top
			const x = px + HEX_SIZE * Math.cos(angle+Math.PI/2);
			const y = py + HEX_SIZE * Math.sin(angle+Math.PI/2);
			if(i === 0){
				ctx.moveTo(x, y);
			}else{
				ctx.lineTo(x, y);
			}
		}
		ctx.closePath();
	}
}


function drawHexagonOutlines(q, r, myId = -1){
	let highlightedLines = [];
	const { x, y } = axialToPixel(q, r);
	
	let hexNeigh = getHexNeighbors(q, r);

	for(let i = 0; i < hexNeigh.length; i++){
		let hexCoord = hexNeigh[i];
		let nTile = getTileAt(hexCoord.q, hexCoord.r);
		if(nTile && nTile.ownerId != myId){
			highlightedLines.push(i);
		}
		// if neighbour tile is out of bounds:
		if(!nTile){
			highlightedLines.push(i);
		}
	}
	drawHexagonPath(x, y, highlightedLines);
}


// renderinfinitewater
let drawInfiniteWater = 1;

function render() {
	if (!GAME_STATE.gameStarted) return;
	
	//ctx.fillStyle = '#000'; // Clear with black
	//ctx.fillRect(0, 0, canvas.width, canvas.height);
	
	
	// draw background pattern always:
	//ctx.fillStyle = bgPattern;
	//ctx.fillRect(0, 0, canvas.width, canvas.height);


   // ctx.save();
   // ctx.translate(viewport.x, viewport.y);
   // ctx.scale(viewport.zoom, viewport.zoom);
   
   

	// Save the context state
	ctx.save();
	if(drawInfiniteWater){
		// ---- STEP 1: Create or reuse pattern ----
		// (You can create bgPattern once outside render to avoid recreating every frame)
		const pattern = bgPattern; // your ctx.createPattern(waterImage, 'repeat');

		// ---- STEP 2: Apply transform to pattern ----
		const matrix = new DOMMatrix()
			.translate(viewport.x, viewport.y) // inverse of camera movement
			.scale(viewport.zoom*0.4);         // scale with zoom

		pattern.setTransform(matrix);

		// ---- STEP 3: Draw the pattern ----
	
		ctx.fillStyle = pattern;
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}else{
		
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}

	// ---- STEP 4: Now apply your world transform ----
	ctx.translate(viewport.x, viewport.y);
	ctx.scale(viewport.zoom, viewport.zoom);
	
	// --- CULLING (existing code) ---
	const topLeft = pixelToAxial(0, 0);
	const bottomRight = pixelToAxial(canvas.width, canvas.height);
	const qMin = topLeft.q - 2;
	const qMax = bottomRight.q + 2;
	const rMin = topLeft.r - (bottomRight.q - topLeft.q) - 2; 
	const rMax = bottomRight.r + (bottomRight.q - topLeft.q) + 2;

	// --- DRAW TILES ---
	// --- DRAW TILES ---
	for (let r = rMin; r <= rMax; r++) {
		for (let q = qMin; q <= qMax; q++) {
			const tile = getTileAt(q, r);
			if (!tile) continue; // Out of map bounds

			const { x, y } = axialToPixel(q, r);

			// --- Culling Check ---
			const screenX = x * viewport.zoom + viewport.x;
			const screenY = y * viewport.zoom + viewport.y;
			if (screenX < -HEX_SIZE * viewport.zoom || screenX > canvas.width + HEX_SIZE * viewport.zoom ||
				screenY < -HEX_SIZE * viewport.zoom || screenY > canvas.height + HEX_SIZE * viewport.zoom) {
				continue;
			}
			
			if (tile.type === 'water') {
				if(drawInfiniteWater){
					continue; // skip water tiles.
				}
			}

			// --- Start Drawing Hex ---
			
			ctx.save();
			
			// 1. Define the hex path
			drawHexagonPath(x, y);

			// 2. Draw the fallback background color (or owner color)
			let fallbackColor = LAND_COLOR;
			if (tile.type === 'water') {
				fallbackColor = WATER_COLOR;
			} else if (tile.ownerId) {
				const owner = getPlayer(tile.ownerId);
				fallbackColor = owner ? owner.color : LAND_COLOR;
			} else if (tile.type === 'land') {
				fallbackColor = LAND_COLOR;
			}
			ctx.fillStyle = fallbackColor;
			ctx.fill();
			
			
			if(useimages){
				// 3. Get the background image for this tile type
				// (We assume the image key is the same as tile.type)
				let img = null;
				if(tile.ownerId){
					img = getImage(tile.type);
				}else{
					// no owner, use dirt image:
					if(tile.type === 'water') {
						img = getImage("water");
					}else{
						img = getImage("dirt");
					}
				}

				// 4. If image is loaded, draw it clipped and scaled
				if (img && img.complete && img.width > 0) {
					ctx.clip(); // Apply clip to the hex path

					// Calculate the "pointy-top" hex bounding box
					const hexWidth = HEX_SIZE * SQRT3*GS;
					const hexHeight = HEX_SIZE * 2;
					
					// Calculate "scale-to-fit" (contain) ratio
					const ratio = Math.min(hexWidth / img.width, hexHeight / img.height);
					const dWidth = img.width * ratio;
					const dHeight = img.height * ratio;
					
					// Calculate centered destination (dx, dy)
					const dx = x - dWidth / 2;
					const dy = y - dHeight / 2;
					
					// Draw the image centered and scaled
					//ctx.drawImage(img, dx, dy, dWidth, dHeight);


					if(tile.ownerId){
					
						const player = getPlayer(tile.ownerId);
						
						// Draw the gray texture
						ctx.drawImage(img, dx, dy, dWidth, dHeight);

						// todo: make own images for each player texture.
						// Multiply by player color
						ctx.globalCompositeOperation = "multiply";
						ctx.fillStyle = player.color; // e.g. "#ff0000"
						ctx.fillRect(dx, dy, dWidth, dHeight);
						ctx.globalCompositeOperation = "source-over";
						
						/*
						const player = getPlayer(tile.ownerId);
						let hsl = hexToHSL(player.color);

						ctx.filter = `hue-rotate(${hsl.h}deg) saturate(${hsl.s}) brightness(${hsl.l})`;
						ctx.drawImage(img, dx, dy, dWidth, dHeight);
						ctx.filter = 'none'; // always reset after
						*/
					}else{
						// Draw the original image
						ctx.drawImage(img, dx, dy, dWidth, dHeight);
					}

/*
					if (unit.hasMoved) {
						ctx.globalCompositeOperation = 'multiply';
					}
					ctx.drawImage(img, dx, dy, dWidth, dHeight);

					if (unit.hasMoved) {
						ctx.globalCompositeOperation = 'source-over';// always reset after
					}*/
				}
				
			}
			// 5. Restore context (removes clip)
			ctx.restore();
			
			// 6. Draw objects (Trees/Grass) on top
			// (This code is moved from its old location)
			if (tile.object === 'tree') {
				let imageKey = tile.object;
				const img = getImage(imageKey);
				
				if (img && img.complete && img.width > 0) {
					// Draw the image centered and scaled
					let imginfo = getImageSettings(imageKey);
					let scale = imginfo.scale*0.9; // 0.9 global scale
					let ratio = img.height/img.width;
					let drawSize = 50;
					let hsize = drawSize/2;
					let offsetX = imginfo.offsetX;
					let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
					let dx = x-((hsize-offsetX)*scale);
					let dy = y-((hsize-offsetY+10)*ratio*scale);
					let dw = drawSize*scale;
					let dh = drawSize*ratio*scale;
					
					ctx.drawImage(img, dx, dy, dw, dh);
				}
					
					
				/*ctx.fillStyle = 'green';
				ctx.font = `${HEX_SIZE * 0.8}px sans-serif`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText('ðŸŒ³', x, y);*/
			} else if (tile.object === 'grass') {
				let imageKey = tile.object;
				const img = getImage(imageKey);
				
				if (img && img.complete && img.width > 0) {
					// Draw the image centered and scaled
					let imginfo = getImageSettings(imageKey);
					let scale = imginfo.scale*0.9; // 0.9 global scale
					let ratio = img.height/img.width;
					let drawSize = 50;
					let hsize = drawSize/2;
					let offsetX = imginfo.offsetX;
					let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
					let dx = x-((hsize-offsetX)*scale);
					let dy = y-((hsize-offsetY+10)*ratio*scale);
					let dw = drawSize*scale;
					let dh = drawSize*ratio*scale;
					
					ctx.drawImage(img, dx, dy, dw, dh);
				}
				/*ctx.fillStyle = '#7CFC00';
				ctx.font = `${HEX_SIZE * 0.8}px sans-serif`;
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				ctx.fillText('ðŸŒ¾', x, y);
				*/
			}
		}
	}
	
	// --- DRAW HIGHLIGHTS (NEW) ---
	
	// Draw selected pool
	for (const hex of highlightedPool) {
		drawHexagonOutlines(hex.q, hex.r, localPlayer.id);
		ctx.strokeStyle = 'rgba(255,255,0,0.7)';
		ctx.lineWidth = 3;
		ctx.stroke();
	}
	
	// Draw movement range
	ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
	for (const hex of validMoveHexes) {
		const { x, y } = axialToPixel(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}
	
	// Draw invalid move range
	ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
	for (const hex of invalidMoveHexes) {
		const { x, y } = axialToPixel(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}

	// Draw selected hex outline
	if (selectedHex) {
		const { x, y } = axialToPixel(selectedHex.q, selectedHex.r);
		drawHexagonPath(x, y);
		ctx.strokeStyle = 'rgba(255,255,255,0.2)';
		ctx.lineWidth = 3;
		ctx.stroke();
	}
	
	// Draw placement highlight
	if (placingUnit) {
		const mouseHex = pixelToAxial(lastMousePos.x, lastMousePos.y);
		const { x, y } = axialToPixel(mouseHex.q, mouseHex.r);
		drawHexagonPath(x, y);
		if (isPlacementValid(placingUnit.type, mouseHex, getMyPlayer())) {
			ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
		} else {
			ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
		}
		ctx.fill();
	}
	
	// --- DRAW UNITS (existing code, moved *after* highlights) ---
	ctx.font = `${HEX_SIZE * 0.5}px sans-serif`;
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	
	let myPlayer = getMyTurnPlayer();
	
	for (const unit of GAME_STATE.units) {
		let { x, y } = axialToPixel(unit.q, unit.r);
		const owner = getPlayer(unit.ownerId);
		if (!owner) continue;
		
		// Shake logic
		const shake = shakingUnits.find(s => s.id === unit.id);
		if (shake && shake.endTime > Date.now()) {
			x += (Math.random() - 0.5) * HEX_SIZE * 0.1;
			y += (Math.random() - 0.5) * HEX_SIZE * 0.1;
		} else if (shake) {
			shakingUnits = shakingUnits.filter(s => s.id !== unit.id);
		}

		const data = SOLDIER_DATA[unit.type] || CASTLE_DATA[unit.type];
		
		
		let imageKey = `${data.type}${data.level}`;
		const img = getImage(imageKey);
		
		if (img && img.complete && img.width > 0) {
			// Draw the image centered and scaled
			let imginfo = getImageSettings(imageKey);
			let scale = imginfo.scale*0.9; // 0.9 global scale
			let ratio = img.height/img.width;
			let drawSize = 50;
			let hsize = drawSize/2;
			let offsetX = imginfo.offsetX;
			let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
			let dx = x-((hsize-offsetX)*scale);
			let dy = y-((hsize-offsetY+10)*ratio*scale);
			let dw = drawSize*scale;
			let dh = drawSize*ratio*scale;
			
			
			// draw unit:
			ctx.drawImage(img, dx, dy, dw, dh);
			
			
			if(data.type == 'soldier'){
				if(myPlayer.id === unit.ownerId && isMyTurn()){
				
					// draw yellow arrow sign:
					if (!unit.hasMoved) {
						let selectImg = getImage('select');
						ctx.drawImage(selectImg, dx, dy, dw, dh);
						// draw arrow top left to signal the unit was not moved yet on this turn.
					}
				}
			}
			
			//if (unit.hasMoved) {
				// FILTERS ARE FUCKING SLOW!!! DONT USE.
				//ctx.filter = 'brightness(0.6) opacity(1)';
				////ctx.filter = 'drop-shadow(10px 10px 8px rgba(0, 0, 0, 0.6))';
				// DRAW IMAGE
				//ctx.filter = 'none'; // always reset after
			//}
			
		}

	}

	ctx.restore();
	
	requestAnimationFrame(render);
}

let lastMousePos = { x: 0, y: 0 };

function handleCanvasMouseMove(e) {
	lastMousePos.x = e.clientX;
	lastMousePos.y = e.clientY;
	
	if (dragStart && dragStart.canDrag) {
		const dx = e.clientX - dragStart.x;
		const dy = e.clientY - dragStart.y;
		
		if (!isDragging && Math.hypot(dx, dy) > 5) {
			isDragging = true;
		}
		
		if (isDragging) {
			viewport.x += dx;
			viewport.y += dy;
			dragStart.x = e.clientX;
			dragStart.y = e.clientY;
		}
	}
}

function handleCanvasMouseDown(e) {
	isDragging = false; // Reset dragging flag
	dragStart = { x: e.clientX, y: e.clientY };
	
	const clickedHex = pixelToAxial(e.clientX, e.clientY);
	const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);
	
	// Don't drag if we click a unit
	if (!unitOnHex) {
		dragStart.canDrag = true;
	} else {
		dragStart.canDrag = false;
	}
}

function handleCanvasMouseUp(e) {
	const dx = e.clientX - dragStart.x;
	const dy = e.clientY - dragStart.y;
	const dist = Math.sqrt(dx*dx + dy*dy);
	
	if (dist < 5) { // It's a click, not a drag
		handleHexClick(pixelToAxial(e.clientX, e.clientY));
	}
	isDragging = false;
	dragStart = null;
}

// --- Touch controls ---
let touchStartPos = null;
let lastTouch = null;
let lastDist = null; // for pinch-zoom

function handleTouchStart(e) {
	if (e.touches.length === 1) {
		// Single touch (drag or tap)
		const touch = e.touches[0];
		isDragging = false;
		touchStartPos = { x: touch.clientX, y: touch.clientY };
		
		const clickedHex = pixelToAxial(touch.clientX, touch.clientY);
		const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);
		
		touchStartPos.canDrag = !unitOnHex;
		lastTouch = { x: touch.clientX, y: touch.clientY };
		lastDist = null;
	} else if (e.touches.length === 2) {
		// Pinch-zoom
		isDragging = false; // Stop dragging
		touchStartPos = null;
		lastDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
	}
}

function handleTouchMove(e) {
	lastMousePos.x = e.touches[0].clientX; // for placement cursor
	lastMousePos.y = e.touches[0].clientY;

	if (e.touches.length === 1 && touchStartPos && touchStartPos.canDrag) {
		// Dragging
		const touch = e.touches[0];
		const dx = touch.clientX - lastTouch.x;
		const dy = touch.clientY - lastTouch.y;
		
		if (!isDragging && Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y) > 5) {
			isDragging = true; // Started dragging
		}
		
		if (isDragging) {
			viewport.x += dx;
			viewport.y += dy;
		}
		lastTouch.x = touch.clientX;
		lastTouch.y = touch.clientY;

	} else if (e.touches.length === 2 && lastDist) {
		// Pinch-zoom
		const newDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
		
		const zoomFactor = newDist / lastDist;
		
		// Get center of pinch
		const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
		const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

		zoomAtPoint(midX, midY, zoomFactor);

		lastDist = newDist;
	}
}

function handleTouchEnd(e) {
	if (e.touches.length === 0 && touchStartPos && !isDragging) {
		// This was a tap
		handleHexClick(pixelToAxial(touchStartPos.x, touchStartPos.y));
	}
	
	if (e.touches.length < 2) {
		lastDist = null; // Stop zooming
	}
	if (e.touches.length < 1) {
		isDragging = false; // Stop dragging
		touchStartPos = null;
		lastTouch = null;
	}
}

function zoomAtPoint(x, y, factor) {
	const newZoom = Math.max(MIN_ZOOM, Math.min(viewport.zoom * factor, MAX_ZOOM));
	const oldZoom = viewport.zoom;
	
	// (x - viewport.x) / oldZoom = worldX
	// (new_x - viewport.x_new) / newZoom = worldX
	// (x - viewport.x_new) / newZoom = (x - viewport.x) / oldZoom
	// (x - viewport.x_new) = (x - viewport.x) * newZoom / oldZoom
	// x - viewport.x_new = (x - viewport.x) * (newZoom / oldZoom)
	// viewport.x_new = x - (x - viewport.x) * (newZoom / oldZoom)
	
	viewport.x = x - (x - viewport.x) * (newZoom / oldZoom);
	viewport.y = y - (y - viewport.y) * (newZoom / oldZoom);
	viewport.zoom = newZoom;
}

function handleWheel(e) {
	e.preventDefault();
	const zoomFactor = (e.deltaY < 0) ? 1.1 : (1 / 1.1);
	zoomAtPoint(e.clientX, e.clientY, zoomFactor);
}

// =================================================================
// --- GAME LOGIC HELPERS
// =================================================================

function getTileAt(q, r) {
	return GAME_STATE.map.tiles[`${q},${r}`];
}

function setTileAt(q, r, tileData) {
	GAME_STATE.map.tiles[`${q},${r}`] = tileData;
}

function getUnitAt(q, r) {
	return GAME_STATE.units.find(u => u.q === q && u.r === r);
}

function getMyTurnPlayer() {
	if (!GAME_STATE.gameStarted) return null;
	const player = GAME_STATE.players[GAME_STATE.turn.currentPlayerIndex];
	return player;
}

function isMyTurn() {
	const myTurnPlayer = getMyTurnPlayer();
	return myTurnPlayer && myTurnPlayer.id === localPlayer.id;
}

function updateGameUI() {
	if (!GAME_STATE.gameStarted) return;
	
	const myPlayer = getMyPlayer();
	const myTurnPlayer = getMyTurnPlayer();
	
	// Update player list
	playerUIList.innerHTML = '';
	GAME_STATE.players.forEach(p => {
		const item = document.createElement('div');
		item.className = 'player-list-item';
		if (p.id === myTurnPlayer?.id) {
			item.classList.add('current-turn');
		}
		let color = p.color;
		let specTag = "";
		if(p.isSpectator){
			color = "white";
			specTag = "(spec)";
		}
		if(!p.quitted){
			item.innerHTML = `
				<span class="player-turn-indicator"></span>
				<span style="color: ${color}; font-weight: bold;" class="namevals"></span>
			`;
			const safeName = document.createTextNode(`${p.name} ${specTag}`);
			item.querySelector("span.namevals").appendChild(safeName);
			playerUIList.appendChild(item);
		}
	});

	// Update turn info
	turnInfo.textContent = `Turn ${GAME_STATE.turn.turnNumber}`;
	
	// Update buttons
	const canPlay = isMyTurn() && !myPlayer.isSpectator;
	buildSoldierBtn.disabled = !canPlay;
	buildCastleBtn.disabled = !canPlay;
	endTurnBtn.disabled = !canPlay;
	undoBtn.disabled = !canPlay;
	chatInput.disabled = false;
	
	// Update savings
	if (myPlayer && !myPlayer.isSpectator) {
		playerSavings.textContent = `Savings: ${myCurrentSavings} G`;
	} else {
		playerSavings.textContent = "Spectating";
	}
}

function getMyTotalSavings() {
	// This is now just a client-side getter
	return myCurrentSavings;
}

// =================================================================
// --- GAME LOGIC - ACTIONS
// =================================================================

function isHexWater(q, r){
	const tile = getTileAt(q, r);
	if(!tile){ // out of bounds, mark as water:
		return true;
	}else if(tile.type == "water"){
		return true;
	}
	return false;
}

function handleHexClick(hex) {
	const myPlayer = getMyPlayer();
	if (!myPlayer || myPlayer.isSpectator || !isMyTurn()) {
	
		if(!isHexWater(hex.q, hex.r)){
			// Spectator or not my turn, just select
			selectedHex = hex;
			
			selectedUnit = getUnitAt(hex.q, hex.r) || null;
			placingUnit = null;
			buildPopup.style.display = 'none';
			updateHighlights();
		}else{
			selectedUnit = null; // Deselect
			selectedHex = null;
		}
		return;
	}
	


	// --- PLACING A UNIT ---
	if (placingUnit) {
		if (isPlacementValid(placingUnit.type, hex, myPlayer)) {
			sendToHost({
				type: 'action_build',
				unitType: placingUnit.type,
				q: hex.q,
				r: hex.r
			});
		} else {
			playSound('protect');
		}
		placingUnit = null;
		updateHighlights();
		return;
	}
	
	// --- MOVING A UNIT ---
	if (selectedUnit) {
		// Check if clicking a valid move hex
		const isValidMove = validMoveHexes.some(h => h.q === hex.q && h.r === hex.r);
		if (isValidMove) {
			sendToHost({
				type: 'action_move',
				unitId: selectedUnit.id,
				toQ: hex.q,
				toR: hex.r
			});
			// Deselect
			selectedUnit = null;
			selectedHex = null;
		} else {
			// Clicked somewhere else, check for new selection
			if(!isHexWater(hex.q, hex.r)){
				const unitOnHex = getUnitAt(hex.q, hex.r);
				if (unitOnHex && unitOnHex.ownerId === localPlayer.id) {
					selectedUnit = unitOnHex; // Select new unit
					selectedHex = hex;
				} else {
					selectedUnit = null; // Deselect
					selectedHex = hex;
				}
			}else{
				selectedUnit = null; // Deselect
				selectedHex = null;
			}
		}
	} else {
		// --- SELECTING A UNIT ---
		if(!isHexWater(hex.q, hex.r)){
			const unitOnHex = getUnitAt(hex.q, hex.r);
			if (unitOnHex && unitOnHex.ownerId === localPlayer.id) {
				selectedUnit = unitOnHex;
				selectedHex = hex;
			} else {
				selectedUnit = null;
				selectedHex = hex;
			}
		}else{
			selectedUnit = null; // Deselect
			selectedHex = null;
		}
	}
	
	updateHighlights();
}

function updateHighlights() {
	// Clear all highlights
	highlightedPool = [];
	validMoveHexes = [];
	invalidMoveHexes = [];
	
	let poolStartHex = null;
	if (selectedUnit) {
		poolStartHex = selectedUnit;
	} else if (selectedHex) {
		poolStartHex = selectedHex;
	}
	
	const myPlayer = getMyPlayer();
	if (!myPlayer) return;

	// --- 1. Find the connected pool ---
	if (poolStartHex) {
		const tile = getTileAt(poolStartHex.q, poolStartHex.r);
		if (tile && tile.ownerId === myPlayer.id) {
			// Run BFS to find all connected friendly hexes
			const queue = [{q: poolStartHex.q, r: poolStartHex.r}];
			const visited = new Set([`${poolStartHex.q},${poolStartHex.r}`]);
			
			while (queue.length > 0) {
				const current = queue.shift();
				highlightedPool.push(current);
				
				for (const n of getHexNeighbors(current.q, current.r)) {
					const nKey = `${n.q},${n.r}`;
					const nTile = getTileAt(n.q, n.r);
					if (nTile && nTile.ownerId === myPlayer.id && !visited.has(nKey)) {
						visited.add(nKey);
						queue.push(n);
					}
				}
			}
		}
	}
	
	// --- 2. Highlight movement options (only if a unit is selected) ---
	if (selectedUnit) {
		const borderHexes = new Map(); // Use Map to avoid duplicates, key 'q,r'
		
		// Add all empty hexes *in* the pool as valid moves
		for (const hex of highlightedPool) {
			// removing this fixes bug not allowing moving around selected unit:
			//if (hex.q === selectedUnit.q && hex.r === selectedUnit.r) continue;
			if (!getUnitAt(hex.q, hex.r)) {
				validMoveHexes.push(hex);
			}
			
			// While we're here, find all neighbors to build the border set
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nKey = `${n.q},${n.r}`;
				const nTile = getTileAt(n.q, n.r);
				// If neighbor exists, is not water, and is not in our pool
				if (nTile && nTile.type !== 'water' && !highlightedPool.some(p => p.q === n.q && p.r === n.r)) {
					borderHexes.set(nKey, n);
				}
			}
		}
		
		// Now check all border hexes for validity
		for (const [key, hex] of borderHexes.entries()) {
			const toTile = getTileAt(hex.q, hex.r); // We know this tile exists and isn't water
			const targetUnit = getUnitAt(hex.q, hex.r);
			const shieldLevel = getShieldLevel(hex.q, hex.r, myPlayer.id);

			if (targetUnit) {
				if (targetUnit.ownerId === myPlayer.id) continue; // Should be impossible
				if (selectedUnit.level > shieldLevel && selectedUnit.level > targetUnit.level) {
					validMoveHexes.push(hex);
				} else {
					invalidMoveHexes.push(hex);
				}
			} else { // No target unit
				if (toTile.ownerId !== null) { // Enemy land
					if (selectedUnit.level > shieldLevel) {
						validMoveHexes.push(hex);
					} else {
						invalidMoveHexes.push(hex);
					}
				} else { // Unowned land
					// Shields don't apply to unowned land
					validMoveHexes.push(hex);
				}
			}
		}
	}
}

function openBuildPopup(type) {
	placingUnit = null;
	selectedUnit = null;
	selectedHex = null;
	
	const data = (type === 'soldier') ? SOLDIER_DATA : CASTLE_DATA;
	const mySavings = getMyTotalSavings();
	
	buildPopupTitle.textContent = `Buy ${type}`;
	buildPopupList.innerHTML = '';
	
	for (const key in data) {
		const item = data[key];
		const canAfford = mySavings >= item.cost;
		const itemEl = document.createElement('div');
		itemEl.className = 'build-item';
		if (!canAfford) itemEl.classList.add('disabled');
		let imagePath = getImagePath(item);
		// <span>${item.name} (Lvl ${item.level})</span>
		itemEl.innerHTML = `
			<span><img src="${imagePath}" width="50"></span>
			<span class="cost"><span style="color:white">Cost:</span> ${item.cost}${item.wage ? `<br><span style="color:white">Wage:</span> ${item.wage}` : ''}</span>
		`;
		
		if (canAfford) {
			itemEl.onclick = () => {
				placingUnit = { type: item.name, cost: item.cost };
				buildPopup.style.display = 'none';
			};
		}
		buildPopupList.appendChild(itemEl);
	}
	buildPopup.style.display = 'block';
}

// --- HOST-SIDE VALIDATION ---

function isPlacementValid(unitType, hex, player) {
	const tile = getTileAt(hex.q, hex.r);
	if (!tile || tile.type === 'water') return false; // Must be on land
	if (getUnitAt(hex.q, hex.r)) return false; // Must be empty
	
	const isCastle = !!CASTLE_DATA[unitType];
	if (isCastle) {
		if (tile.ownerId !== player.id) return false; // Must own hex
		if (tile.object) return false; // Must be clear (no tree/grass)
	} else {
		// Soldier
		// Rules are "neighbouring land i own, or in the land i own"
		if (tile.ownerId !== player.id) {
			// Check neighbors
			let isNeighborOwned = false;
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerId === player.id) {
					isNeighborOwned = true;
					break;
				}
			}
			if (!isNeighborOwned) return false;
		}
	}
	return true;
}

function getShieldLevel(q, r, perspectiveOwnerId) {
	let maxShield = 0;
	for (const n of getHexNeighbors(q, r)) {
		const unit = getUnitAt(n.q, n.r);
		if (unit && unit.ownerId !== perspectiveOwnerId) {
			// It's an enemy unit
			maxShield = Math.max(maxShield, unit.level);
		}
	}
	return maxShield;
}

function isMoveValid(unit, toHex, player) {
	if (unit.hasMoved) return { valid: false, reason: 'Unit has already moved.' };

	const toTile = getTileAt(toHex.q, toHex.r);
	if (!toTile || toTile.type === 'water') return { valid: false, reason: 'Cannot move into water.' };
	
	const targetUnit = getUnitAt(toHex.q, toHex.r);

	// Find the unit's entire pool
	const unitPool = [];
	const queue = [{q: unit.q, r: unit.r}];
	const visited = new Set([`${unit.q},${unit.r}`]);
	
	while(queue.length > 0) {
		const current = queue.shift();
		unitPool.push(current);
		
		for (const n of getHexNeighbors(current.q, current.r)) {
			const nKey = `${n.q},${n.r}`;
			const nTile = getTileAt(n.q, n.r);
			if (nTile && nTile.ownerId === player.id && !visited.has(nKey)) {
				visited.add(nKey);
				queue.push(n);
			}
		}
	}
	
	// --- Case 1: Moving onto own tile (inside the pool) ---
	const isMovingInPool = unitPool.some(h => h.q === toHex.q && h.r === toHex.r);
	if (isMovingInPool) {
		if (targetUnit) return { valid: false, reason: 'Cannot move onto own unit.' };
		return { valid: true, action: 'move' };
	}

	// --- Case 2: Moving outside the pool ---
	// Check if toHex is a neighbor of *any* hex in the pool
	let isBorderHex = false;
	for (const poolHex of unitPool) {
		if (getHexDistance(poolHex.q, poolHex.r, toHex.q, toHex.r) === 1) {
			isBorderHex = true;
			break;
		}
	}

	if (!isBorderHex) {
		return { valid: false, reason: 'Too far.' };
	}
	
	// It's a valid border hex, now check shields and targets
	const shieldLevel = getShieldLevel(toHex.q, toHex.r, player.id);

	if (targetUnit) {
		if (targetUnit.ownerId === player.id) {
			return { valid: false, reason: 'Cannot move onto own unit.' }; // Should be caught by pool check, but safe
		}
		if (unit.level > shieldLevel && unit.level > targetUnit.level) {
			 return { valid: true, action: 'attack', target: targetUnit };
		} else {
			return { valid: false, reason: 'Target unit level is too high or shielded.', shake: true };
		}
	}
	
	// No target unit
	if (toTile.ownerId !== null) { // It's enemy land
		if (unit.level > shieldLevel) {
			return { valid: true, action: 'move' };
		} else {
			return { valid: false, reason: 'Blocked by enemy shield.', shake: true };
		}
	} else { // It's unowned land
		// New rule: Shields do not block movement to unowned land
		return { valid: true, action: 'move' };
	}
}

function executeAction(playerId, action) {
	// HOST-ONLY function
	if (!localPlayer.isHost) return;
	
	const player = getPlayer(playerId);
	if (!player || player.id !== getMyTurnPlayer()?.id) {
		console.warn(`Action from wrong player: ${playerId}`);
		return;
	}
	
	let updates = []; // Array of update messages to broadcast
	let sounds = []; // Array of sounds to broadcast
	let actionForUndo = null;
	let affectedPlayers = new Set([playerId]); // Track who needs savings update

	switch (action.type) {
		case 'action_move': {
			const { unitId, toQ, toR } = action;
			const unit = GAME_STATE.units.find(u => u.id === unitId);
			if (!unit || unit.ownerId !== playerId) return;
			
			const moveCheck = isMoveValid(unit, { q: toQ, r: toR }, player);
			if (moveCheck.valid) {
				const fromQ = unit.q;
				const fromR = unit.r;
				const toTile = getTileAt(toQ, toR);
				const oldOwner = toTile.ownerId;
				const oldObject = toTile.object;
				
				actionForUndo = {
					type: 'move',
					unitId: unit.id,
					fromQ, fromR,
					toQ, toR,
					didClaim: oldOwner !== playerId,
					oldOwner: oldOwner,
					clearedObject: oldObject
				};
				
				if (moveCheck.action === 'attack') {
					const targetUnit = moveCheck.target;
					actionForUndo.killedUnit = { ...targetUnit }; // Store copy
					GAME_STATE.units = GAME_STATE.units.filter(u => u.id !== targetUnit.id);
					updates.push({ type: 'unit_removed', unitId: targetUnit.id });
					sounds.push(CASTLE_DATA[targetUnit.type] ? 'destroy' : 'kill');
				}
				
				console.warn("actionForUndo1");
				console.warn(actionForUndo);
				
				// Move unit
				unit.q = toQ;
				unit.r = toR;
				unit.hasMoved = true;
				updates.push({ type: 'unit_moved', unitId: unit.id, q: toQ, r: toR, hasMoved: true });
				
				// Claim hex
				if (toTile.ownerId !== playerId) {
					toTile.ownerId = playerId;
					updates.push({ type: 'tile_changed', q: toQ, r: toR, ownerId: playerId });
					sounds.push('moveunit');
				}
				if (toTile.object) {
					toTile.object = null;
					updates.push({ type: 'tile_changed', q: toQ, r: toR, object: null });
				}
				
				distributePoolSavings(findEconomyPools(playerId));
				if (oldOwner) {
					affectedPlayers.add(oldOwner);
					distributePoolSavings(findEconomyPools(oldOwner));
				}
				
			} else if (moveCheck.shake) {
				broadcast({ type: 'unit_shake', unitId: unit.id });
				sounds.push('protect');
			}
			break;
		}
		
		case 'action_build': {
			const { unitType, q, r } = action;
			const data = SOLDIER_DATA[unitType] || CASTLE_DATA[unitType];
			if (!data) return;
			
			if (isPlacementValid(unitType, {q, r}, player)) {
				const pools = findEconomyPools(playerId);
				let totalSavings = 0;
				pools.forEach(p => totalSavings += p.totalSavings);
				
				if (totalSavings >= data.cost) {
					deductCost(pools, data.cost);
					
					const newUnit = {
						id: getUID(),
						type: unitType,
						ownerId: playerId,
						level: data.level,
						q, r,
						hasMoved: true,
						isCastle: !!CASTLE_DATA[unitType]
					};
					GAME_STATE.units.push(newUnit);
					
					let didClaim = false;
					
					const tile = getTileAt(q, r);
					if (!newUnit.isCastle && tile.ownerId !== playerId) {
						tile.ownerId = playerId;
						didClaim = true;
						updates.push({ type: 'tile_changed', q: q, r: r, ownerId: playerId });
						sounds.push('moveunit');
					}
					let clearedObject = null;
					if (tile.object) {
						clearedObject = tile.object;
						tile.object = null;
						updates.push({ type: 'tile_changed', q: q, r: r, object: null });
					}
					actionForUndo = { type: 'build', unit: newUnit, cost: data.cost, didClaim: didClaim, clearedObject:clearedObject };
					console.warn("actionForUndo");
					console.warn(actionForUndo);
					updates.push({ type: 'unit_added', unit: newUnit });
					sounds.push('moveunit');
					
					distributePoolSavings(findEconomyPools(playerId));
				}
			}
			break;
		}
		
		case 'action_undo': {
			const lastAction = currentTurnActions.pop();
			if (!lastAction) break;
			
			if (lastAction.type === 'move') {
				const unit = GAME_STATE.units.find(u => u.id === lastAction.unitId);
				if (unit) {
					unit.q = lastAction.fromQ;
					unit.r = lastAction.fromR;
					unit.hasMoved = false;
					updates.push({ type: 'unit_moved', unitId: unit.id, q: unit.q, r: unit.r, hasMoved: false });
				}
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						tile.ownerId = lastAction.oldOwner;
						updates.push({ type: 'tile_changed', q: lastAction.toQ, r: lastAction.toR, ownerId: tile.ownerId });
					}
				}
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						tile.object = lastAction.clearedObject;
						updates.push({ type: 'tile_changed', q: lastAction.toQ, r: lastAction.toR, object: tile.object });
					}
				}
				if (lastAction.killedUnit) {
					GAME_STATE.units.push(lastAction.killedUnit);
					updates.push({ type: 'unit_added', unit: lastAction.killedUnit });
				}
				
				distributePoolSavings(findEconomyPools(playerId));
				if(lastAction.oldOwner) {
					affectedPlayers.add(lastAction.oldOwner);
					distributePoolSavings(findEconomyPools(lastAction.oldOwner));
				}
				
			} else if (lastAction.type === 'build') {
				GAME_STATE.units = GAME_STATE.units.filter(u => u.id !== lastAction.unit.id);
				updates.push({ type: 'unit_removed', unitId: lastAction.unit.id });
				
				const pools = findEconomyPools(playerId);
				addCost(pools, lastAction.cost);
				
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						tile.ownerId = null; 
						updates.push({ type: 'tile_changed', q: lastAction.unit.q, r: lastAction.unit.r, ownerId: null });
					}
				}
				
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						tile.object = lastAction.clearedObject;
						updates.push({ type: 'tile_changed', q: lastAction.unit.q, r: lastAction.unit.r, object: tile.object });
					}
				}
				distributePoolSavings(findEconomyPools(playerId));
			}
			sounds.push('moveunit');
			break;
		}
		
		case 'action_end_turn': {
			executeEndTurn(playerId);
			broadcast({ type: 'sound', name: "move" });
			return; // end turn handles its own broadcasts
		}
	}
	
	if (actionForUndo) {
		currentTurnActions.push(actionForUndo);
	}
	
	for (const update of updates) {
		broadcast(update);
	}
	const uniqueSounds = [...new Set(sounds)];
	for (const sound of uniqueSounds) {
		broadcast({ type: 'sound', name: sound });
	}
	
	// Send savings updates to all affected players
	affectedPlayers.forEach(pid => updatePlayerSavings(pid));
}

// =================================================================
// --- ECONOMY & TURN LOGIC (HOST-SIDE)
// =================================================================
function updatePlayerSavings(playerId) {
	if (!playerId) return;
	const newPools = findEconomyPools(playerId);
	let newTotalSavings = 0;
	newPools.forEach(p => newTotalSavings += p.totalSavings);
	console.log("newTotalSavings");
	console.log(newTotalSavings);
	
	sendToPlayer(playerId, { 
		type: 'savings_update', 
		total: Math.floor(newTotalSavings) 
	});
}

function findEconomyPools(playerId) {
	// Finds all contiguous land areas for a given player
	const pools = [];
	const visited = new Set(); // 'q,r'
	
	for (const key in GAME_STATE.map.tiles) {
		const tile = GAME_STATE.map.tiles[key];
		if (tile.ownerId !== playerId || visited.has(key)) {
			continue;
		}
		
		// Start a new pool
		const pool = {
			hexes: [], // {q, r, tile}
			soldiers: [],
			totalSavings: 0,
			totalIncome: 0,
			totalWages: 0
		};
		
		const queue = [key]; // 'q,r'
		visited.add(key);
		
		while (queue.length > 0) {
			const currentKey = queue.shift();
			const [q, r] = currentKey.split(',').map(Number);
			const currentTile = GAME_STATE.map.tiles[currentKey];
			
			pool.hexes.push({ q, r, tile: currentTile });
			pool.totalSavings += currentTile.savings;
			
			// Add income (if no tree)
			if (currentTile.object !== 'tree' && currentTile.object !== 'grass') {
				pool.totalIncome += gameRules.tileIncome;
			}
			
			// Check for soldier
			const unit = getUnitAt(q, r);
			if (unit && !unit.isCastle && SOLDIER_DATA[unit.type]) {
				pool.soldiers.push(unit);
				pool.totalWages += SOLDIER_DATA[unit.type].wage;
			}
			
			// Check neighbors
			for (const n of getHexNeighbors(q, r)) {
				const nKey = `${n.q},${n.r}`;
				const nTile = GAME_STATE.map.tiles[nKey];
				if (nTile && nTile.ownerId === playerId && !visited.has(nKey)) {
					visited.add(nKey);
					queue.push(nKey);
				}
			}
		}
		pools.push(pool);
	}
	return pools;
}

function distributePoolSavings(pools) {
	// Takes a list of pools (from findEconomyPools) and distributes
	// their savings evenly among their hexes.
	let updates = [];
	for (const pool of pools) {
		if (pool.hexes.length === 0) continue;
		
		const savingsPerHex = pool.totalSavings / pool.hexes.length;
		for (const hex of pool.hexes) {
			if (hex.tile.savings !== savingsPerHex) {
				hex.tile.savings = savingsPerHex;
				// Don't need to broadcast savings changes,
				// they are implicit and only matter to the host
				// and the player (who gets a total).
			}
		}
	}
	// Return updates if we ever need them
	return updates;
}

function deductCost(pools, cost) {
	// Deducts cost proportionally from all pools
	let totalSavings = 0;
	pools.forEach(p => totalSavings += p.totalSavings);
	if (totalSavings < cost) return false; // Should not happen
	
	for (const pool of pools) {
		const proportion = pool.totalSavings / totalSavings;
		pool.totalSavings -= cost * proportion;
	}
	distributePoolSavings(pools);
	return true;
}

function addCost(pools, cost) {
	// Refunds cost. Just add it to the first pool.
	// distributePoolSavings will spread it evenly.
	if (pools.length > 0) {
		pools[0].totalSavings += cost;
	}
	distributePoolSavings(pools);
}


function advanceToNextPlayer(){
	let nextIndex = GAME_STATE.turn.currentPlayerIndex;
    do {
        nextIndex = (nextIndex + 1) % GAME_STATE.players.length;
    } while (GAME_STATE.players[nextIndex].isSpectator);
	
    GAME_STATE.turn.currentPlayerIndex = nextIndex;
	
	let firstPlayerIndex = 0;
	for(let i = 0; i < GAME_STATE.players.length; i++){
		if(!GAME_STATE.players[i].isSpectator){
			firstPlayerIndex = i;
			break;
		}
	}
	
	if (GAME_STATE.turn.currentPlayerIndex === firstPlayerIndex) {
		GAME_STATE.turn.turnNumber++;
	}
	
	updateGameUI();
}

function checkForAITurn(){
	
	
}

function executeEndTurn(playerId) {
	// --- 1. Apply income and wages for current player ---
	const player = getPlayer(playerId);
	const pools = findEconomyPools(playerId);
	
	let allSoldiersKilled = [];
	
	//sounds.push('move');
	
	for (const pool of pools) {
		pool.totalSavings += pool.totalIncome;
		pool.totalSavings -= pool.totalWages;
		
		if (pool.totalSavings < 0) {
			// Bankrupt!
			pool.totalSavings = 0;
			for (const soldier of pool.soldiers) {
				allSoldiersKilled.push(soldier);
			}
			//sounds.push('kill'); // or 'famine'
		}
	}
	
	// Distribute final savings
	distributePoolSavings(pools);
	updatePlayerSavings(playerId); // Update savings *after* calcs
	
	// --- 2. Kill soldiers & turn to grass ---
	for (const soldier of allSoldiersKilled) {
		const tile = getTileAt(soldier.q, soldier.r);
		if (tile) {
			tile.object = 'grass'; // Turn to grass
			broadcast({ type: 'tile_changed', q: soldier.q, r: soldier.r, object: 'grass' });
		}
		GAME_STATE.units = GAME_STATE.units.filter(u => u.id !== soldier.id);
		broadcast({ type: 'unit_removed', unitId: soldier.id });
	}
	
	// --- 3. Reset "hasMoved" for all *this player's* units ---
	GAME_STATE.units.forEach(u => {
		if (u.ownerId === playerId) {
			if (u.hasMoved) {
				u.hasMoved = false;
				broadcast({ type: 'unit_moved', unitId: u.id, q: u.q, r: u.r, hasMoved: false });
			}
		}
	});
	
	// --- 4. Grow Grass / Spawn Trees (random events) ---
	// TODO: Add grass spreading and tree spawning logic
	
	// --- 5. Advance Turn ---

	advanceToNextPlayer();
	console.log("GAME_STATE.turn.currentPlayerIndex");
	console.log(GAME_STATE.turn.currentPlayerIndex);
	
	
	currentTurnActions = []; // Clear undo stack
	
	broadcast({ 
		type: 'turn_changed', 
		currentPlayerIndex: GAME_STATE.turn.currentPlayerIndex, 
		turnNumber: GAME_STATE.turn.turnNumber 
	});
	
	// --- 6. Check for AI turn ---
	// TODO: If new player is AI, run AI logic
}


function hideUiRight(){
	uiRight.style.display = "none";
}


// =================================================================
// --- GAME STATE SYNC (NETWORKING)
// =================================================================

function handleHostData(data) {
	// CLIENT-SIDE: Received data from host
	let needsUIUpdate = false;
	
	switch (data.type) {
		case 'game_start':
			GAME_STATE = data.state;
			showPage('game');
			updateGameUI();
			break;
		case 'full_state':
			GAME_STATE = data.state;
			if (!localPlayer.isSpectator) {
				localPlayer.isSpectator = true;
				localPlayer.color = SPECTATOR_COLOR;
				hideUiRight();
				console.log("localPlayer");
				console.log(localPlayer);
				alert("Game in progress. Joining as spectator.");
			}
			showPage('game');
			updateGameUI();
			break;
		case 'lobby_update':
			GAME_STATE.settings = data.settings;
			GAME_STATE.players = data.players;
			updateLobbyUI();
			break;
		case 'chat':
			addChatMessage(data.from, data.message, data.color);
			break;
		case 'tile_changed':
			const tile = getTileAt(data.q, data.r);
			if (tile) {
				if (data.ownerId !== undefined) tile.ownerId = data.ownerId;
				if (data.object !== undefined) tile.object = data.object;
			}
			needsUIUpdate = true;
			break;
		case 'unit_added':
			GAME_STATE.units.push(data.unit);
			needsUIUpdate = true;
			break;
		case 'unit_removed':
			GAME_STATE.units = GAME_STATE.units.filter(u => u.id !== data.unitId);
			needsUIUpdate = true;
			break;
		case 'unit_moved':
			const unit = GAME_STATE.units.find(u => u.id === data.unitId);
			if (unit) {
				unit.q = data.q;
				unit.r = data.r;
				unit.hasMoved = data.hasMoved;
			}
			needsUIUpdate = true;
			break;
		case 'unit_shake':
			shakingUnits.push({ id: data.unitId, endTime: Date.now() + 500 });
			playSound('protect'); // stub
			break;
		case 'turn_changed':
			GAME_STATE.turn = {
				currentPlayerIndex: data.currentPlayerIndex,
				turnNumber: data.turnNumber
			};
			selectedUnit = null;
			selectedHex = null;
			updateHighlights();
			updateGameUI();
			addSystemChatMessage(`Turn ${GAME_STATE.turn.turnNumber}: ${getMyTurnPlayer().name}'s turn.`);
			break;
		case 'sound':
			playSound(data.name);
			break;
		case 'savings_update':
			myCurrentSavings = data.total;
			playerSavings.textContent = `Savings: ${myCurrentSavings} G`;
			break;
	}
	
	if (needsUIUpdate) {
		updateGameUI();
	}
}

function handleClientData(peerId, data) {
	// HOST-SIDE: Received data from a client
	const player = getPlayer(peerId);
	if (!player) return;
	
	switch (data.type) {
		case 'join':
			player.name = data.name;
			
			if (!GAME_STATE.gameStarted) {
				player.color = data.color;
				player.isSpectator = data.isSpectator;
			} else {
				player.color = "#FFFFFF";
				player.isSpectator = true; // Always spectator if game in progress
			}
			// If player "takes" a loaded name, update that
			if (data.loadedPlayerName) {
				const p = loadedGameState.players.find(lp => lp.name === data.loadedPlayerName);
				if (p) p.isTaken = true;
			}
			broadcastLobbyState();
			addSystemChatMessage(`${player.name} has joined.`);
			break;
		case 'player_update':
			player.name = data.name;
			player.color = data.color;
			broadcastLobbyState();
			break;
		case 'chat':
			broadcast({
				type: 'chat',
				from: player.name,
				message: data.message,
				color: player.color
			});
			break;
		
		// All game actions
		case 'action_move':
		case 'action_build':
		case 'action_undo':
		case 'action_end_turn':
			if (GAME_STATE.gameStarted) {
				executeAction(peerId, data);
			}
			break;
	}
}

// =================================================================
// --- PEERJS NETWORKING
// =================================================================
function initPeerJS() {
	try {
		// This peer is for clients, or for the host to override
		peer = new Peer(null, {
			debug: 2 // Set to 0 for production
		});
		
		peer.on('open', (id) => {
			myPeerId = id;
			localPlayer.id = id;
			connectionStatus.textContent = 'Connected to Peer server.';
			console.log('My peer ID is: ' + id);
			// Enable buttons
			hostBtn.disabled = false;
			joinBtn.disabled = false;
			spectateBtn.disabled = false;
		});
		
		// NO 'connection' listener here. Clients don't accept connections.
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			alert(`Connection Error: ${err.message}\nTry refreshing or check your connection.`);
		});
		
	} catch (err) {
		console.error("Failed to initialize PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}

function setupConnection(conn) {
	connections.set(conn.peer, conn); // must be here instantly or color/nick changes wont work.
	
	conn.on('open', () => {
		console.log(`Data connection opened with ${conn.peer}`);
		//connections.set(conn.peer, conn);

		// If we are host, add new player and send lobby state
		if (localPlayer.isHost) {
			const newPlayer = {
				id: conn.peer,
				name: 'Joining...', // Will be updated by 'join' message
				color: null,
				isSpectator: false,
				isAI: false
			};
			GAME_STATE.players.push(newPlayer);
			
			if (GAME_STATE.gameStarted) {
				// Send full game state to new player (who will join as spec)
				conn.send({ type: 'full_state', state: GAME_STATE });
			} else {
				// Send lobby state
				conn.send({ type: 'lobby_update', settings: GAME_STATE.settings, players: GAME_STATE.players });
			}
		}
	});
	
	
	conn.on('data', (data) => {
		if (localPlayer.isHost) {
			handleClientData(conn.peer, data);
		} else {
			handleHostData(data);
		}
	});
	
	conn.on('close', () => {
		console.log(`Connection closed with ${conn.peer}`);
		connections.delete(conn.peer);
		if (localPlayer.isHost) {
			const player = getPlayer(conn.peer);
			if (player) {
				addSystemChatMessage(`${player.name} has left.`);
				//GAME_STATE.players = GAME_STATE.players.filter(p => p.id !== conn.peer);
				GAME_STATE.players = GAME_STATE.players.map(p =>
					p.id === conn.peer ? { ...p, isSpectator: true, quitted: true } : p
				);
				if (GAME_STATE.gameStarted) {
					// let others play if quitter was in turn:
					if(conn.peer == GAME_STATE.players[GAME_STATE.turn.currentPlayerIndex].id){
						advanceToNextPlayer();
						checkForAITurn(); // start AI turn if it is his turn.
					}else{
						
						updateGameUI();
					}
				} else {
					broadcastLobbyState();
				}
			}
		} else {
			// We were disconnected from host
			//alert('Disconnected from host. Returning to start page.');
			console.warn('Disconnected from host. Returning to start page.');
			showPage('start');
			// Reset state?
		}
	});
}

// Helper function for joinGame
function executeJoin(hostPeerId) {
	console.log(`Attempting to connect to host: ${hostPeerId}`);
	const conn = peer.connect(hostPeerId);
	
	conn.on('open', () => {
		console.log(`Connected to host: ${hostPeerId}`);
		setupConnection(conn);
		
		// Send our initial join info
		conn.send({
			type: 'join',
			name: localPlayer.name,
			color: localPlayer.color,
			isSpectator: localPlayer.isSpectator
		});
		
		// Go to lobby page
		lobbyPlayerNameInput.value = localPlayer.name;
		lobbyRoomNameTitle.textContent = `Joining: ${hostPeerId}`; // Use the ID we joined
		showPage('lobby');
	});
	
	conn.on('error', (err) => {
		console.error('Connection failed:', err);
		alert(`Failed to connect to room: ${hostPeerId}\nCheck the ID and try again.`);
	});
}

function joinGame(isSpectator) {
	localPlayer.isSpectator = isSpectator;
	localPlayer.name = playerNameInput.value;
	if (isSpectator) {
		localPlayer.color = SPECTATOR_COLOR;
		hideUiRight();
	}
	
	hostPeerId = roomNameInput.value.trim();
	if (!hostPeerId) {
		alert('Please enter a Game Room Name (which is the Host\'s ID).');
		return;
	}
	
	if (!peer || peer.destroyed) {
		console.log("Peer is destroyed, re-initializing for join.");
		initPeerJS(); // Re-init
		// Need to wait for 'open'
		peer.on('open', () => {
			console.log("Re-initialized peer, now joining.");
			executeJoin(hostPeerId);
		});
		return;
	}
	
	executeJoin(hostPeerId);
}

function hostGame() {
	const desiredRoomId = roomNameInput.value.trim();
	if (!desiredRoomId) {
		alert("Please enter a Game Room Name.");
		return;
	}

	if (peer) {
		peer.destroy();
	}
	
	console.log(`Attempting to host with ID: ${desiredRoomId}`);
	try {
		peer = new Peer(desiredRoomId, { debug: 2 });

		peer.on('open', (id) => {
			myPeerId = id;
			localPlayer.id = id;
			localPlayer.isHost = true;
			localPlayer.name = playerNameInput.value;
			hostPeerId = myPeerId;
			
			// Use the desired ID, not the one from the 'open' event (which should be the same)
			GAME_STATE.settings.roomName = desiredRoomId;
			// This was the line overwriting your input, it's now correct.
			roomNameInput.value = desiredRoomId; 
			hostRoomNameTitle.textContent = `Hosting: ${desiredRoomId}`;
			
			// Reset player list and add host
			GAME_STATE.players = []; 
			GAME_STATE.players.push(localPlayer);
			
			updateHostLobbyUI();
			showPage('host');
			connectionStatus.textContent = `Hosting at ${desiredRoomId}. Ready for players.`;
		});
		
		// Host MUST listen for connections
		peer.on('connection', (conn) => {
			console.log('Incoming connection from', conn.peer);
			setupConnection(conn);
		});
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			if (err.type === 'unavailable-id') {
				alert(`Game Room "${desiredRoomId}" is already taken. Please choose another name.`);
				showPage('start');
				peer.destroy();
				initPeerJS(); // Re-init with a random client ID
			}
		});
		
	} catch (err) {
		console.error("Failed to initialize host PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}

// =================================================================
// --- LOBBY UI & LOGIC
// =================================================================

function updateHostLobbyUI() {
	hostPlayerList.innerHTML = '';
	GAME_STATE.players.forEach(p => {
		const item = document.createElement('div');
		item.className = 'player-list-item';
		let specTag = p.isSpectator ? ' (spec)' : '';
		item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.color;
		item.textContent = `${p.name}${specTag}`;
		hostPlayerList.appendChild(item);
	});
}

function updateLobbyUI() {
	// Update settings info
	lobbyRoomNameTitle.textContent = `Joining: ${GAME_STATE.settings.roomName}`;
	lobbyMapSize.textContent = `${GAME_STATE.settings.mapWidth} x ${GAME_STATE.settings.mapHeight}`;
	lobbyStartMoney.textContent = `${GAME_STATE.settings.startingMoney} G`;
	
	// Update player list
	lobbyPlayerList.innerHTML = '';
	const usedColors = [];
	GAME_STATE.players.forEach(p => {
		const item = document.createElement('div');
		item.className = 'player-list-item';
		let specTag = p.isSpectator ? ' (spec)' : '';
		item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.color;
		item.textContent = `${p.name}${specTag}`;
		lobbyPlayerList.appendChild(item);
		if (p.color) usedColors.push(p.color);
	});
	/*
    playerList.innerHTML = '';
    gameState.players.forEach((p, playerIndex) => {
        const li = document.createElement('li');
        const displayName = p.isSpec ? `${p.name} (Spectator)` : p.name;
		const safeName = document.createTextNode(displayName);
		li.innerHTML = `<span style="color:${p.colors.color}"></span>`;
		li.querySelector("span").appendChild(safeName);
        playerList.appendChild(li);
    });
	*/
	// Update color picker
	lobbyColorPicker.innerHTML = '';
	if (localPlayer.isSpectator) {
		lobbyColorPicker.innerHTML = '<i>Spectators cannot change color.</i>';
		lobbyPlayerNameInput.disabled = true;
	} else {
		lobbyPlayerNameInput.disabled = false;
		console.log("usedColors");
		console.log(usedColors);
		PLAYER_COLORS.forEach(color => {
			const box = document.createElement('div');
			box.className = 'color-box';
			box.style.backgroundColor = color;
			
			if (localPlayer.color === color) {
				box.classList.add('selected');
			}
			if (usedColors.includes(color) && localPlayer.color !== color) {
				console.log(usedColors);
				box.classList.add('disabled');
			} else {
				box.onclick = () => {
					console.log("tried to change color");
					localPlayer.color = color;
					sendToHost({
						type: 'player_update',
						name: localPlayer.name,
						color: localPlayer.color
					});
					updateLobbyUI(); // Re-render
				};
			}
			lobbyColorPicker.appendChild(box);
		});
	}
}

function broadcastLobbyState() {
	if (!localPlayer.isHost) return;
	// Update host's own UI
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: 'lobby_update',
		settings: GAME_STATE.settings,
		players: GAME_STATE.players
	});
}

// =================================================================
// --- INDEXEDDB
// =================================================================

function initDB() {
	const request = indexedDB.open(DB_NAME, 1);
	
	request.onerror = (e) => {
		console.error("IndexedDB error:", e.target.errorCode);
	};
	
	request.onsuccess = (e) => {
		db = e.target.result;
		console.log("IndexedDB initialized.");
	};
	
	request.onupgradeneeded = (e) => {
		let db = e.target.result;
		if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
			db.createObjectStore(DB_STORE_NAME, { keyPath: 'roomName' });
		}
	};
}

function saveGameToDB(gameState) {
	if (!db) return;
	
	// Create a deep clone to store
	let stateToSave = JSON.parse(JSON.stringify(gameState));
	stateToSave.saveDate = new Date().toISOString();
	
	// --- FIX ---
	// The keyPath is 'roomName', so we must add it to the top level of the object.
	stateToSave.roomName = gameState.settings.roomName;
	// --- END FIX ---
	
	const transaction = db.transaction([DB_STORE_NAME], 'readwrite');
	const objectStore = transaction.objectStore(DB_STORE_NAME);
	const request = objectStore.put(stateToSave);
	
	request.onsuccess = () => {
		console.log('Game saved:', stateToSave.roomName);
	};
	request.onerror = (e) => {
		console.error('Error saving game:', e.target.error);
	};
}

function loadGameFromDB(roomName, callback) {
	if (!db) return;
	
	const transaction = db.transaction([DB_STORE_NAME], 'readonly');
	const objectStore = transaction.objectStore(DB_STORE_NAME);
	const request = objectStore.get(roomName);
	
	request.onsuccess = (e) => {
		callback(e.target.result);
	};
	request.onerror = (e) => {
		console.error('Error loading game:', e.target.error);
		callback(null);
	};
}

// =================================================================
// --- GAME INIT (HOST-SIDE)
// =================================================================

// generate_map

/*
castle wars map format:
first line: width height

left side = right on the game.
top side = top on the game.

values:
-1 water



                             first 5 bits
0 below = no owner.

  1 00000001 owner 1 empty   0
  4 00000100 owner 1 peasant

 41 00101001 owner 2 empty   5
 44 00101100 owner 2 peasant

 81 01010001 owner 3 empty   10
 84 01010100 owner 3 peasant

121 01111001 owner 4 empty   15
124 01111100 owner 4 peasant 

161 10100001 owner 5 empty   20
164 10100100 owner 5 peasant 

201 11001001 owner 6 empty   25
204 11001100 owner 6 peasant 

241 11110001 owner 0 empty   30
243 11110011 owner 0 tree

*/


let loadedmap = null;

parseMap("maps/mapn1.dat");

// loadmap
async function parseMap(mapFilePath){
	const response = await fetch(mapFilePath);
	if (!response.ok) {
		console.error("Failed to load file:", response.statusText);
		return;
	}

	const text = await response.text(); // read file as plain text
	const lines = text.split(/\r?\n/);  // split into lines

	let parsedMap = {
		width: 0,
		height: 0,
		data: [],
	};

	for(let p = 0; p < lines.length; p++){
		const trimmed = lines[p].trim();
		if (!trimmed) continue; // skip empty lines
		
		const lineValues = trimmed.split(/\s+/); // split by spaces
		
		// get width/height:
		if(p == 0){
			parsedMap.width = parseInt(lineValues[0], 10);
			parsedMap.height = parseInt(lineValues[1], 10);
			continue;
		}
		
		let parsedRowArr = [];
		
		// process cell values:
		for(let i = 0; i < lineValues.length; i++){
			//console.log(lineValues[i]);
			let info = getMapValueInfo(lineValues[i]);
			//console.log(info);
			parsedRowArr.push(info);
		}
		
		parsedMap.data.push(parsedRowArr);
		//console.log(lineValues);
	}
	
	console.log(parsedMap);
	
	loadedmap = parsedMap;
}




// {type: land/water, object: null/tree/peasant, owner: 0-6}
function getMapValueInfo(valueStr){
	// set default type to land, so we dont need to modify it for player owned tiles.
	let info = {type: "land", object: null, owner: 0};
	let value = parseInt(valueStr, 10);
	switch(value){
		case -1:
			info.type = "water";
		break;
		case 241:
			info.owner = 0;
		break;
		case 243:
			info.owner = 0;
			info.object = "tree";
		break;
		case 1:
			info.owner = 1;
		break;
		case 4:
			info.owner = 1;
			info.object = "peasant";
		break;
		case 41:
			info.owner = 2;
		break;
		case 44:
			info.owner = 2;
			info.object = "peasant";
		break;
		case 81:
			info.owner = 3;
		break;
		case 84:
			info.owner = 3;
			info.object = "peasant";
		break;
		case 121:
			info.owner = 4;
		break;
		case 124:
			info.owner = 4;
			info.object = "peasant";
		break;
		case 161:
			info.owner = 5;
		break;
		case 164:
			info.owner = 5;
			info.object = "peasant";
		break;
		case 201:
			info.owner = 6;
		break;
		case 204:
			info.owner = 6;
			info.object = "peasant";
		break;
	}
	return info;
}


function loadParsedMap(parsedMap){
	let width = parsedMap.width+8;
	let height = parsedMap.height+8;
	console.error(parsedMap);
	for (let q = -Math.floor(width/2), y = 0; q <= Math.floor(width/2); q++, y++) {
		let roff = 0;
	
		for (let r = -Math.floor(height/2), x = 0; r <= Math.floor(height/2); r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let isEven = ((x%2) == 0);
			let add1 = isEven ? 1 : 0;
			let xx = x; // todo: fix reading rows, has to place different offsets...
			//xx = (parsedMap.width-1)-x;
			let yy = y;
			
			//yy = (parsedMap.height-1)-y;
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info = parsedMap.data[yy][xx];
				let tree = null;
				if(info.object == "tree"){
					tree = "tree";
				}
				setTileAt(q-roff, r, { type: info.type, ownerId: null, object: tree, savings: 0 });
			}
			
	
			
		}
	}
}



function generateMap(width, height) {
	width = loadedmap.width+8;
	height = loadedmap.height+8;
	
		
	GAME_STATE.settings.mapWidth = width;
	GAME_STATE.settings.mapHeight = height;
	
	loadParsedMap(loadedmap);
	
	console.log(`Generating map ${width}x${height}`);
	/*
	GAME_STATE.map.tiles = {};
	
	
	
	// Create a "rhombus" shape of hexes
	for (let q = -Math.floor(width/2); q <= Math.floor(width/2); q++) {
		for (let r = -Math.floor(height/2); r <= Math.floor(height/2); r++) {
			// This creates a rectangle in axial coords
			// We can refine this later
			setTileAt(q, r, { type: 'water', ownerId: null, object: null, savings: 0 });
		}
	}
	
	// Add 15x15 land square in middle
	const landSize = 15;
	const qStart = -Math.floor(landSize/2);
	const rStart = -Math.floor(landSize/2);
	
	for (let q = qStart; q < qStart + landSize; q++) {
		for (let r = rStart; r < rStart + landSize; r++) {
			const tile = getTileAt(q, r);
			if (tile) {
				tile.type = 'land';
			}
			// add random trees:
			if(Math.random() < 0.1){
				tile.object = 'tree';
			}
		}
	}
	*/
}

function spawnPlayers() {
	const playersToSpawn = GAME_STATE.players.filter(p => !p.isSpectator && !p.isAI);
	let landHexes = [];
	
	// Get all available land hexes
	for (const key in GAME_STATE.map.tiles) {
		if (GAME_STATE.map.tiles[key].type === 'land') {
			const [q, r] = key.split(',').map(Number);
			landHexes.push({q, r});
		}
	}
	
	// Shuffle
	landHexes.sort(() => Math.random() - 0.5);
	
	for (const player of playersToSpawn) {
		let spawnHex = null;
		let neighbors = [];
		
		// Find a spawn point with at least 4 land neighbors
		let found = false;
		while (!found && landHexes.length > 0) {
			spawnHex = landHexes.pop();
			neighbors = getHexNeighbors(spawnHex.q, spawnHex.r)
				.map(h => ({ ...h, tile: getTileAt(h.q, h.r) }))
				.filter(h => h.tile && h.tile.type === 'land');
			
			if (neighbors.length >= 4) {
				found = true;
			}
		}
		
		if (!found) {
			console.warn(`Could not find ideal spawn for ${player.name}`);
			// Just use the last one we tried
			if (!spawnHex) continue; // No land hexes left?
		}
		
		// Claim center hex
		const centerTile = getTileAt(spawnHex.q, spawnHex.r);
		centerTile.ownerId = player.id;
		centerTile.object = null;
		centerTile.savings = GAME_STATE.settings.startingMoney / 5; // Split money
		
		// Claim 4 neighbors
		for (let i = 0; i < 4; i++) {
			const n = neighbors[i];
			n.tile.ownerId = player.id;
			n.tile.object = null;
			n.tile.savings = GAME_STATE.settings.startingMoney / 5;
		}
		
		// Add Peasant on one of them
		const soldierHex = neighbors[0];
		const peasant = {
			id: getUID(),
			type: 'Peasant',
			ownerId: player.id,
			level: 1,
			q: soldierHex.q,
			r: soldierHex.r,
			hasMoved: false
		};
		GAME_STATE.units.push(peasant);
	}
}

function startGame() {
	if (!localPlayer.isHost) return;
	
	console.log("Starting game...");
	
	if (loadedGameState) {
		console.log("Starting from loaded state.");
		GAME_STATE = loadedGameState;
		GAME_STATE.gameStarted = true;
		
		// Match current players to loaded players
		const newPlayerList = [];
		const loadedPlayers = GAME_STATE.players.filter(p => !p.isSpectator);
		
		// Add all current spectators
		for (const p of connections.keys()) {
			const player = getPlayer(p);
			if (player.isSpectator) newPlayerList.push(player);
		}
		if (localPlayer.isSpectator) newPlayerList.push(localPlayer);
		
		// Match players
		for (const loadedP of loadedPlayers) {
			// Find a current player who 'took' this name
			const matchingCurrentPlayer = [...GAME_STATE.players, localPlayer].find(
				p => p.name === loadedP.name && p.color === loadedP.color && !p.isSpectator
			);
			
			if (matchingCurrentPlayer) {
				// This player takes the slot
				loadedP.id = matchingCurrentPlayer.id; // Assign new PeerID
				newPlayerList.push(loadedP);
			} else {
				// No one took this slot. Mark as AI or disconnected?
				// For now, let's just keep them.
				loadedP.isAI = true; // Mark as AI for now
				newPlayerList.push(loadedP);
			}
		}
		GAME_STATE.players = newPlayerList;
		
	} else {
		console.log("Starting new game.");
		// Set settings from inputs
		GAME_STATE.settings.mapWidth = parseInt(mapWidthInput.value);
		GAME_STATE.settings.mapHeight = parseInt(mapHeightInput.value);
		GAME_STATE.settings.startingMoney = parseInt(startMoneyInput.value);
		
		// Filter out spectators from play
		GAME_STATE.players = GAME_STATE.players.filter(p => p.id === localPlayer.id || connections.has(p.id));
		const playingPlayers = GAME_STATE.players.filter(p => !p.isSpectator);
		
		// Assign first colors to any uncolored players
		let colorIdx = 0;
		const usedColors = GAME_STATE.players.map(p => p.color);
		for (const p of playingPlayers) {
			if (!p.color) {
				while(usedColors.includes(PLAYER_COLORS[colorIdx])) {
					colorIdx++;
				}
				p.color = PLAYER_COLORS[colorIdx];
				usedColors.push(p.color);
			}
		}
		
		GAME_STATE.gameStarted = true;
		generateMap(GAME_STATE.settings.mapWidth, GAME_STATE.settings.mapHeight);
		spawnPlayers();
		
		let myPlayer = getMyPlayer();
		if(myPlayer.isSpectator){
			hideUiRight();
		}
		
		// Set initial turn
		GAME_STATE.turn.currentPlayerIndex = 0;
		GAME_STATE.turn.turnNumber = 0;
		advanceToNextPlayer();
	}
	
	// Clear undo stack
	currentTurnActions = [];
	
	// Save this game state
	saveGameToDB(GAME_STATE);
	
	// Broadcast start
	// At the very end of the function, AFTER broadcast('game_start'):
	broadcast({ type: 'game_start', state: GAME_STATE });
	
	// Send initial savings to all players
	GAME_STATE.players.forEach(p => {
		if (!p.isSpectator) {
			updatePlayerSavings(p.id);
		}
	});
}


// =================================================================
// --- EVENT LISTENERS
// =================================================================
window.addEventListener('DOMContentLoaded', () => {
	initDB();
	initPeerJS();
	loadImages();
	
	hostBtn.disabled = true;
	joinBtn.disabled = true;
	spectateBtn.disabled = true;
	
	// --- Start Page ---
	hostBtn.onclick = hostGame;
	joinBtn.onclick = () => joinGame(false);
	spectateBtn.onclick = () => joinGame(true);
	playerNameInput.onchange = (e) => localPlayer.name = e.target.value;

	// --- Host Page ---
	mapWidthInput.onchange = () => GAME_STATE.settings.mapWidth = parseInt(mapWidthInput.value);
	mapHeightInput.onchange = () => GAME_STATE.settings.mapHeight = parseInt(mapHeightInput.value);
	startMoneyInput.onchange = () => GAME_STATE.settings.startingMoney = parseInt(startMoneyInput.value);
	
	spectateHostBtn.onclick = () => {
		localPlayer.isSpectator = !localPlayer.isSpectator;
		localPlayer.color = localPlayer.isSpectator ? SPECTATOR_COLOR : PLAYER_COLORS[0];
		spectateHostBtn.classList.toggle('active', localPlayer.isSpectator);
		broadcastLobbyState();
	};
	
	loadGameBtn.onclick = () => {
		if (loadedGameState) {
			// Unload
			loadedGameState = null;
			loadGameBtn.textContent = 'Load Game';
			loadedGameInfoContainer.style.display = 'none';
		} else {
			// Load
			const roomName = roomNameInput.value;
			loadGameFromDB(roomName, (state) => {
				if (state) {
					loadedGameState = state;
					loadGameBtn.textContent = 'Unload Game';
					loadGameDate.textContent = new Date(state.saveDate).toLocaleString();
					loadGamePlayersList.innerHTML = '';
					state.players.filter(p => !p.isSpectator).forEach(p => {
						const li = document.createElement('li');
						li.textContent = `${p.name}`;
						li.style.color = p.color;
						li.className = 'loaded-player';
						li.onclick = () => {
							if (li.classList.contains('taken')) return;
							
							// Mark others as not taken
							loadGamePlayersList.querySelectorAll('li').forEach(item => {
								if (item.textContent.endsWith(' (taken)')) {
									const originalName = item.dataset.name;
									const pData = loadedGameState.players.find(lp => lp.name === originalName);
									if (pData) pData.isTaken = false;
									item.textContent = originalName;
									item.classList.remove('taken');
								}
							});
							
							// Take this one
							localPlayer.name = p.name;
							localPlayer.color = p.color;
							playerNameInput.value = p.name;
							localPlayer.isSpectator = false;
							spectateHostBtn.classList.remove('active');
							p.isTaken = true; // Mark in loaded state
							li.textContent = `${p.name} (taken)`;
							li.dataset.name = p.name;
							li.classList.add('taken');
							broadcastLobbyState(); // Update others
						};
						loadGamePlayersList.appendChild(li);
					});
					loadedGameInfoContainer.style.display = 'block';
				} else {
					alert('No saved game found for this room name.');
				}
			});
		}
	};
	
	startGameBtn.onclick = startGame;
	
	// --- Lobby Page ---
	lobbyPlayerNameInput.onchange = (e) => {
		localPlayer.name = e.target.value;
		sendToHost({
			type: 'player_update',
			name: localPlayer.name,
			color: localPlayer.color
		});
	};
	
	// --- Game Page ---
	window.onresize = initCanvas;
	canvas.addEventListener('wheel', handleWheel, { passive: false });
	canvas.addEventListener('mousedown', handleCanvasMouseDown);
	canvas.addEventListener('mousemove', handleCanvasMouseMove);
	canvas.addEventListener('mouseup', handleCanvasMouseUp);
	canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
	canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
	canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
	
	chatInput.onkeydown = (e) => {
		if (e.key === 'Enter' && chatInput.value.trim() !== '') {
			sendToHost({ type: 'chat', message: chatInput.value.trim() });
			chatInput.value = '';
		}
	};
	
	buildSoldierBtn.onclick = () => openBuildPopup('soldier');
	buildCastleBtn.onclick = () => openBuildPopup('castle');
	buildPopupClose.onclick = () => {
		buildPopup.style.display = 'none';
		placingUnit = null;
	};
	
	endTurnBtn.onclick = () => {
		if (isMyTurn()) {
			sendToHost({ type: 'action_end_turn' });
		}
	};
	
	undoBtn.onclick = () => {
		if (isMyTurn()) {
			sendToHost({ type: 'action_undo' });
		}
	};

});
</script>
</body>
</html>