<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="site.webmanifest">
	
    <title>Castle Wars</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
	
	<script src="config.js"></script> <!-- LOCAL=true on public, false on my pc config -->

	<script>
	
	/*

game logic:
click next turn:
savings = savings + (income - wages)

initially: (1 peasant (wage 3))

savings: 21
income: 5
wages: -3
balance: 23

click buy knight (cost 20, wage 8) ->
savings: 1
income: 5
wages: -11
balance: -5

place knight: (1 peasant, 1 knight)
*all units dies*
savings: 0
income: 5
wages: 0
balance: 5

makes little sense to allow placing unit if the result is everyone dying. 
unless you claim new hex which increases your income by 1, and makes income-wages zero. 
or if joining two pools together to get the balance positive.


	
	*/
	//////////////////////////////////////////////
	//
	//  force to public server here for quick testing:
	//
	//window.APP_CONFIG.LOCAL = false; // this is true on my pc by default. on release version false.
	</script>
	


    
<style>

:root {
	--bg-color: #000000;
	--text-color: #eee;
	--border-color: #444;
	--input-bg: #1d1d1d;
	--btn-bg: #1d1d1d;
	--btn-hover-bg: #2a2a2a;
	--danger-color: #ff3b30;
	--warn-color: #ffcc00;
	--spec-color: #ffffff;
	--unclaimed-color: #555;
	--water-color: #003366;
	--land-color: #224422;
}

* {
	box-sizing: border-box;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
	---user-select: none;
}

html, body {
	margin: 0;
	padding: 0;
	width: 100%;
	----height: 100%;
	----overflow: hidden;
	background-color: var(--bg-color);
	color: var(--text-color);
}

.page {
	display: none;
	width: 100%;
	height: 100%;
	----padding: 20px;
	overflow-y: auto;
	flex-direction: column;
	align-items: center;
	justify-content: center;
}

.page.active {
	display: flex;
}

.container {
	width: 100%;
	max-width: 410px;
	padding: 8px;
	---background: #1a1a1a;
	---border-radius: 8px;
	---border: 1px solid var(--border-color);
}

h1, h2, h3 {
	margin-top: 0;
	text-align: center;
	font-weight: 500;
}

input[type="text"], input[type="number"], select {
	width: 100%;
	padding: 12px;
	margin-bottom: 10px;
	background: var(--input-bg);
	border: 1px solid var(--border-color);
	color: var(--text-color);
	border-radius: 6px;
	font-size: 16px;
}


button {
	width: 100%;
	padding: 12px;
	margin-bottom: 10px;
	background: var(--btn-bg);
	color: var(--text-color);
	border: none;
	border-radius: 6px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
}

.gamebutton {
	padding:4px;
	
	padding-top: 2px;

	font-size: 15px;
	height: 47px;
}


.gamebutton.active {
	---background-color: #1e8117;
}



#build-soldier-btn,
#build-castle-btn {
	/* prevents annoying ghosting of hover effect that is visible under the build menu for a short time */
	-webkit-tap-highlight-color: transparent;
}

button:hover {
	background: var(--btn-hover-bg);
}


button:active {
	---transform: scale(0.98);
}

button.primary {
	background-color: #00428e;
	color: white;
}

button.primary:hover {
	background-color: #1155cc;
}

button.danger {
	background-color: var(--danger-color);
	color: white;
}

button.toggle-btn.active {
	background-color: var(--warn-color);
	color: #000;
}

label {
	display: block;
	margin-bottom: 5px;
	font-size: 14px;
	color: #aaa;
}

.input-group {
	display: flex;
	gap: 10px;
	margin-bottom: 15px;
}

.input-group > div {
	flex: 1;
}

.player-list {
	width: 100%;
	---padding: 10px;
	background: #000000;
	border:1px solid #333333;
	border-radius: 6px;
	height: 100px;
	overflow-y:auto;
	----margin-top: 15px;
}

.player-list-item {
	padding: 5px;
	border-bottom: 1px solid var(--border-color);
	

	word-break: break-all;
}
.player-list-item:last-child {
	border-bottom: none;
}

.color-picker {
	display: flex;
	flex-wrap: wrap;
	gap: 7px;
	margin-bottom: 15px;
}

.color-box {
	width: 37px;
	height: 37px;
	border-radius: 50%;
	cursor: pointer;
	---border: 2px solid transparent;
	position: relative;
	display: inline-block;
}

.color-box.selected {
	border-color: white;
	box-shadow: 0 0 8px white;
}

.color-box.disabled {
	---opacity: 0.3;
	cursor: not-allowed;
	
	background: repeating-linear-gradient(
		45deg, /* angle of the stripes */
		rgba(0, 0, 0, 0.5), /* dark stripe color with transparency */
		rgba(0, 0, 0, 0.6) 4px,
		transparent 4px,
		transparent 7px
	);
}



.loaded-game-info {
	font-size: 14px;
	background: var(--input-bg);
	padding: 10px;
	border-radius: 4px;
	margin-bottom: 10px;
}

.loaded-player {
	cursor: pointer;
}
.loaded-player:hover {
	text-decoration: underline;
}
.loaded-player.taken {
	cursor: not-allowed;
	opacity: 0.5;
	text-decoration: line-through;
}

/* --- GAME PAGE --- */
#game-page {
	padding: 0;
	margin: 0;
	width: 100%;
	height: 100%;
	background: #000;
	user-select: none;
}

#game-canvas {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

#game-ui {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	display: flex;
	justify-content: space-between;
	padding: 0px;
}

.ui-panel {
	pointer-events: auto;
	background: rgba(0, 0, 0, 0.8);
	backdrop-filter: blur(5px);
	padding: 2px 6px 2px 6px;
	max-height: 90vh;
	overflow-y: auto;
}

.ui-panel-trans {
	pointer-events: auto;
	----padding: 2px 6px 2px 6px;
	---max-height: 90vh;
	---overflow-y: auto;
}

#debug-ui {
	pointer-events: none;
	padding-right: 6px;
	position: absolute;
	top: 0;
	right: 0;
}

#ui-left {
	display: none; /*flex when visible*/
	flex-direction: column;
	gap: 0px;
	width: 200px;
}

#ui-right {
	position:absolute;
	bottom:0;
	right:0;
	display: flex;
	flex-direction: column; /* stack rows vertically */
	---gap: 10px;

	max-width: 200px;
	width: 100%;
	---height: 96px; /* let it grow naturally */
	
	overflow-y: hidden;
	
	border-top-left-radius: 8px;
}

/* Top row: texts side by side */
#ui-right .top-row {
	display: flex;
	flex-direction: column;
	justify-content: space-between; /* turn-info left, savings right */
	align-items: flex-end;
	gap: 0px;
	padding-right:10px;
	margin-bottom: 10px;
}

.ui-panel-controls {
	border-top-left-radius: 10px;
	padding-top: 7px;
}

#turn-info {
	padding: 4px;
	position: absolute;
	bottom: 0;
	left: 0;
	pointer-events: none;
}

/* Optional: style buttons as a row */
#ui-right .button-row {
	display: flex;
	flex-direction: row;
	gap: 10px;
}

/* Make buttons stretch evenly */
#ui-right .button-row button {
	flex: 1;  /* each button takes equal width */
}

#player-ui-list {
	max-height: 133px;
	
    border-top: 1px solid #3e3e3e;
    border-bottom: 1px solid #3e3e3e;
}

#player-ui-list .player-list-item {
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.player-turn-indicator {
	display: inline-block;
	width: 10px;
	height: 10px;
	border-radius: 50%;
	background: var(--warn-color);
	margin-right: 5px;
	visibility: hidden;
}

.player-list-item.current-turn .player-turn-indicator {
	visibility: visible;
}

#chat-ui {
	display: flex;
	flex-direction: column;
	height: 145px;

	border-bottom-right-radius: 8px;
	
	padding-left: 4px;
}

#chat-messages {
	flex-grow: 1;
	overflow-y: auto;
	font-size: 13px;
	padding: 5px;
	background: rgba(0,0,0,0.2);
	border-radius: 4px;
	margin-bottom: 5px;
	margin-top: 3px;

	user-select: text !important;
}

.msgfromtext, .msgtext {
	user-select: text !important;
}

#chat-input {
	width: 100%;
	padding: 8px;
	font-size: 14px;
	margin-bottom: 4px;
}

.smalltitle {
	text-align:center;
	margin-bottom:5px;
	font-size:18px;
}



#build-popup-close {
	margin-top: 10px;
	width: 66px;
	height: 42px;
	margin-left: 121px;
	padding: 5px 4px 5px 4px;
}

#build-popup {
	position: absolute;
	bottom: 0;
	right: 0;
	/* transform: translate(-50%, -50%); */
	z-index: 100;
	pointer-events: auto;
	width: 200px;

	border-top-left-radius: 12px;
}

.build-item {
	display: flex;
	justify-content: space-between;
	
	padding: 2px 10px 2px 10px;
	background: var(--btn-bg);
	border-radius: 4px;
	margin-bottom: 5px;
	cursor: pointer;
}

.build-item:hover {
	background: var(--btn-hover-bg);
}

.build-item.disabled {
	opacity: 0.4;
	cursor: not-allowed;
	background: #222;
}

.build-item .cost {
	color: var(--warn-color);
	padding-top: 5px;
}


button.redbutton {
	background-color: #d03535;
}

button.redbutton:hover {
	background-color: #ca4747;
}

.savedgames-popup-overlay {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	justify-content: center;
	align-items: center;
}

.savedgames-popup {
	background: black;
	border-radius: 12px;
	width: 100%;

	max-height: 100%;
	height: 100%;
	overflow-y: auto;
	position: relative;
	padding: 3px;
	box-shadow: 0 5px 20px rgba(0,0,0,0.2);
	----animation: fadeIn 0.2s ease;

	padding-top: 63px;
}

.savedgames-item {
	border-radius: 8px;
	text-align: center;
	cursor: pointer;
	---transition: 0.15s;

	margin-bottom: 8px;
	padding-top: 5px;
	padding-bottom: 5px;
}

.savedgames-item:hover {
	background: #333333;
	---transform: scale(1.03);
}

.savedgames-item img {
	width: 95%;
	border-radius: 6px;
}

.savedgames-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(156px, 1fr));
	gap: 0px;
}



/* Popup backdrop */
.popup-overlay {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	justify-content: center;
	align-items: center;
}

/* Popup box */
.popup {
	background: black;
	border-radius: 12px;
	width: 100%;

	max-height: 100%;
	height: 100%;
	overflow-y: auto;
	position: relative;
	padding: 3px;
	box-shadow: 0 5px 20px rgba(0,0,0,0.2);
	---animation: fadeIn 0.2s ease;

	padding-top: 128px;
}

@keyframes fadeIn {
	from { opacity: 0; transform: scale(0.95); }
	to { opacity: 1; transform: scale(1); }
}


.popup-top-bar {
	position: fixed;
	top: 0;

	border: none;
	font-size: 29px;

	width: 100%;
	padding: 0;

	background-color:rgba(0,0,0, 1);
}

.popup-title {
	font-size:24px;
	text-align:center;
	padding:10px;
}

/* Close (X) button */
.popup-close {
	position: absolute;
	right: 0;
	width: 50px;
	height: 43px;
	font-size: 34px;
	line-height: 21px;
	padding-top: 6px;
}

/* Category buttons */
.category-tabs {
	display: flex;
	gap: 8px;
	margin-bottom: 16px;
	margin-top: 15px;
}

.category-btn {
	padding: 8px 16px;
	border: 1px solid #333;
	background: #338;
	cursor: pointer;
	border-radius: 8px;
	font-weight: bold;
	color: #c5bef1;
}

.category-btn:hover {
	background: #66B;
}

.category-btn.active {
	background: #007bff;
	color: white;
	border-color: #007bff;
}

/* Map list */

.map-item {
	border-radius: 8px;
	text-align: center;
	cursor: pointer;
	---transition: 0.15s;

	margin-bottom: 8px;
	padding-top: 5px;
	padding-bottom: 5px;

}

.map-item:hover {
	background: #333333;
	---transform: scale(1.03);
}

.map-item img {
	width: 95%;
	border-radius: 6px;
}

.map-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(156px, 1fr));
	gap: 0px;
}


#loaded-map {
	border: 1px solid #ccc;
	border-radius: 6px;
}



#top-float-ui {
	display: none;
	flex-direction: column;
	padding-left: 4px;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 57px;
	pointer-events: none;
}

#top-float-ui-messages {
	flex-grow: 1;
	overflow-y: hidden;
	font-size: 15px;
	text-shadow: 2px 2px 1px rgba(0, 0, 0, 1), 0px 0px 2px rgba(0, 0, 0, 1), 0px 0px 4px rgba(0, 0, 0, 1);
	color:white;
}




input.disabled {
	cursor: not-allowed;
}


/* Popup container */
#image-popup {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
}

/* Visible state */
#image-popup.active {
	display: flex;
}

/* Enlarged image style */
#image-popup img {
	width: 90vw;          /* take up 90% of viewport width */
	height: auto;         /* maintain aspect ratio */
	max-height: 90vh;     /* prevent overflowing vertically */
	object-fit: contain;  /* ensures the image scales proportionally */
	border-radius: 8px;
}


#end-turn-btn[disabled] {
	background-color:var(--btn-bg);
}

#undo-btn[disabled] {
	background-color:var(--btn-bg);
}


#build-soldier-btn {
	background-image: url('images/orig-scaled/128x128/soldier1.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position-x: 4px;
	background-position-y: -2px;
}

#build-castle-btn {
	background-image: url('images/orig-scaled/128x128/castle1.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position-x: 4px;
	background-position-y: -2px;
}

#undo-btn {
	background-image: url('images/ui/undo.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

#toggle-ui-btn {
	background-image: url('images/ui/chat.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

#sell-unit-btn {
	background-image: url('images/ui/sell.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

#end-turn-btn {
	background-image: url('images/ui/endturn.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

</style>
</head>
<body>

<input type="hidden" id="dirty-flag">

<div id="map-popup-overlay" class="popup-overlay">
	<div class="popup" id="map-popup">
		
		<div class="popup-top-bar">
			<div class="input-group">
				<div class="popup-title">Load map</div>
				<button class="popup-close" id="popup-close">&times;</button>
			</div>
			<div class="category-tabs">
				<button class="category-btn active" data-category="small">Small</button>
				<button class="category-btn" data-category="normal">Normal</button>
			</div>
			
		</div>
		<div class="map-list" id="map-list"></div>
	</div>
</div>

<div id="savedgames-popup-overlay" class="savedgames-popup-overlay">
	<div class="savedgames-popup" id="savedgames-popup">
		
		<div class="popup-top-bar">
			<div class="input-group">
				<div class="popup-title">Load game</div>
				<button class="popup-close" id="savedgames-popup-close">&times;</button>
			</div>
		</div>
		<div class="savedgames-list" id="savedgames-list"></div>
	</div>
</div>



<div id="image-popup">
	<div style="padding:5px">Map preview</div>
	<img id="popup-img" src="" alt="Enlarged view">
</div>


<div id="start-page" class="page active">
	<div class="container">
		<h1>Castle Wars</h1>
		<label for="player-name">Player Name</label>
		<input type="text" id="player-name" value="Player">
		
		<label for="game-name-input">Game Room Name</label>
		<input type="text" id="game-name-input" value="default-room">
		<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
			<label for="server-name-input">Server:</label>
			<select id="server-name-input">
			
			</select>
		</div>
		<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
			<label for="games-list-input">Gamelist:</label>
			<select id="games-list-input">
			
			</select>
		</div>
		<button id="host-btn" class="primary">Host Game</button>
		<button id="join-btn">Join Game</button>
		<button id="spectate-btn">Join as Spectator</button>
		<div id="connection-status" style="text-align: center; margin-top: 10px; font-size: 14px;">Initializing...</div>
	</div>
</div>


<div id="host-page" class="page">
	<div class="container">
		<h2 id="host-room-name-title">Hosting: default-room</h2>
		
		<label for="host-room-player-name">Your Name</label>
		<div class="input-group">
			<input type="text" id="host-room-player-name" value="Player"  style="flex: 3;">
			<button id="spectate-host-btn" class="toggle-btn" style="flex: 1;">Spectate</button>
		</div>
		

		<div class="input-group">
			<div style="flex:5">
				<label>Choose Color</label>
				<div id="host-room-color-picker" class="color-picker"></div>
			</div>
			<div style="flex: 2;">
				<label>Joined Players</label>
				<div id="host-player-list" class="player-list"></div>
			</div>
		</div>
		
		<!-- todo: later when random map generator is added, or map editor, then enable these inputs: -->
		<div class="input-group" style="display:none">
			<div>
				<label for="map-width">Map Width</label>
				<input type="number" id="map-width" value="24">
			</div>
			<div>
				<label for="map-height">Map Height</label>
				<input type="number" id="map-height" value="24">
			</div>
		</div>
		
		<div class="input-group">
			<button id="add-ai-btn">Add AI</button>
		</div>
		
		<div style="display:none">
			<label for="start-money">Starting Money</label>
			<input type="number" id="start-money" value="1000">
		</div>


		
		<div class="input-group">
			<button id="load-random-map-btn">Random map</button>
			<button id="load-map-btn">Select Map</button>
			<button id="load-game-btn" style="display:block">Load Game</button>
		</div>
		
		<div class="input-group">
			<div style="width:110px; flex:0 0 auto;">
				<label for="loaded-map">Loaded map</label>
				<img id="loaded-map" src="" width="100" height="100">
			</div>
			<div>
				<label for="map-scale">Map scale</label>
				<input type="number" id="map-scale" value="1" min="1" max="4">
				Scaling resizes the map by factor above.
			</div>
		</div>
		
		<div id="loaded-game-info-container" class="loaded-game-info" style="display: none;">
			<p><strong>Saved Game:</strong> <span id="load-game-date"></span></p>
			<p><strong>Players:</strong></p>
			<ul id="load-game-players"></ul>
		</div>
		
		<button id="start-game-btn" class="primary">Start Game</button>
		

	</div>
</div>


<div id="lobby-page" class="page">
	<div class="container">
		<h2 id="lobby-room-name-title">Joining: default-room</h2>
		

		<label for="lobby-player-name">Your Name</label>
		<input type="text" id="lobby-player-name" value="Player">
		
		<div class="input-group">
			<div style="flex:5">
				<label>Choose Color</label>
				<div id="lobby-color-picker" class="color-picker"></div>
			</div>
			<div style="flex: 2;">
				<label>Joined Players</label>
				<div id="lobby-player-list" class="player-list"></div>
			</div>
		</div>
		
		<div id="lobby-game-settings" style="display:none">
			<p><strong>Map:</strong> <span id="lobby-map-size">...</span></p>
			<p><strong>Money:</strong> <span id="lobby-start-money">...</span></p>
		</div>
		
		<div class="input-group">
			<div style="width:110px; flex:0 0 auto;">
				<label for="lobby-loaded-map">Loaded map</label>
				<img id="lobby-loaded-map" src="" width="100" height="100">
			</div>
			<div>
				<label for="lobby-map-scale">Map scale</label>
				<input type="number" id="lobby-map-scale" class="disabled" value="1" max="4" disabled>
				Scaling resizes the map by factor above.
			</div>
		</div>
		
		
		
		<p id="lobby-status" style="text-align: center;">Waiting for host to start...</p>
	</div>
</div>


<div id="game-page" class="page">
	<canvas id="game-canvas"></canvas>
	
	<div id="top-float-ui">
		<div id="top-float-ui-messages"></div>
	</div>
	
	<div id="turn-info"></div>
	
	<div id="game-ui">
		<div id="ui-left">
			<div id="ui-menu" class="ui-panel">
				<div class="input-group">
					<div style="flex:4">
						<button id="quit-game-btn" class="gamebutton redbutton">Quit game</button>
					</div>
					<div style="flex: 1;">
						<button id="refresh-canvas" class="gamebutton" title="refresh canvas">↺</button>
					</div>
				</div>
			</div>
			
			<div id="player-ui-list" class="ui-panel"></div>
			<div id="chat-ui" class="ui-panel">
				<div id="chat-messages"></div>
				<input type="text" id="chat-input" placeholder="Type message..." disabled>
			</div>
			<div id="debug-ui">
			</div>
		</div>
		
		<div id="ui-right">
			
			<div>
				<div class="top-row" id="ui-right-top-row-id">
					<div id="player-savings">Savings: 0</div>
					<div id="player-income">Income: 0</div>
					<div id="player-wages">Wages: 0</div>
					<div id="player-balance">Balance: 0</div>
				</div>
			</div>
			
			<div class="ui-panel ui-panel-controls">

				<div class="button-row" id="ui-right-button-row1-id">
					<button id="sell-unit-btn" class="gamebutton" title="Sell warrior"></button>
					<button id="build-soldier-btn" class="gamebutton" title="Recruit warrior"></button>
					<button id="build-castle-btn" class="gamebutton" title="Build castle"></button>
				</div>
				<div class="button-row" id="ui-right-button-row2-id">
					<button id="end-turn-btn" class="gamebutton primary" title="End turn"></button>
					<button id="undo-btn" class="gamebutton redbutton" title="Undo"></button>
					<button id="toggle-ui-btn" class="gamebutton" title="Open chat"></button>
				</div>
			</div>
		</div>
		
	</div>
	
	<div id="build-popup" class="ui-panel" style="display: none;">
		<div id="build-popup-title" class="smalltitle"></div>
		<div id="build-popup-list"></div>
		<button id="build-popup-close" class="redbutton">Cancel</button>
	</div>
</div>



<script>

let APP_NAME = "castlewars"; // needed to filter these games from open rooms list. minesweeper is also on same peerjs server.

let selectedServerIndex = 1; // default to render.com

// select local server if local server is forced in config:
if(window.APP_CONFIG.LOCAL == true){
	selectedServerIndex = 0;
}

// onlyLocal = only visible if window.APP_CONFIG.LOCAL = true
// serverlist
let serversList = [
	{name: "local", onlyLocal: true, serverListEnabled: true, 
		fetchUrl: "http://localhost:9000",
		config: {
			host: 'localhost',
			port: 9000,
			path: '/peerjs',
			secure: false,
			debug: 2,
	}}, // dont show this if testing locally.
	{name: "render.com", onlyLocal: false, serverListEnabled: true, 
		fetchUrl: "https://peerjs-server-j9al.onrender.com",
		config: {
			host: 'peerjs-server-j9al.onrender.com',
			path: '/peerjs',
			secure: true,
			debug: 2,
	}},
	{name: "peerjs.com", onlyLocal: false, serverListEnabled: false, config: {
		debug: 2
	}},
];


let eventSource = null;

function connectToServer(serverUrl) {
	// 1. Close existing EventSource if any
	if (eventSource) {
		eventSource.close(); // stops listening and frees resources
		console.log('Closed previous EventSource');
	}

	// 2. Create new EventSource
	eventSource = new EventSource(`${serverUrl}/events`);

	// 3. Listen for messages
	eventSource.onmessage = (event) => {
		if (event.data === 'games_updated') {
			console.log('Games updated — reloading list...');
			fetchOpenGames(selectedServerIndex); // or your own function
		}
	};

	eventSource.onerror = (err) => {
		console.error('EventSource error', err);
	};

	console.log('Connected to EventSource at', serverUrl);
}






const gamesListInput = document.getElementById("games-list-input");

gamesListInput.addEventListener("change", function() {
	const selectedValue = this.value;
	console.log("Selected game:", selectedValue);
	gameNameInput.value = selectedValue;
});


async function fetchOpenGames(serverIndex) {
	let server = serversList[serverIndex];

	if (!server.serverListEnabled) return;

	try {
		const res = await fetch(`${server.fetchUrl}/games`);

		// Check for HTTP errors (non-2xx responses)
		if (!res.ok) {
			throw new Error(`Server returned ${res.status} ${res.statusText}`);
		}

		const games = await res.json();
		let totalGames = 0;//Object.keys(games).length;
		for (const key in games) {
			if (games.hasOwnProperty(key)) {
				let appName = games[key].appName;
				// only display this game app rooms:
				if(appName === APP_NAME){
					totalGames++;
				}
			}
		}
		console.log('Open games:');
		console.log(games);

		// Clear existing options
		gamesListInput.innerHTML = '';

		// Add header option
		const defaultOption = document.createElement("option");
		defaultOption.value = "";
		defaultOption.textContent = `-- Select game (${totalGames}) --`;
		gamesListInput.appendChild(defaultOption);

		// Add each game
		for (const key in games) {
			if (games.hasOwnProperty(key)) {
				let gameName = games[key].name;
				let appName = games[key].appName;
				// only display this game app rooms:
				if(appName === APP_NAME){
					const option = document.createElement("option");
					option.value = gameName;
					option.textContent = gameName;
					gamesListInput.appendChild(option);
				}
			}
		}
	} catch (error) {
		console.error("Failed to fetch open games:", error);

		// If any error occurs, modify select list
		gamesListInput.innerHTML = '';

		const errorOption = document.createElement("option");
		errorOption.value = "";
		errorOption.textContent = "-- Server down --";
		gamesListInput.appendChild(errorOption);
	}
}






const serverNameInput = document.getElementById("server-name-input");
serverNameInput.value = selectedServerIndex;

serverNameInput.addEventListener("change", function() {
	const selectedValue = this.value;
	console.log("Selected server:", selectedValue);
	selectedServerIndex = selectedValue;
	
	let server = serversList[selectedServerIndex];
	if(server.serverListEnabled){
		connectToServer(server.fetchUrl);
		fetchOpenGames(selectedValue);
	}else{
		gamesListInput.innerHTML = '';
		const option = document.createElement("option");
		option.value = "";  // value attribute
		option.textContent = "-- Not available --";  // visible text
		gamesListInput.appendChild(option);
	}
});


function initServerOpen(){
	let server = serversList[selectedServerIndex];
	if(server.serverListEnabled){
		fetchOpenGames(selectedServerIndex);
		connectToServer(server.fetchUrl);
	}
}

initServerOpen();

serversList.forEach((server, index) => {
	// if onlyLocal is false or config local is true, then add line:
	if(!server.onlyLocal || window.APP_CONFIG.LOCAL){
		const option = document.createElement("option");
		option.value = index;  // value attribute
		option.textContent = server.name;  // visible text
		serverNameInput.appendChild(option);
	}
});


function getSelectedServer(){
	selectedServerIndex = parseInt(serverNameInput.value, 10);
	return serversList[selectedServerIndex];
}



const popupOverlay = document.getElementById('map-popup-overlay');
const popup = document.getElementById('map-popup');


const savedGamesPopupOverlay = document.getElementById('savedgames-popup-overlay');
const savedGamesPopup = document.getElementById('savedgames-popup');


const loadRandomBtn = document.getElementById('load-random-map-btn');
const closeBtn = document.getElementById('popup-close');


const savedGamesCloseBtn = document.getElementById('savedgames-popup-close');



const mapList = document.getElementById('map-list');
const savedGamesList = document.getElementById('savedgames-list');



const categoryBtns = document.querySelectorAll('.category-btn');
const loadedMapImg = document.getElementById('loaded-map');
const lobbyLoadedMapImg = document.getElementById('lobby-loaded-map');



const imagePopup = document.getElementById('image-popup');
const popupImg = document.getElementById('popup-img');

const loadMapBtn = document.getElementById('load-map-btn');
const loadGameBtn = document.getElementById('load-game-btn');


// Show popup on click
loadedMapImg.addEventListener('click', () => {
	popupImg.src = loadedMapImg.src;
	imagePopup.classList.add('active');
});

// Show popup on click
lobbyLoadedMapImg.addEventListener('click', () => {
	popupImg.src = lobbyLoadedMapImg.src;
	imagePopup.classList.add('active');
});

// Hide popup on click
imagePopup.addEventListener('click', (e) => {
	imagePopup.classList.remove('active');
});




const mapScale = document.getElementById('map-scale');

let currentCategory = 'small';



function loadRandomMap(){
	loadMap(((random(0,1) == 0) ? "normal" : "small"), random(0,39));
}

loadRandomBtn.addEventListener('click', () => {
	loadRandomMap();
});



// Open popup
loadMapBtn.addEventListener('click', () => {
	popupOverlay.style.display = 'flex';
	renderMapList(currentCategory);
});

// Close popup (X or outside click)
closeBtn.addEventListener('click', closePopup);
	popupOverlay.addEventListener('click', (e) => {
	if (e.target === popupOverlay) closePopup();
});

function closePopup() {
	popupOverlay.style.display = 'none';
}

// Render map list
function renderMapList(category) {
	mapList.innerHTML = '';
	const maps = customMaps[category];

	maps.forEach((map, index) => {
		const div = document.createElement('div');
		div.className = 'map-item';
		div.innerHTML = `
			<img src="${map.imageData}" alt="${map.name}" title="${map.name}: ${map.width} x ${map.height}">
			<div>Land tiles: ${map.tileCount}</div>
		`;
		// <div>${map.width} x ${map.height}</div>
		div.addEventListener('click', () => {
			loadMap(category, index);
			console.log("map loaded: "+category+index);

			closePopup();
		});
		mapList.appendChild(div);
	});
}

// Handle category switching
categoryBtns.forEach(btn => {
	btn.addEventListener('click', () => {
		categoryBtns.forEach(b => b.classList.remove('active'));
		btn.classList.add('active');
		currentCategory = btn.dataset.category;
		renderMapList(currentCategory);
	});
});

  
  

// Open popup
loadGameBtn.addEventListener('click', async () => {
	if(loadedGameState){
		loadSavedGame(null);
	}else{
		savedGamesPopupOverlay.style.display = 'flex';
		let savedGames = await getAllSavedGames();
		
		renderSavedGamesList(savedGames);
	}
});


// Close popup (X or outside click)
savedGamesCloseBtn.addEventListener('click', closeSavedGamesPopup);
savedGamesPopupOverlay.addEventListener('click', (e) => {
	if (e.target === savedGamesPopupOverlay) closeSavedGamesPopup();
});

function closeSavedGamesPopup() {
	savedGamesPopupOverlay.style.display = 'none';
}

// Render map list
function renderSavedGamesList(savedGames) {
	savedGamesList.innerHTML = '';

	for(let i = 0; i < savedGames.length; i++){
		let map = savedGames[i].gameState.map;
		let roomName = savedGames[i].roomName;
		let date = formatReadableDate(savedGames[i].saveDate);
		
		let style = "";
		if(i == 0){
			style = "color:yellow; font-weight:bold";
		}

		const div = document.createElement('div');
		div.className = 'savedgames-item';
		div.innerHTML = `
			<img src="${map.imageData}" alt="${map.name}" title="${map.name}: ${map.width} x ${map.height}">
			<div style="${style}">${date}</div>
		`;
		div.addEventListener('click', () => {
			loadSavedGame(roomName);
			console.log("game loaded: "+roomName);

			closeSavedGamesPopup();
		});
		savedGamesList.appendChild(div);
	}
}



let useimages = 1;
let GS = 1.16; // hex texture size multi

const MIN_ZOOM = 0.05; // smaller value = more zoomed out
const MAX_ZOOM = 20;   // bigger value = more zoomed in
let zoomMipLevel = 0;




function hexToHSL(hex) {
	// Remove '#' if present
	hex = hex.replace(/^#/, '');

	// Parse r, g, b values
	let bigint = parseInt(hex, 16);
	let r = (bigint >> 16) & 255;
	let g = (bigint >> 8) & 255;
	let b = bigint & 255;

	// Convert RGB to 0..1
	r /= 255;
	g /= 255;
	b /= 255;

	let max = Math.max(r, g, b);
	let min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;

	if (max === min) {
		h = s = 0; // achromatic
	} else {
		let d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	return {
		h: Math.round(h * 360), // 0 - 360 degrees
		s: parseFloat(s.toFixed(3)), // 0 - 1
		l: parseFloat(l.toFixed(3))  // 0 - 1
	};
}


let gameRules = {
	tileIncome: 1,
};
// sounds =
let gameSounds = {
	moveunit:     {filename: "sounds/down.mp3",    gain: 1,   filter: false},
	startmove:    {filename: "sounds/up.mp3",      gain: 1,   filter: false},
	info:         {filename: "sounds/info.mp3",    gain: 1,   filter: false},
	kill:         {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	destroy:      {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	move:         {filename: "sounds/move.mp3",    gain: 1,   filter: false},
	protect:      {filename: "sounds/protect.mp3", gain: 0.6,   filter: false},
	sea:          {filename: "sounds/sea.mp3",     gain: 1,   filter: false},
	
	sell:         {filename: "sounds/sell.mp3",    gain: 0.4,   filter: false},
	claimGrass:   {filename: "sounds/claim-grass.mp3",     gain: 0.4,   filter: false},
	claimTree:    {filename: "sounds/claim-tree.mp3",      gain: 0.1,   filter: false},
	
	// used for: soldier kills castle.
	killCastle:   {filename: "sounds/kill-castle.mp3",     gain: 1,   filter: false},
	
	// used for: knight kills peasant, horse kills knight.
	swordKill:    {filename: "sounds/sword-kill.mp3",      gain: 1,   filter: false},
};

// Preload all sounds
for (const key in gameSounds) {
	loadSound(gameSounds[key].filename); // call your loadSound function for each file
}


const context = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds

function loadSound(src) {
	return fetch(src)
		.then(res => res.arrayBuffer())
		.then(data => context.decodeAudioData(data))
		.then(decoded => {
			soundBuffers[src] = decoded; // store buffer by filename
			return decoded; // also return it
		});
}




function playSound(src) {
	let sound = gameSounds[src];
	if(!sound){
		console.warn("sound not found: "+src);
		return;
	}
	console.warn("playSound: "+src);
	
	const buffer = soundBuffers[sound.filename];
	if (!buffer) return; // sound not loaded yet

	const source = context.createBufferSource();
	source.buffer = buffer;

	// Create a gain node for volume control
	const gainNode = context.createGain();
	gainNode.gain.value = sound.gain; // 1.0 = 100%, 0.5 = 50%, etc.

	if (sound.filter) {
		// Create and use filter
		const filter = context.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = 3000; // let only frequencies below ~3kHz pass

		source.connect(filter);
		filter.connect(gainNode);
	} else {
		// Connect directly
		source.connect(gainNode);
	}

	gainNode.connect(context.destination);
	source.start();
}


// --- Prevent default touch behavior for scrolling/zooming ---
document.body.addEventListener('touchstart', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });

document.body.addEventListener('touchmove', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });

document.body.addEventListener('touchend', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });



// --- CONSTANTS ---
const DB_NAME = 'HexWarlordsDB';
const DB_STORE_NAME = 'savedGames';

const PLAYER_COLORS = [
	'#FF2222', '#FFFF00', '#3333ee', '#FF9500', '#FF2D55', '#34C759',  '#30B0C7', 
	'#ff22dd', '#A2845E', '#eeeeee', '#333333',
];



function randomColor() {
	const h = Math.floor(Math.random() * 360);
	const s = Math.floor(Math.random() * 41) + 60; // 60–100%
	const l = Math.floor(Math.random() * 51) + 50; // 50–100%

	// Convert HSL → RGB → HEX
	const a = s * Math.min(l / 100, 1 - l / 100) / 100;
	const f = n => {
		const k = (n + h / 30) % 12;
		const color = l / 100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
		return Math.round(255 * color).toString(16).padStart(2, '0');
	};

	return `#${f(0)}${f(8)}${f(4)}`;
}


function getNextFreeColor(player = null){
	
	let usedColors = [];
	for(let i = 0; i < gameState.players.length; i++){
		let p = gameState.players[i];
		if(!player || p.id !== player.id){
			if(!p.quitted && !p.isSpectator){
				usedColors.push(p.color);
			}
		}
	}
	
	for(let i = 0; i < PLAYER_COLORS.length; i++){
		let color = PLAYER_COLORS[i];
		if(!usedColors.includes(color)){
			return color;
		}
	}
	console.log("random color returned");
	return randomColor();
}


const SPECTATOR_COLOR = '#FFFFFF';
const UNCLAIMED_COLOR = '#555555';
const WATER_COLOR = '#003366';
const LAND_COLOR = '#224422'; // Unclaimed land
const HEX_SIZE = 40; // Radius of hexagon
const SQRT3 = Math.sqrt(3);


// soldiers =
const SOLDIER_DATA = {
	// listed in this order.
	// visibleName = text shown to user.
	// name = internal name, same as the key (maybe useful later).
	"dragon":  { visibleName: "Dragon",  name: "dragon",  type:"soldier", level: 4, cost: 40, wage: 54, sell: 20, prefix: 'D' },
	"horse":   { visibleName: "Horse",   name: "horse",   type:"soldier", level: 3, cost: 30, wage: 18, sell: 15, prefix: 'H' },
	"knight":  { visibleName: "Knight",  name: "knight",  type:"soldier", level: 2, cost: 20, wage: 8, sell: 10, prefix: 'K' },
	"peasant": { visibleName: "Peasant", name: "peasant", type:"soldier", level: 1, cost: 10, wage: 3, sell: 5, prefix: 'P' },
};



// castles =
const CASTLE_DATA = {
	// listed in this order.
	"fortress": { visibleName: "Fortress",name: "fortress", type:"castle", level: 3, cost: 200, prefix: 'F' },
	"castle":   { visibleName: "Castle",  name: "castle",   type:"castle", level: 2, cost: 40, prefix: 'C' },
	"hut":      { visibleName: "Hut",     name: "hut",      type:"castle", level: 1, cost: 10, prefix: 'h' },
};


// todo: use this array instead of 2 separate arrays for soldiers and castles.
const UNITS_DATA = {
	soldier: { // this should be unit type, which can be used directly as reference here.
		...SOLDIER_DATA
	},
	castle: {
		...CASTLE_DATA
	},
	object: {
		
	},
};

console.log(UNITS_DATA);


function getSoldierLevel(type){
	return SOLDIER_DATA[type].level;
}
function getCastleLevel(type){
	return CASTLE_DATA[type].level;
}



// --- GLOBAL STATE ---
let peer = null;
let myPeerId = null;
let hostPeerId = null;
let connections = new Map(); // key: peerId, value: DataConnection
let localPlayer = {
	id: null,
	name: 'Player',
	color: "#888888", // debug color
	isSpectator: false,
	isHost: false,
	isDead: false,
	isAI: false,
};
let db = null;
let loadedGameState = null;


// --- GAME STATE (synced by host) ---
let gameState = {
	settings: {
		gameStarted: false,
		gameOver: false,
		mapWidth: 50, // default input values for map generation on ui
		mapHeight: 50,
		mapScale: 1,
		startingMoney: 1000, // default 0 actually. for testing 1000.
		roomName: 'default-room'
	},
	players: [], // { id, name, color, isSpectator, isAI }
	map: { // Using axial coordinates (q, r)
		// tiles[`${q},${r}`] = { type: 'land'/'water', ownerId: null, object: 'tree'/'grass'/'dead'/null, savings: 0 }
		// these are initialized when map is generated:
		width: 0,
		height: 0,
		imageData: "",
		name: "",
		bounds: {},
		tiles: {}, 
		tilesData: [
			// {
			//   tileIndex: this tile array index
			//   neighbours: {tileIndex, neighbourIndex, q, r} neighbour tiles indexes that are not water.
			// }
		], 
	},
	units: [], // { id, type: 'Peasant', ownerId, level, q, r, hasMoved }
	turn: {
		currentPlayerIndex: 0,
		startPlayerIndex: 0,
		turnNumber: 1,
	},
	// Economy pools are calculated, not stored directly
};

function resetGameState(){
	// TODO:
	// todo: causes weird bugs when the client player goes to start page and starts hosting his own room.
	
	// reset only required stuff, keep map intact so it can be reused.
	gameState.settings.gameStarted = false;
	gameState.settings.gameOver = false;
	gameState.players = [];
	gameState.units = [];
	gameState.turn.currentPlayerIndex = 0;
	gameState.turn.turnNumber = 1;
	
	// only reset map data that is generated on game start:
	gameState.map.bounds = {};
	gameState.map.tiles = {};
	gameState.map.tilesData = [];
	
	// reset only required stuff for the player:
	localPlayer.isSpectator = false;
	localPlayer.isHost = false;
	localPlayer.isDead = false;
	localPlayer.isAI = false;
}


// --- CLIENT-SIDE STATE (not synced) ---
let canvas, ctx;
let viewport = { x: 0, y: 0, zoom: 1 };
let dragStart = null;
let isDragging = false;
let selectedHex = null; // {q, r}
let selectedUnit = null;
let placingUnit = null; // e.g., { type: 'Peasant', cost: 100 }
let currentTurnActions = []; // For undo

let shakingUnits = []; // { id, endTime }
let highlightedPool = []; // [{q, r}] for highlighting connected hexes
let enemyHighlightedPool = []; // [{q, r}] for highlighting connected hexes
let validMoveHexes = []; // [{q, r}] for green move highlight
let invalidMoveHexes = []; // [{q, r}] for red move highlight
let myCurrentSavings = 0; // Client-side savings

// --- IMAGE CACHING ---
let imageCache = {};
let imageAssets;


function buildImageName(unitData){
	return `${unitData.type}${unitData.level}`; // soldier1
}

function getImagePath(unitData){
	return imageAssets[buildImageName(unitData)].path;
}

let use_orig = 1;

let waterAnimData = {
	width: 416,
	height: 32,
	tileWidth: 32,
	tileHeight: 32,
	frames: [
		{"x":0,"y":0},{"x":32,"y":0},{"x":64,"y":0},{"x":96,"y":0},
		{"x":128,"y":0},{"x":160,"y":0},{"x":192,"y":0},{"x":224,"y":0},
		{"x":256,"y":0},{"x":288,"y":0},{"x":320,"y":0},{"x":352,"y":0},
		{"x":384,"y":0}
	]
};


let use_homm3 = 0;
let pathPrefix = "";
let unitScales = [];
let unitOffsets = [];
if(use_homm3){
	pathPrefix = "homm3";
	unitScales = [1.45, 1.6, 1.6,   2.6, 2.2, 2.2, 1.9];
	unitOffsets = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0},   {x:0,y:5}, {x:0,y:5}, {x:0,y:2}, {x:0,y:2}];
}else{
	pathPrefix = "orig-scaled/128x128";
	unitScales = [1.8, 1.8, 1.8,   1.8, 1.8, 1.8, 1.8];
	unitOffsets = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0},   {x:0,y:0}, {x:0,y:0}, {x:0,y:0}, {x:0,y:3}];
}

// images =
if(use_orig){
	imageAssets = {
		'ui-sell': {path:'images/ui/sell.png', isUi: true},
		'ui-undo': {path:'images/ui/undo.png', isUi: true},
		'ui-endturn': {path:'images/ui/endturn.png', isUi: true},
		'ui-chat': {path:'images/ui/chat.png', isUi: true},
		'infinitewater': {path:'images/water.jpg', scale:1, offsetX: 0, isPattern: true},
		'water-anim': {path:'images/water-anim.png', scale:1, offsetX: 0, isPattern: true, isAnimated: true, animationData: waterAnimData},
		'water-anim-big': {path:'images/water-anim.png', isPattern: true, isAnimated: true, animationData: waterAnimData, isBigAnim: true},
		'land':     {path:'images/land2.jpg', scale:1, offsetX: 0}, 
		'dirt':     {path:'images/dirt2.jpg', scale:1, offsetX: 0},
		'water':    {path:'images/water.jpg', scale:1, offsetX: 0},
		'dead':     {path:'images/orig-scaled/128x128/dead.png', scale:2, offsetX: 0},
		'grass':    {path:'images/orig-scaled/128x128/grass.png', scale:2, offsetX: 3, offsetY: 5},
		'tree':     {path:'images/orig-scaled/128x128/tree.png', scale:2, offsetX: 2, offsetY: 5},
		'protect':  {path:'images/orig-scaled/128x128/protect.png', scale:1, offsetX: 0},
		'select':   {path:'images/orig-scaled/128x128/select.png', scale:1, offsetX: 0},

		'castle1':  {path:'images/'+pathPrefix+'/castle1.png', scale: unitScales[0], offsetX: unitOffsets[0].x, offsetY: unitOffsets[0].y},
		'castle2':  {path:'images/'+pathPrefix+'/castle2.png', scale: unitScales[1], offsetX: unitOffsets[1].x, offsetY: unitOffsets[1].y},
		'castle3':  {path:'images/'+pathPrefix+'/castle3.png', scale: unitScales[2], offsetX: unitOffsets[2].x, offsetY: unitOffsets[2].y},
		'soldier1': {path:'images/'+pathPrefix+'/soldier1.png', scale: unitScales[3], offsetX: unitOffsets[3].x, offsetY: unitOffsets[3].y},
		'soldier2': {path:'images/'+pathPrefix+'/soldier2.png', scale: unitScales[4], offsetX: unitOffsets[4].x, offsetY: unitOffsets[4].y},
		'soldier3': {path:'images/'+pathPrefix+'/soldier3.png', scale: unitScales[5], offsetX: unitOffsets[5].x, offsetY: unitOffsets[5].y},
		'soldier4': {path:'images/'+pathPrefix+'/soldier4.png', scale: unitScales[6], offsetX: unitOffsets[6].x, offsetY: unitOffsets[6].y},

		//'castle1':  {path:'images/orig-scaled/128x128/castle1.png', scale:1.8, offsetX: 0},
		//'castle2':  {path:'images/orig-scaled/128x128/castle2.png', scale:1.8, offsetX: 0},
		//'castle3':  {path:'images/orig-scaled/128x128/castle3.png', scale:1.8, offsetX: 0},
		//'soldier1': {path:'images/orig-scaled/128x128/soldier1.png', scale:1.8, offsetX: 0},
		//'soldier2': {path:'images/orig-scaled/128x128/soldier2.png', scale:1.8, offsetX: 0},
		//'soldier3': {path:'images/orig-scaled/128x128/soldier3.png', scale:1.8, offsetX: 0},
		//'soldier4': {path:'images/orig-scaled/128x128/soldier4.png', scale:1.8, offsetX: 0, offsetY: 3},
	};
}else{
	imageAssets = {
		'land': {path:'images/land2.jpg', scale:1, offsetX: 0}, 
		'dirt': {path:'images/dirt2.jpg', scale:1, offsetX: 0},
		'water': {path:'images/water.jpg', scale:1, offsetX: 0},
		'infinitewater': {path:'images/water.jpg', scale:1, offsetX: 0, isPattern: true},
		'dead': {path:'images/orig-scaled/dead.png', scale:1, offsetX: 0},
		'grass': {path:'images/orig-scaled/grass.png', scale:1, offsetX: 0},
		'tree': {path:'images/orig-scaled/tree.png', scale:1, offsetX: 0},
		'protect': {path:'images/orig-scaled/protect.png', scale:1, offsetX: 0},
		'select': {path:'images/orig-scaled/select.png', scale:1, offsetX: 0},
		'castle1': {path:'images/castle1.png', scale:0.7, offsetX: 0},
		'castle2': {path:'images/castle2.png', scale:1, offsetX: 0},
		'castle3': {path:'images/castle3.png', scale:1, offsetX: 0},
		'soldier1': {path:'images/soldier1.png', scale:1, offsetX: -5},
		'soldier2': {path:'images/soldier2.png', scale:1, offsetX: 0},
		'soldier3': {path:'images/soldier3.png', scale:1, offsetX: 5},
		'soldier4': {path:'images/soldier4.png', scale:1, offsetX: 0},
	};
}


// draws ">" triangle where the pointy right side is the x y coordinate.
function drawRightTriangle(ctx, x, y, height, width) {
	const halfHeight = height / 2;

	ctx.beginPath();
	
	ctx.moveTo(x-width, y-halfHeight);                 // Top-left
	ctx.lineTo(x-width, y-halfHeight + height);        // Bottom-left
	ctx.moveTo(x-width, y-halfHeight);                 // Back to top-left
	ctx.lineTo(x, y);  // Top to center-right
	ctx.moveTo(x-width, y-halfHeight + height);        // Bottom-left
	ctx.lineTo(x, y);  // Bottom to center-right

	ctx.strokeStyle = 'yellow';
	ctx.lineWidth = 2.5;
	ctx.lineCap = 'round';
	ctx.stroke();
}

function drawTriangle(ctx, x, y){
	let scale = 0.45;
	let h = 76;
	let w = h/2;
	drawRightTriangle(ctx, x-HEX_SIZE/2, y+HEX_SIZE/3, h*scale, w*scale);
}


async function load8BitBMP(url) {
	const buffer = await (await fetch(url)).arrayBuffer();
	const dv = new DataView(buffer);

	const pixelDataOffset = dv.getUint32(10, true);
	const width = dv.getInt32(18, true);
	const height = dv.getInt32(22, true);
	const bitsPerPixel = dv.getUint16(28, true);
	const paletteCount = dv.getUint32(46, true) || 256;

	if (bitsPerPixel !== 8) throw new Error("Only 8-bit BMPs supported");

	// Read palette (B,G,R,0)
	const palette = [];
	for (let i = 0; i < paletteCount; i++) {
		const b = dv.getUint8(54 + i * 4 + 0);
		const g = dv.getUint8(54 + i * 4 + 1);
		const r = dv.getUint8(54 + i * 4 + 2);
		palette.push([r, g, b]);
	}

	// Read pixel indices (bottom-up rows, 4-byte aligned)
	const pixels = new Uint8Array(width * height);
	const rowSize = Math.ceil(width / 4) * 4;
	let offset = pixelDataOffset;
	for (let y = height - 1; y >= 0; y--) {
		for (let x = 0; x < width; x++) {
			pixels[y * width + x] = dv.getUint8(offset++);
		}
		offset = pixelDataOffset + (height - 1 - y + 1) * rowSize;
	}

	return { width, height, palette, pixels };
}



function getCroppedBMP(bmp, dx, dy, width, height) {
	const { width: srcW, height: srcH, pixels, palette } = bmp;

	// Ensure crop stays inside the image bounds
	dx = Math.max(0, Math.min(dx, srcW - 1));
	dy = Math.max(0, Math.min(dy, srcH - 1));
	const cropW = Math.min(width, srcW - dx);
	const cropH = Math.min(height, srcH - dy);

	// Allocate new pixel array for cropped region
	const newPixels = new Uint8Array(cropW * cropH);

	for (let y = 0; y < cropH; y++) {
		const srcY = dy + y;
		for (let x = 0; x < cropW; x++) {
			const srcX = dx + x;
			newPixels[y * cropW + x] = pixels[srcY * srcW + srcX];
		}
	}

	// Return a new BMP-like object
	return {
		width: cropW,
		height: cropH,
		palette: bmp.palette.map(c => [...c]), // deep copy so palette edits won’t affect original
		pixels: newPixels
	};
}



function cyclePalette(palette, start = 229, end = 240) {
	const last = palette[end];
	for (let i = end; i > start; i--){
		palette[i] = palette[i - 1];
	}
	palette[start] = last;
}


function drawPaletteImage(ctx2, bmp, dx = 0, dy = 0) {
	const imgData = ctx2.createImageData(bmp.width, bmp.height);
	const data = imgData.data;
	const { pixels, palette } = bmp;

	for (let i = 0; i < pixels.length; i++) {
		const [r, g, b] = palette[pixels[i]];
		const j = i * 4;
		data[j] = r;
		data[j + 1] = g;
		data[j + 2] = b;
		data[j + 3] = 255;
	}

	ctx2.putImageData(imgData, dx, dy);
}


async function loadImages() {
    const loadPromises = [];

    for (const [key, obj] of Object.entries(imageAssets)) {
        const img = new Image();
        img.src = obj.path;
        imageCache[key] = img;

		if (!obj.isUi) {
			const promise = new Promise((resolve, reject) => {
				img.onload = async () => {
					try {
						await img.decode(); // ensure fully decoded before use
						console.log(`Image loaded: ${key}`);

						obj.image = img;

						// --- NEW: generate patterns for images that are marked as patterns ---
						if (!obj.isPattern) {
							// just generate mipmaps for normal images:
							obj.mipmaps = await generateMipmaps(img, 6);
						}else{
							if(obj.isAnimated){
								if (obj.isBigAnim) {
									const anim = obj.animationData;
									const frameCount = anim.frames.length;
									const gridSize = 8;
									const tileW = anim.tileWidth;
									const tileH = anim.tileHeight;
									const outputSize = gridSize * tileW;
									
									// load 13 images at once from single image:
									let waterAllPath = "images/water-all.bmp";
									let bmpAll = await load8BitBMP(waterAllPath);

									// 1️⃣ Create shuffled pool of frame indices 0–12, repeated 5 times
									const baseIndices = Array.from({ length: frameCount }, (_, i) => i);
									const shuffledPool = [];
									for (let i = 0; i < 5; i++) {
										const arr = [...baseIndices];
										for (let j = arr.length - 1; j > 0; j--) {
											const k = Math.floor(Math.random() * (j + 1));
											[arr[j], arr[k]] = [arr[k], arr[j]];
										}
										shuffledPool.push(...arr);
									}

									// 2️⃣ Fill initial 8×8 tile map from shuffled pool
									const tileMap = [];
									let poolIndex = 0;
									for (let y = 0; y < gridSize; y++) {
										const row = [];
										for (let x = 0; x < gridSize; x++) {
											let imageIndex = shuffledPool[poolIndex % shuffledPool.length];
											//let imageNumber = imageIndex+21;
											//let imagePath = `images/waterframes/watrtl${imageNumber}.bmp`;
											let bmp = getCroppedBMP(bmpAll, imageIndex*32, 0, 32, 32);
											row.push(bmp);
											poolIndex++;
										}
										tileMap.push(row);
									}

									// 3️⃣ Build 13 big animation frames (each 256×256)
									obj.animFrames = [];
									for (let frameIdx = 0; frameIdx < frameCount; frameIdx++) {
										const off = new OffscreenCanvas(outputSize, outputSize);
										const ctx2d = off.getContext('2d');
										
										// 8x8 tiles image:
										for (let y = 0; y < gridSize; y++) {
											for (let x = 0; x < gridSize; x++) {
												let bmp = tileMap[y][x];
												
												let dx = x*tileW;
												let dy = y*tileH;
												drawPaletteImage(ctx2d, bmp, dx, dy);
												cyclePalette(bmp.palette, 229, 240);
											}
										}

										// 4️⃣ Generate mipmaps + patterns for this composite frame
										const bitmap = await createImageBitmap(off);
										const mipmaps = await generateMipmaps(bitmap, 6);
										const patterns = mipmaps.map(mipmap => {
											const c = new OffscreenCanvas(mipmap.width, mipmap.height);
											const ctx3 = c.getContext('2d');
											ctx3.drawImage(mipmap, 0, 0);
											return ctx.createPattern(c, 'repeat');
										});

										obj.animFrames.push({
											mipmaps,
											patterns
										});
									}

									// 5️⃣ Metadata (same structure as small animated textures)
									obj.frameCount = frameCount;
									obj.frameDuration = 100; // adjust if you want faster/slower
									obj.currentFrame = 0;
									obj.lastFrameTime = performance.now();

									console.log(`Generated large animated pattern frames for ${key}`);
								}else{
									const anim = obj.animationData;
									obj.animFrames = [];

									for (const frame of anim.frames) {
										const frameCanvas = new OffscreenCanvas(anim.tileWidth, anim.tileHeight);
										const fctx = frameCanvas.getContext('2d');
										fctx.drawImage(
											img,
											frame.x, frame.y, anim.tileWidth, anim.tileHeight,
											0, 0, anim.tileWidth, anim.tileHeight
										);
										const frameBitmap = await createImageBitmap(frameCanvas);
										const frameMipmaps = await generateMipmaps(frameBitmap, 6);

										// For each mipmap level, create a pattern
										const framePatterns = frameMipmaps.map(mipmap => {
											const c = new OffscreenCanvas(mipmap.width, mipmap.height);
											const ctx2d = c.getContext('2d');
											ctx2d.drawImage(mipmap, 0, 0);
											return ctx.createPattern(c, 'repeat');
										});

										obj.animFrames.push({
											mipmaps: frameMipmaps,
											patterns: framePatterns
										});
									}

									obj.frameCount = anim.frames.length;
									obj.frameDuration = 300; // ms per frame, tweak as needed
									obj.currentFrame = 0;
									obj.lastFrameTime = performance.now();
								}
							}else{
								obj.mipmaps = await generateMipmaps(img, 6);
								obj.patterns = obj.mipmaps.map(mipmap => {
									// create a temporary canvas context for pattern
									const c = new OffscreenCanvas(mipmap.width, mipmap.height);
									const ctx2d = c.getContext('2d');
									ctx2d.drawImage(mipmap, 0, 0);
									return ctx.createPattern(c, 'repeat');
								});
							}
						}

						resolve();
					} catch (err) {
						console.error(`Error generating mipmaps for ${key}:`, err);
						reject(err);
					}
				};

				img.onerror = () => {
					console.error(`Failed to load image: ${obj.path}`);
					reject(new Error(`Failed to load image: ${obj.path}`));
				};
			});

			loadPromises.push(promise);
		}
    }

    await Promise.all(loadPromises);
    console.log("All images, mipmaps, and pattern mipmaps generated");
}


async function generateMipmaps(img, levels = 6) {
    const mipmaps = [];

    // Level 0 = original image as ImageBitmap
    const baseBitmap = await createImageBitmap(img);
    mipmaps.push(baseBitmap);

    let width = img.width;
    let height = img.height;
    let prev = baseBitmap;

    // Generate smaller levels using OffscreenCanvas
    for (let i = 1; i < levels; i++) {
        width = Math.max(1, Math.floor(width / 2));
        height = Math.max(1, Math.floor(height / 2));

        const off = new OffscreenCanvas(width, height);
        const ctx = off.getContext('2d');

        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(prev, 0, 0, width, height);

        // Convert the offscreen result into an ImageBitmap (GPU-friendly)
        const bitmap = await createImageBitmap(off);
        mipmaps.push(bitmap);

        prev = bitmap;
    }

    return mipmaps;
}








function getMipmapForZoom(imgObj, miplevel = -1) {
    if (!imgObj.mipmaps) return imgObj.image;
	if(miplevel == -1) miplevel = zoomMipLevel;
    return imgObj.mipmaps[miplevel];
}




// --- NEW FUNCTION: To get a loaded image from the cache
function getImage(key) {
	return imageCache[key];
}

function getImageSettings(key){
	return imageAssets[key];
}

// --- DOM ELEMENTS ---
const pages = {
	start: document.getElementById('start-page'),
	host: document.getElementById('host-page'),
	lobby: document.getElementById('lobby-page'),
	game: document.getElementById('game-page'),
};
const playerNameInput = document.getElementById('player-name');
playerNameInput.value = randomPlayerName();

const hostRoomPlayerNameInput = document.getElementById('host-room-player-name');




const gameNameInput = document.getElementById('game-name-input');
const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const spectateBtn = document.getElementById('spectate-btn');
const connectionStatus = document.getElementById('connection-status');

// Host Page
const hostRoomNameTitle = document.getElementById('host-room-name-title');
const mapWidthInput = document.getElementById('map-width');
const mapHeightInput = document.getElementById('map-height');
const startMoneyInput = document.getElementById('start-money');





const spectateHostBtn = document.getElementById('spectate-host-btn');


const loadedGameInfoContainer = document.getElementById('loaded-game-info-container');
const loadGameDate = document.getElementById('load-game-date');
const loadGamePlayersList = document.getElementById('load-game-players');
const startGameBtn = document.getElementById('start-game-btn');
const hostPlayerList = document.getElementById('host-player-list');

// Lobby Page
const lobbyRoomNameTitle = document.getElementById('lobby-room-name-title');
const lobbyMapSize = document.getElementById('lobby-map-size');
const lobbyStartMoney = document.getElementById('lobby-start-money');
const lobbyMapScale = document.getElementById('lobby-map-scale');
const lobbyPlayerNameInput = document.getElementById('lobby-player-name');
lobbyPlayerNameInput.value = randomPlayerName();

const lobbyColorPicker = document.getElementById('lobby-color-picker');
const hostRoomColorPicker = document.getElementById('host-room-color-picker');

const lobbyPlayerList = document.getElementById('lobby-player-list');
const lobbyStatus = document.getElementById('lobby-status');

// Game Page
canvas = document.getElementById('game-canvas');
ctx = canvas.getContext('2d');
const playerUIList = document.getElementById('player-ui-list');
const chatMessages = document.getElementById('chat-messages');
const topFloatUiChatMessages = document.getElementById('top-float-ui-messages');

//ctx.imageSmoothingEnabled = true;
//ctx.imageSmoothingQuality = 'high';

const chatInput = document.getElementById('chat-input');
const turnInfo = document.getElementById('turn-info');
const playerSavings = document.getElementById('player-savings');
const playerIncome = document.getElementById('player-income');
const playerWages = document.getElementById('player-wages');
const playerBalance = document.getElementById('player-balance');

const buildSoldierBtn = document.getElementById('build-soldier-btn');
const buildCastleBtn = document.getElementById('build-castle-btn');
const endTurnBtn = document.getElementById('end-turn-btn');
const undoBtn = document.getElementById('undo-btn');
const sellUnitBtn = document.getElementById('sell-unit-btn');
const buildPopup = document.getElementById('build-popup');

const buildPopupTitle = document.getElementById('build-popup-title');
const buildPopupList = document.getElementById('build-popup-list');
const buildPopupClose = document.getElementById('build-popup-close');

const toggleUiBtn = document.getElementById('toggle-ui-btn');
const quitGameBtn = document.getElementById('quit-game-btn');

const refreshCanvasBtn = document.getElementById('refresh-canvas');



const topFloatUi = document.getElementById('top-float-ui');
const uiRight = document.getElementById('ui-right');
const uiLeft = document.getElementById('ui-left');




// randomname random name random nick
function randomPlayerName() {
	const prefixes = [
		"al", "bel", "cor", "dar", "el", "fen", "gal", "hal", "jor", "kal",
		"lin", "mor", "nor", "or", "pel", "quil", "ron", "sel", "tor", "val",
	];
	const middles = [
		"a", "e", "i", "o", "u", "ae", "ia", "eo", "ou", "ai",
	];
	const suffixes = [
		"dor", "mar", "ric", "tan", "ven", "win", "bar", "dris", "lith", "zor",
		"thus", "mir", "gorn", "las", "thar", "mond",
	];

	function capitalize(word) {
		return word.charAt(0).toUpperCase() + word.slice(1);
	}

	const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
	const middle = middles[Math.floor(Math.random() * middles.length)];
	const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];

	return capitalize(prefix + middle + suffix);
}

function getRandomString(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        result += chars[randomIndex];
    }
    return result;
}




const addAiBtn = document.getElementById('add-ai-btn');

let ai_counter = 1;

addAiBtn.addEventListener('click', () => {
    if (!localPlayer.isHost) return;

	let randomStr = getUID(8);
    const aiPlayer = {
        id: `AI-${ai_counter}-${randomStr}`,
        name: `AI-${ai_counter}`,
		color: getNextFreeColor(),
		isSpectator: false,
		isAI: true,
		isDead: false,
    };

    gameState.players.push(aiPlayer);
    ai_counter++;

    // Update the UI for the host and broadcast the new state to all clients
	broadcastLobbyState();
});



// =================================================================
// --- UTILITY FUNCTIONS
// =================================================================
function centerToFirstUnit(){
	// todo: will fail when loading a game where you are not a player.
	let player = getMyPlayer();
	
	for (const unit of gameState.units) {
		if(unit.ownerId === player.id){
			centerTo(unit.q, unit.r);
			break;
		}
	}
}

function showPage(pageId) {
	Object.values(pages).forEach(page => page.classList.remove('active'));
	if (pages[pageId]) {
		pages[pageId].classList.add('active');
	}
	if (pageId === 'game') {
		resizeCanvas();
		
		// might fix weird black bar appearing at bottom sometimes:
		// "A2HS standalone/PWA mode has viewport bugs on many Android versions."
		// "The OS initially gives a height that includes or excludes soft navigation bars incorrectly."
		// "The CSS units vh and JavaScript window.innerHeight are unreliable on first load in these conditions."
		setTimeout(resizeCanvas, 1000);
		
		render();
	}
}




// centers screen on q,r position.
function centerTo(q, r){
	const centerPx = axialToPixel(q, r); 
	viewport.x = canvas.width / 2 - centerPx.x;
	viewport.y = canvas.height / 2 - centerPx.y;
}


function sendToPlayer(playerId, data) {
	//console.log("sendToPlayer");
	
	if (!localPlayer.isHost) return;
	
	//console.log("sendToPlayer 2");
	
	if (playerId === localPlayer.id) {
		// It's the host, handle directly
		//console.log("sendToPlayer playerId === localPlayer.id");
		
		handleHostData(data);
	} else if (connections.has(playerId)) {
		//console.log("else if (connections.has(playerId)");
		
		connections.get(playerId).send(data);
	}
}

function sendToHost(data) {
	if (localPlayer.isHost) {
		// Host handles its own actions directly
		handleClientData(localPlayer.id, data);
	} else if (hostPeerId && connections.has(hostPeerId)) {
		connections.get(hostPeerId).send(data);
	}
}

function broadcast(data) {
	if (!localPlayer.isHost) return;
	// Send to all connected clients
	for (const [peerId, conn] of connections.entries()) {
		conn.send(data);
	}
	// Host handles its own data
	handleHostData(data);
}


let hideTimeout = null;
let hideTimeout2 = null;

function clearTimeouts(){
	if(hideTimeout){
		clearTimeout(hideTimeout);
	}
	if(hideTimeout2){
		clearTimeout(hideTimeout2);
	}
}

function hideTopFloatUi(){
	clearTimeouts();
	topFloatUi.style.transition = 'opacity 0.5s';
	topFloatUi.style.opacity = '1';
	topFloatUi.style.display = 'flex';
	
	hideTimeout = setTimeout(() => {
		topFloatUi.style.opacity = '0';
		
		hideTimeout2 = setTimeout(() => {
			topFloatUi.style.display = 'none';
		}, 1000); // matches the transition time
	}, 10000);
}



let showTopLeftUi = false;

function toggleUiTopLeft(toggleValue = null){
	if(toggleValue === null){
		showTopLeftUi = !showTopLeftUi;
	}else{
		showTopLeftUi = toggleValue;
	}
	toggleUiBtn.classList.toggle('active', showTopLeftUi);
	
	clearTimeouts();
	
	if(showTopLeftUi){
		uiLeft.style.display = 'flex';
		topFloatUi.style.display = 'none';
		topFloatUi.style.opacity = '0';
		chatMessages.scrollTop = chatMessages.scrollHeight;
		chatInput.focus();
	}else{
		uiLeft.style.display = 'none';
		topFloatUi.style.display = 'flex';
		topFloatUi.style.opacity = '1';
		topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;
		hideTopFloatUi();
	}
}


function pushChatMessage(from, message, color = '#FFF') {
	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};" class="msgfromtext"></strong><span class="msgtext"></span>`;
	
	const safeMsgFrom = document.createTextNode(`${from}:`);
	const safeMsg = document.createTextNode(` ${message}`);
	item.querySelector(".msgfromtext").appendChild(safeMsgFrom);
	item.querySelector(".msgtext").appendChild(safeMsg);

	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
	
	const item2 = item.cloneNode(true);
	topFloatUiChatMessages.appendChild(item2);
	topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;
}

// sendmessage addmessage pushmessage
function addChatMessage(from, message, color = '#FFF') {
	pushChatMessage(from, message, color);
	
	// show chat messages on top if topleft ui is not open
	if(!showTopLeftUi){
		//console.warn("hideTopFloatUi");
		hideTopFloatUi();
	}

}



function addSystemChatMessage(message, color = '#FFF') {
	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};">${message}</strong>`;
	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
	
	const item2 = item.cloneNode(true);
	topFloatUiChatMessages.appendChild(item2);
	topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;
	
	// show chat messages on top if topleft ui is not open
	if(!showTopLeftUi){
		//console.warn("hideTopFloatUi2");
		hideTopFloatUi();
	}
}



function shortUIDBase36(maxLength = 16) {
	let bytes = 10;
	const arr = new Uint8Array(bytes);
	crypto.getRandomValues(arr);

	let num = 0n;
	for (const b of arr) num = (num << 8n) | BigInt(b);

	return num.toString(36).toUpperCase().slice(0, maxLength);
}

function getUID(maxLength = 16) {
	// seems to be working right, no way two identical IDS generated.
	//return Date.now().toString(36) + Math.random().toString(36).substr(2);
	//return Date.now().toString(36).toUpperCase() + Math.random().toString(36).substr(2).toUpperCase();
	return shortUIDBase36(maxLength);
}

function getPlayer(playerId) {
	return gameState.players.find(p => p.id === playerId);
}

function getPlayerByIndex(playerIndex) {
	if(gameState.players[playerIndex]){
		return gameState.players[playerIndex];
	}else{
		return null;
	}
}

function getPlayerIndex(playerId) {
	return gameState.players.findIndex(p => p.id === playerId);
}

function getMyPlayer() {
	return getPlayer(localPlayer.id);
}


// =================================================================
// --- HEXAGON MATH
// (Using "pointy top" axial coordinates)
// =================================================================

function axialToPixel(q, r) {
	const x = HEX_SIZE * (3/2 * q);
	const y = HEX_SIZE * (SQRT3/2 * q + SQRT3 * r);
	return { x, y };
}


function pixelToAxial(x, y) {
	// Apply viewport inverse transform
	const viewX = (x - viewport.x) / viewport.zoom;
	const viewY = (y - viewport.y) / viewport.zoom;
	
	const q = (2/3 * viewX) / HEX_SIZE;
	const r = (-1/3 * viewX + SQRT3/3 * viewY) / HEX_SIZE;
	return hexRound(q, r);
}


function hexRound(q, r) {
	const s = -q - r;
	let rq = Math.round(q);
	let rr = Math.round(r);
	let rs = Math.round(s);

	const q_diff = Math.abs(rq - q);
	const r_diff = Math.abs(rr - r);
	const s_diff = Math.abs(rs - s);

	if (q_diff > r_diff && q_diff > s_diff) {
		rq = -rr - rs;
	} else if (r_diff > s_diff) {
		rr = -rq - rs;
	}
	// `rs` is derived, so we just return `rq` and `rr`
	return { q: rq, r: rr };
}


function getHexNeighbors(q, r) {
	return [                    //              i for "angle index" calculations
		{ q: q,     r: r + 1 }, // bottom       0
		{ q: q - 1, r: r + 1 }, // bottom left  1
		{ q: q - 1, r: r },     // top left     2
		{ q: q,     r: r - 1 }, // top          3
		{ q: q + 1, r: r - 1 }, // top right    4
		{ q: q + 1, r: r },     // bottom right 5
	];
}


function getHexDistance(q1, r1, q2, r2) {
	const dq = q1 - q2;
	const dr = r1 - r2;
	const ds = (-q1 - r1) - (-q2 - r2);
	return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
}




// =================================================================
// --- CANVAS RENDERING
// =================================================================
function resizeCanvas(){
	console.warn(`resizeCanvas(): old = ${canvas.width}x${canvas.height}, new = ${window.innerWidth}x${window.innerHeight}`);
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
}




function initCanvas() {
	// old code, using resizeCanvas() now.
	//canvas.width = window.innerWidth;
	//canvas.height = window.innerHeight;
}




function getHexAnglePos(i, px, py){
	const angle = 2 * Math.PI / 6 * (i + 1); // +0.5 for pointy top
	const x = px + HEX_SIZE * Math.cos(angle);
	const y = py + HEX_SIZE * Math.sin(angle);
	return {x, y};
}


function drawHexLine(i, px, py){
	let p1 = getHexAnglePos(i, px, py);
	let p2 = getHexAnglePos(i+1, px, py);
	ctx.moveTo(p1.x, p1.y);
	ctx.lineTo(p2.x, p2.y);
}





function drawCalligraphyLine(x1, y1, x2, y2, penWidth, penAngle = Math.PI / 2) {
	const dx = x2 - x1;
	const dy = y2 - y1;

	// Compute perpendicular offset based on fixed pen angle
	const offsetX = Math.cos(penAngle) * (penWidth / 2);
	const offsetY = Math.sin(penAngle) * (penWidth / 2);

	ctx.beginPath();
	ctx.moveTo(x1 - offsetX, y1 - offsetY);
	ctx.lineTo(x2 - offsetX, y2 - offsetY);
	ctx.lineTo(x2 + offsetX, y2 + offsetY);
	ctx.lineTo(x1 + offsetX, y1 + offsetY);
	ctx.closePath();
	ctx.fill();
}





let waterShadingHeightHalf = 10; // half of the line height.
let waterShadingHeight = waterShadingHeightHalf*2;


// water shading
function drawWaterShading(px, py, drawLines, color = "rgba(0,0,0, 0.6)"){
	if(drawLines.length > 0){
		let da = Math.PI / 2;
		for(let i = 0; i < drawLines.length; i++){
			let ival = drawLines[i]; // convert getHexNeighbors indexes to i multiplier value for calculations of angles.
			let p1 = getHexAnglePos(ival, px, py);
			let p2 = getHexAnglePos(ival+1, px, py);

			ctx.fillStyle = color;
			
			drawCalligraphyLine(
				p1.x, p1.y+waterShadingHeightHalf, 
				p2.x, p2.y+waterShadingHeightHalf, 
				waterShadingHeight, da
			);
		}
	}
}




function drawHexagonPathLines(px, py, drawLines = null) {
	if(drawLines){
		if(drawLines.length > 0){
			ctx.beginPath();
			for(let i = 0; i < drawLines.length; i++){
				let ival = drawLines[i]; // convert getHexNeighbors indexes to i multiplier value for calculations of angles.
				drawHexLine(ival, px, py);
			}
			//ctx.closePath(); // only needed for drawing filled hex.
		}
	}else{
		ctx.beginPath();
		for (let ival = 0; ival < 6; ival++) {
			drawHexLine(ival, px, py);
		}
		//ctx.closePath(); // only needed for drawing filled hex.
	}
}




// drawLines = array of values 0-5
// 0 = bottom left
// 1 = top left
// 2 = Top
// 3 = top right
// 4 = bottom right
// 5 = bottom
function drawHexagonPath(px, py, padding = 0) {
	ctx.beginPath();
	for (let i = 0; i < 6; i++) {
		const angle = 2 * Math.PI / 6 * (i + 1); // +0.5 for pointy top
		const x = px + (HEX_SIZE+padding) * Math.cos(angle);
		const y = py + (HEX_SIZE+padding) * Math.sin(angle);
		if(i === 0){
			ctx.moveTo(x, y);
		}else{
			ctx.lineTo(x, y);
		}
	}
	ctx.closePath();
}




function drawHexagonOutlines(q, r, myId = -1){
	let highlightedLines = [];
	const { x, y } = axialToPixel(q, r);
	
	let hexNeigh = getHexNeighbors(q, r);

	for(let i = 0; i < hexNeigh.length; i++){
		let hexCoord = hexNeigh[i];
		let nTile = getTileAt(hexCoord.q, hexCoord.r);
		if(nTile && nTile.ownerId != myId){
			highlightedLines.push(i);
		}
		// if neighbour tile is out of bounds:
		if(!nTile){
			highlightedLines.push(i);
		}
	}
	drawHexagonPathLines(x, y, highlightedLines);
}





function drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, miplevel = -1){
	const imgObj = imageAssets[imageName];
	if(miplevel == -1) miplevel = zoomMipLevel;
	const mip = getMipmapForZoom(imgObj, miplevel);
	ctx.drawImage(mip, dx, dy, dWidth, dHeight);
}

// check if object/tile should be skipped from drawing:
// returns true if out of screen.
// topEdgeOffset: top edge offset.
function checkCulling(x, y, topEdgeOffset = 0){
	const screenX = x * viewport.zoom + viewport.x;
	const screenY = y * viewport.zoom + viewport.y;
	if (screenX < -HEX_SIZE * viewport.zoom || screenX > canvas.width + HEX_SIZE * viewport.zoom ||
		screenY < (-HEX_SIZE+topEdgeOffset) * viewport.zoom || screenY > canvas.height + HEX_SIZE * viewport.zoom) {
		return true;
	}
	return false;
}


function darkenHexColor(color, percentage = 0.8){
	return blendHexColor(color, "#000000", percentage);
}
function lightenHexColor(color, percentage = 0.1){
	return blendHexColor(color, "#FFFFFF", percentage);
}

function hexToRgba(hex, opacity = 1) {
	// Remove the leading '#' if present
	hex = hex.replace(/^#/, '');

	// Handle shorthand hex (e.g. #f53)
	if (hex.length === 3) {
		hex = hex.split('').map(char => char + char).join('');
	}

	// Parse r, g, b values
	const r = parseInt(hex.substring(0, 2), 16);
	const g = parseInt(hex.substring(2, 4), 16);
	const b = parseInt(hex.substring(4, 6), 16);

	// Clamp opacity between 0 and 1
	const alpha = Math.max(0, Math.min(1, opacity));

	return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}


function blendHexColor(color1, color2 = "#000000", percentage = 0.5) {
	// Ensure percentage is between 0 and 1
	percentage = Math.min(Math.max(percentage, 0), 1);

	// Helper to convert hex to RGB
	const hexToRgb = hex => {
		hex = hex.replace(/^#/, "");
		if (hex.length === 3) {
			hex = hex.split("").map(x => x + x).join("");
		}
		const num = parseInt(hex, 16);
		return [num >> 16, (num >> 8) & 255, num & 255];
	};

	// Helper to convert RGB to hex
	const rgbToHex = ([r, g, b]) =>
		"#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");

	const rgb1 = hexToRgb(color1);
	const rgb2 = hexToRgb(color2);

	// Blend each channel
	const blended = rgb1.map((c, i) => Math.round(c * (1 - percentage) + rgb2[i] * percentage));

	return rgbToHex(blended);
}



const debugUi = document.getElementById("debug-ui");

let lastTime = 0;
let frameCount = 0;


function trackFPS(){
	let timestamp = Date.now();
	if (!lastTime) lastTime = timestamp;

	const delta = timestamp - lastTime;
  
	if (delta >= 2000) {
		let fps = frameCount/(delta/1000);
		//console.log("FPS: "+fps.toFixed(2));
		debugUi.textContent = "FPS: "+fps.toFixed(0);
		
		
		frameCount = 0;
		lastTime = timestamp;
	}else{
		frameCount++;
	}

}


function drawObject(ctx, x, y, objectName){
	let imageKey = objectName;
	const img = getImage(imageKey);
	
	if (img && img.complete && img.width > 0) {
		// Draw the image centered and scaled
		let imginfo = getImageSettings(imageKey);
		let scale = imginfo.scale*0.9; // 0.9 global scale
		let ratio = img.height/img.width;
		let drawSize = 50;
		let hsize = drawSize/2;
		let offsetX = imginfo.offsetX;
		let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
		let dx = x-((hsize-offsetX)*scale);
		let dy = y-((hsize-offsetY+10)*ratio*scale);
		let dw = drawSize*scale;
		let dh = drawSize*ratio*scale;
		
		//ctx.drawImage(img, dx, dy, dw, dh);
		drawImageMipped(ctx, imageKey, dx, dy, dw, dh);
	}
}





let useAnimatedWater = 1;
let isBigAnimatedWater = 1;

// renderinfinitewater 
let useInfiniteWater = 1;
let drawWaterTiles = 0;


// draw water draw infinitewater draw infinite water render infinitewater render infinite water
function drawInfiniteWater(){

	let waterZoomMipLevel = getZoomMipLevel(0.6); // smaller = earlier switch to smaller image
	let waterAnimZoomMipLevel = getZoomMipLevel(1.6); // smaller = earlier switch to smaller image
	let bigWaterAnimZoomMipLevel = getZoomMipLevel(1.6); // smaller = earlier switch to smaller image


	if(useInfiniteWater){
		if(useAnimatedWater){
			if(isBigAnimatedWater){
				const patternObj = imageAssets['water-anim-big'];
				if (patternObj && patternObj.isAnimated) {
					const now = performance.now();
					if (now - patternObj.lastFrameTime >= patternObj.frameDuration) {
						patternObj.currentFrame = (patternObj.currentFrame + 1) % patternObj.frameCount;
						// skip first frame, since its same as last frame:
						// TODO: remove the first frame image from the actual image frames array to save memory.
						if(patternObj.currentFrame == 0) patternObj.currentFrame = 1;
						patternObj.lastFrameTime = now;
					}

					const frame = patternObj.animFrames[patternObj.currentFrame];
					const pattern = frame.patterns[bigWaterAnimZoomMipLevel];
					const mipScale = Math.pow(0.5, bigWaterAnimZoomMipLevel);

					const matrix = new DOMMatrix()
						.translate(viewport.x, viewport.y)
						.scale(viewport.zoom * 1.6 / mipScale);

					pattern.setTransform(matrix);
					ctx.fillStyle = pattern;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}else{
				const patternObj = imageAssets['water-anim'];
				if (patternObj && patternObj.isAnimated) {
					const now = performance.now();
					if (now - patternObj.lastFrameTime >= patternObj.frameDuration) {
						patternObj.currentFrame = (patternObj.currentFrame + 1) % patternObj.frameCount;
						patternObj.lastFrameTime = now;
					}

					const frame = patternObj.animFrames[patternObj.currentFrame];
					const pattern = frame.patterns[waterAnimZoomMipLevel];
					const mipScale = Math.pow(0.5, waterAnimZoomMipLevel);

					const matrix = new DOMMatrix()
						.translate(viewport.x, viewport.y)
						.scale(viewport.zoom * 2.4 / mipScale);

					pattern.setTransform(matrix);
					ctx.fillStyle = pattern;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}

		}else{
			const patternObj = imageAssets['infinitewater'];
			// get current mip level image pattern:
			const pattern = patternObj.patterns[waterZoomMipLevel];
			const mipScale = Math.pow(0.5, waterZoomMipLevel);
			
			const matrix = new DOMMatrix()
				.translate(viewport.x, viewport.y) 
				.scale(viewport.zoom*0.4/mipScale); // mipScale = scale to different mip level

			pattern.setTransform(matrix);

			ctx.fillStyle = pattern;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
		}
	}else{
		// default clear without textures.
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}
}





let drawnTiles = 0;
let previous_drawnTiles = 0;


// rendertiles drawtiles rendermaptiles render tiles render map tiles
function drawMapTiles(){

	let tileZoomMipLevel = getZoomMipLevel(0.5); // use normal. smaller = earlier switch to smaller image
	
	
	// --- DRAW TILES ---
	// draw only the tiles that exists. (old code had 2 for loops for q and r ranges...)
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		const { x, y } = axialToPixel(q, r);

		// --- Culling Check ---
		if(checkCulling(x, y, -waterShadingHeight)){
			continue;
		}
		
		if (tile.type === 'water') {
			if(useInfiniteWater){
				continue; // skip water tiles.
			}
		}
		
		let drawTile = true;
		

		// 2. Draw the fallback background color (or owner color)
		let fallbackColor = LAND_COLOR;
		if (tile.type === 'water') {
			fallbackColor = WATER_COLOR;
			if(!drawWaterTiles){
				drawTile = false;
			}
		} else if (tile.ownerId) {
			const owner = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
			fallbackColor = owner ? owner.color : LAND_COLOR;
		} else if (tile.type === 'land') {
			fallbackColor = LAND_COLOR;
		}
		
		if(!drawTile){
			continue;
		}
		
		// draw shadows/shading for land tiles next to water:
		// draw map outlines:
		// renderoutlines render outlines
		if(tile.type === 'land') {
			if(tile.outline){
				let player = getPlayer(tile.ownerId);
				let color;
				if(player){
					color = hexToRgba(darkenHexColor(player.color, 0.8), 0.8);
				}else{
					color = hexToRgba(darkenHexColor("#705F4B", 0.8), 0.8);
				}
				drawWaterShading(x, y, tile.outline, color);
			}
		}


		drawnTiles++;
		
		// --- Start Drawing Hex ---

		// anything inside save/restore is clipped to the hex shape.
		ctx.save(); // needed for hex drawing.
		
		// Define the hex path
		drawHexagonPath(x, y);
		//ctx.fillStyle = fallbackColor;
		//ctx.fill();

		// useimages = false for testing performance without tile images.
		if(useimages){
			// 3. Get the background image for this tile type
			// (We assume the image key is the same as tile.type)
			let img = null;
			let imageName = "";
			if(tile.ownerId){
				imageName = tile.type;
				img = getImage(tile.type);
			}else{
				// no owner, use dirt image:
				if(tile.type === 'water') {
					imageName = "water";
					img = getImage("water");
				}else{
					imageName = "dirt";
					img = getImage("dirt");
				}
			}

			// 4. If image is loaded, draw it clipped and scaled
			if (img && img.complete && img.width > 0) {
				ctx.clip(); // Apply clip to the hex path

				// Calculate the "pointy-top" hex bounding box
				const hexWidth = HEX_SIZE * SQRT3*GS;
				const hexHeight = HEX_SIZE * 2;
				
				// Calculate "scale-to-fit" (contain) ratio
				const ratio = Math.min(hexWidth / img.width, hexHeight / img.height);
				const dWidth = img.width * ratio;
				const dHeight = img.height * ratio;
				
				// Calculate centered destination (dx, dy)
				const dx = x - dWidth / 2;
				const dy = y - dHeight / 2;
				
				if(tile.ownerId){
					// Draw the gray texture (owned land) with multiply operation:
					const player = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
	
					//ctx.drawImage(img, dx, dy, dWidth, dHeight);
					drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, tileZoomMipLevel);

					let color = player.color;
					if(!tile.isProtected){
						// showing unprotected lands might make game boring, also confusing when it shows different color.
						//color = lightenHexColor(player.color, 0.2);
					}
					// todo: make own images for each player texture?
					// Multiply by player color
					ctx.globalCompositeOperation = "multiply";
					ctx.fillStyle =  color; // e.g. "#ff0000"
					ctx.fillRect(dx, dy, dWidth, dHeight);
					ctx.globalCompositeOperation = "source-over";
					
				}else{
					// draw dirt image:
					//ctx.drawImage(img, dx, dy, dWidth, dHeight);
					drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, tileZoomMipLevel);
				}

			}
			
		}
		// Restore context (removes clip)
		ctx.restore();
	}
	

	// log how many tiles were drawn to test culling working:
	if(previous_drawnTiles != drawnTiles){
		//console.log("drawnTiles = "+drawnTiles);
		previous_drawnTiles = drawnTiles;
	}
	
}




// renderhighlights
function drawHighlights(){

	let highlightedEnemy = null;
	let highlightedPlayer = null;
	
	// draw pools edges for all pools:
	if(enemyHighlightedPool.length > 0){
		let tile = getTileAt(enemyHighlightedPool[0].q, enemyHighlightedPool[0].r);
		highlightedEnemy = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
	}
	
	if(highlightedPool.length > 0){
		let tile = getTileAt(highlightedPool[0].q, highlightedPool[0].r);
		highlightedPlayer = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
	}


	// draw highlighted lines for all pools:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		const { x, y } = axialToPixel(q, r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		
		if (tile.type === 'water') {
			if(useInfiniteWater){
				continue; // skip water tiles.
			}
		}
		
		
		if(tile.ownerId){
			let neighbours = tile.neighbours;
			if(neighbours && neighbours.length > 0){
				let highlightedLines = [];
				// ({tileIndex: nTile.tileIndex, neighbourIndex: i, q: n.q, r: n.r}
				for(let n = 0; n < neighbours.length; n++){
					let neigh = neighbours[n];
					// -1 = water tile:
					if(neigh.tileIndex != -1){
						let nTile = gameState.map.tilesData[neigh.tileIndex];
						if(nTile.ownerId !== tile.ownerId){
							highlightedLines.push(neigh.neighbourIndex);
						}
					}else{
						// water tiles: add by default.
						highlightedLines.push(neigh.neighbourIndex);
					}
				}
				
				
				if(highlightedLines.length > 0){
					drawHexagonPathLines(x, y, highlightedLines);
					//drawHexagonPathLines(x, y, [0,1,2,3,4,5]);
					
					let player = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
					let color = lightenHexColor(player.color, 0.1);
					let opacity = 0.5;
					let dashedMode = 0;
					
					if(highlightedEnemy){
						if(highlightedEnemy.id == tile.ownerId){
							opacity = 1;
							color = lightenHexColor(player.color, 0.6);
						}
					}
					
					if(highlightedPlayer){
						if(highlightedPlayer.id == tile.ownerId){
							dashedMode = 1;
						}
					}
					
					if(dashedMode){
						// your pool highlight
						ctx.setLineDash([12.5, 15]);
						ctx.strokeStyle = 'rgba(255,255,0, 1)';
						ctx.lineWidth = 4;
						ctx.lineCap = 'round';
						ctx.stroke();
						ctx.lineCap = 'butt'; // reset to default
						ctx.setLineDash([]);
					}else{
						// enemy pool highlight
						ctx.strokeStyle = hexToRgba(color, opacity);
						ctx.lineWidth = 3;
						ctx.lineCap = 'round';
						ctx.stroke();
						ctx.lineCap = 'butt'; // reset to default
					}
				}
			}
		}
	}
	

/*
	// note: moved above that loops all tiles to draw edges.
	if(highlightedPool.length > 0){
		ctx.setLineDash([12.5, 15]);
		// Draw selected pool
		for (const hex of highlightedPool) {
			drawHexagonOutlines(hex.q, hex.r, localPlayer.id);
			ctx.strokeStyle = 'rgba(255,0,255, 1)';
			ctx.lineWidth = 1;
			ctx.lineCap = 'round';
			ctx.stroke();
			ctx.lineCap = 'butt'; // reset to default
		}
		ctx.setLineDash([]);
	}
	*/
	/*
	if(enemyHighlightedPool.length > 0){
		//ctx.setLineDash([12.5, 15]);
		// Draw selected enemy pool
		// use selected pool player id for each tile:
		
		let tile = getTileAt(enemyHighlightedPool[0].q, enemyHighlightedPool[0].r);
		let player = getPlayerByIndex(tile.ownerIndex);//getPlayer(tile.ownerId);
		
		let color = lightenHexColor(player.color);
		
		for (const hex of enemyHighlightedPool) {
			drawHexagonOutlines(hex.q, hex.r, tile.ownerId);
			ctx.strokeStyle = color;
			ctx.lineWidth = 4;
			ctx.lineCap = 'round';
			ctx.stroke();
			ctx.lineCap = 'butt'; // reset to default
		}
		//ctx.setLineDash([]);
	}
	*/
}





// renderobjects
function drawObjects(){

	// Draw objects (trees etc) on top of pool edges:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		const { x, y } = axialToPixel(q, r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		
		if (tile.type === 'land' && tile.object) {
			drawObject(ctx, x, y, tile.object);
		}
	}
}




// draw only specific type of units; "soldier" or "castle"
function drawUnitsByType(unitType){
	for (const unit of gameState.units) {
		if(unit.internalType !== unitType){
			continue;
		}
		
		let { x, y } = axialToPixel(unit.q, unit.r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		//unitsDrawn++;
		
		// no idea why this is here... probably loaded game missing players fix?
		const owner = getPlayerByIndex(unit.ownerIndex);
		if (!owner){
			//console.log("owner not found: "+unit.ownerIndex);
			continue;
		}

		const data = SOLDIER_DATA[unit.type] || CASTLE_DATA[unit.type];
		
		let imageKey = `${data.type}${data.level}`;
		const img = getImage(imageKey);
		
		if (img && img.complete && img.width > 0) {
			// Draw the image centered and scaled
			let imginfo = getImageSettings(imageKey);
			let scale = imginfo.scale*0.9; // 0.9 global scale
			let ratio = img.height/img.width;
			let drawSize = 50;
			let hsize = drawSize/2;
			let offsetX = imginfo.offsetX;
			let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
			let dx = x-((hsize-offsetX)*scale);
			let dy = y-((hsize-offsetY+10)*ratio*scale);
			let dw = drawSize*scale;
			let dh = drawSize*ratio*scale;
			
			// draw unit:
			drawImageMipped(ctx, imageKey, dx, dy, dw, dh);
		}
	}
}




// renderunits
function drawUnits(){
	
	// draw all units, castles first:
	drawUnitsByType("castle");
	drawUnitsByType("soldier");
	
	
	let currentTurnPlayer = getCurrentTurnPlayer();

	// draw arrow signs (yellow triangles):
	for (const unit of gameState.units) {
		let { x, y } = axialToPixel(unit.q, unit.r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		
		// no idea why this is here... probably loaded game missing players fix?
		const owner = getPlayerByIndex(unit.ownerIndex);
		if (!owner) continue;

		const data = SOLDIER_DATA[unit.type] || CASTLE_DATA[unit.type];
		
		if(data.type == 'soldier'){
			if(currentTurnPlayer.id === unit.ownerId && isMyTurn()){
				// draw yellow arrow sign:
				if (!unit.hasMoved) {
					drawTriangle(ctx, x, y);
				}
			}
		}
		
	}
	
	//console.log("unitsDrawn = "+unitsDrawn);
}



// rendermovementranges
function drawMovementRanges(){

	// Draw movement range
	ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
	for (const hex of validMoveHexes) {
		const { x, y } = axialToPixel(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}
	
	// Draw invalid move range
	ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
	for (const hex of invalidMoveHexes) {
		const { x, y } = axialToPixel(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}
}




let prev_highlight = "";
let cur_buildCheck = null;

// renderPlacementHighlight 
function drawPlacementHighlight(){

/*
	// Draw selected hex outline
	if (selectedHex) {
		const { x, y } = axialToPixel(selectedHex.q, selectedHex.r);
		drawHexagonPathLines(x, y);
		ctx.strokeStyle = 'rgba(255,255,255, 0.4)';
		ctx.lineWidth = 2;
		ctx.lineCap = 'round';
		ctx.stroke();
		ctx.lineCap = 'butt'; // reset to default
	}
	*/
	
	
	// Draw placement highlight
	if (placingUnit) {
		const mouseHex = pixelToAxial(lastMousePos.x, lastMousePos.y);
		const { x, y } = axialToPixel(mouseHex.q, mouseHex.r);
		
		let cur_highlight =  mouseHex.q+", "+mouseHex.r;
		
		// run isPlacementValid() only when mouse has moved to new hex:
		if(prev_highlight !== cur_highlight){
			//console.warn("prev_drawPlacementHighlight !== curstr");
			
			const buildCheck = isPlacementValid(placingUnit.type, mouseHex, getMyPlayer());
			cur_buildCheck = buildCheck;
			prev_highlight = cur_highlight;
		}

		// draw always with cached info:
		drawHexagonPath(x, y);
		if (cur_buildCheck.valid) {
			ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
		} else {
			ctx.fillStyle = 'rgba(255, 0, 255, 0.4)';
		}
		ctx.fill();
	}
}



function drawUnitSelection(){
	if(selectedUnit){
		const { x, y } = axialToPixel(selectedUnit.q, selectedUnit.r);
		drawHexagonPathLines(x, y);

		// your pool highlight
		ctx.setLineDash([12.5, 15]);
		ctx.strokeStyle = 'rgba(255,255,255, 1)';
		ctx.lineWidth = 4;
		ctx.lineCap = 'round';
		ctx.stroke();
		ctx.lineCap = 'butt'; // reset to default
		ctx.setLineDash([]);

	}
}


function render() {
	if (!gameState.settings.gameStarted) return;
	
	trackFPS();

	// calculate current mip level:
	zoomMipLevel = getZoomMipLevel(1); // use normal. smaller = earlier switch to smaller image

	//console.log(tileZoomMipLevel);
  
	// Save the context state
	ctx.save();
	drawInfiniteWater();

	ctx.translate(viewport.x, viewport.y);
	ctx.scale(viewport.zoom, viewport.zoom);
	

	// MAP TILE DRAWING:
	drawMapTiles();

	// HIGHLIGHTS DRAWING:
	drawHighlights();
	
	// OBJECTS DRAWING:
	drawObjects();
	
	// MOVEMENT RANGE DRAWING:
	//drawMovementRanges();
	
	// UNIT SELECTION DRAWING:
	drawUnitSelection();
	
	// PLACEMENT HIGHLIGHT DRAWING:
	//drawPlacementHighlight();
	
	// UNITS DRAWING:
	drawUnits();
	

	ctx.restore();
	
	requestAnimationFrame(render);
}




let lastMousePos = { x: 0, y: 0 };

function handleCanvasMouseMove(e) {
	//console.log("handleCanvasMouseMove");
	
	lastMousePos.x = e.clientX;
	lastMousePos.y = e.clientY;
	
	if (dragStart && dragStart.canDrag) {
		const dx = e.clientX - dragStart.x;
		const dy = e.clientY - dragStart.y;
		
		if (!isDragging && Math.hypot(dx, dy) > 5) {
			isDragging = true;
		}
		
		if (isDragging) {
			viewport.x += dx;
			viewport.y += dy;
			dragStart.x = e.clientX;
			dragStart.y = e.clientY;
		}
	}
}

function handleCanvasMouseDown(e) {
	//console.log("handleCanvasMouseDown");
	
	isDragging = false; // Reset dragging flag
	dragStart = { x: e.clientX, y: e.clientY };
	
	//const clickedHex = pixelToAxial(e.clientX, e.clientY);
	//const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);
	
	// Don't drag if we click a unit
	//if (!unitOnHex) {
		dragStart.canDrag = true;
	//} else {
	//	dragStart.canDrag = false;
	//}
}

function handleCanvasMouseUp(e) {
	//console.log("handleCanvasMouseUp");
	
	if(dragStart){
		const dx = e.clientX - dragStart.x;
		const dy = e.clientY - dragStart.y;
		const dist = Math.sqrt(dx*dx + dy*dy);
		
		if (dist < 5) { // It's a click, not a drag
			handleHexClick(pixelToAxial(e.clientX, e.clientY));
		}
		isDragging = false;
		dragStart = null;
	}
}

// --- Touch controls ---
let touchStartPos = null;
let lastTouch = null;
let lastDist = null; // for pinch-zoom


/*
function handleTouchStart(e) {
	if (e.touches.length === 1) {
		// Single touch (drag or tap)
		const touch = e.touches[0];
		isDragging = false;
		touchStartPos = { x: touch.clientX, y: touch.clientY };
		
		const clickedHex = pixelToAxial(touch.clientX, touch.clientY);
		const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);
		
		touchStartPos.canDrag = !unitOnHex;
		lastTouch = { x: touch.clientX, y: touch.clientY };
		lastDist = null;
	} else if (e.touches.length === 2) {
		// Pinch-zoom
		isDragging = false; // Stop dragging
		touchStartPos = null;
		lastDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
	}
}
*/

function isBuildPopupOpen(){
	return buildPopup.style.display !== 'none';
}


function handleTouchStart(e) {
	//console.log("handleTouchStart");
	
    const touch = e.touches[0];
    const target = document.elementFromPoint(touch.clientX, touch.clientY);

	if(!placingUnit){
		const touchedOutside =
			!buildPopup.contains(target) &&
			!buildSoldierBtn.contains(target) &&
			!buildCastleBtn.contains(target);

		if (touchedOutside && isBuildPopupOpen()) {
			closeBuildPopup();
		}
	}

    if (e.touches.length === 1) {
		//console.log("e.touches.length === 1");
        isDragging = false;
        touchStartPos = { x: touch.clientX, y: touch.clientY };

        const clickedHex = pixelToAxial(touch.clientX, touch.clientY);
        const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);

		touchStartPos.canDrag = true; // always allow dragging while doing things
        //touchStartPos.canDrag = !unitOnHex;
		//touchStartPos.canDrag = !placingUnit;
        lastTouch = { x: touch.clientX, y: touch.clientY };
        lastDist = null;

    } else if (e.touches.length === 2) {
		//console.log("e.touches.length === 2");
		// cancel drag, start zooming by pinching.
        isDragging = false;
        touchStartPos = null;
        lastDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
    }
}



function handleTouchMove(e) {
	//console.log("handleTouchMove");
		
	lastMousePos.x = e.touches[0].clientX; // for placement cursor
	lastMousePos.y = e.touches[0].clientY;

	if (e.touches.length === 1 && touchStartPos && touchStartPos.canDrag) {
		// Dragging
		const touch = e.touches[0];
		const dx = touch.clientX - lastTouch.x;
		const dy = touch.clientY - lastTouch.y;
		
		if (!isDragging && Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y) > 5) {
			isDragging = true; // Started dragging
		}
		
		if (isDragging) {
			viewport.x += dx;
			viewport.y += dy;
		}
		lastTouch.x = touch.clientX;
		lastTouch.y = touch.clientY;

	} else if (e.touches.length === 2 && lastDist) {
		// Pinch-zoom
		const newDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
		
		const zoomFactor = newDist / lastDist;
		
		// Get center of pinch
		const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
		const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

		zoomAtPoint(midX, midY, zoomFactor);

		lastDist = newDist;
	}
}

function handleTouchEnd(e) {
	//console.log("handleTouchEnd");
	
	if (e.touches.length === 0 && touchStartPos && !isDragging) {
		// This was a tap
		handleHexClick(pixelToAxial(touchStartPos.x, touchStartPos.y));
	}
	
	
	if (e.touches.length < 2) {
		lastDist = null; // Stop zooming
	}
	if (e.touches.length < 1) {
		isDragging = false; // Stop dragging
		touchStartPos = null;
		lastTouch = null;
	}
}




function getZoomMipLevel(multiplier){
	const safeZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, viewport.zoom));
	return Math.min(
		6 - 1,
		Math.max(0, Math.round(-Math.log2(safeZoom * multiplier))) // smaller multiplier = earlier mip change to smaller
	);
}

function zoomAtPoint(x, y, factor) {
	const newZoom = Math.max(MIN_ZOOM, Math.min(viewport.zoom * factor, MAX_ZOOM));
	const oldZoom = viewport.zoom;
	
	viewport.x = x - (x - viewport.x) * (newZoom / oldZoom);
	viewport.y = y - (y - viewport.y) * (newZoom / oldZoom);
	viewport.zoom = newZoom;

	//console.log(zoomMipLevel);
}


function handleWheel(e) {
	e.preventDefault();
	const zoomFactor = (e.deltaY < 0) ? 1.1 : (1 / 1.1);
	zoomAtPoint(e.clientX, e.clientY, zoomFactor);
}

// =================================================================
// --- GAME LOGIC HELPERS
// =================================================================


function getMapBounds(){
	return gameState.map.bounds;
}

function getTileAt(q, r) {
	let tileKey = `${q},${r}`;
	let tileIndex = gameState.map.tiles[tileKey];
	return gameState.map.tilesData[tileIndex];
}


// if tile doesnt exist: new tile created, if not: modifying the tile.
function setTileAt(q, r, tileData) {
	let tileKey = `${q},${r}`;

	if (Object.hasOwn(gameState.map.tiles, tileKey)) {
		// modify already existing tile:
		let tileIndex = gameState.map.tiles[tileKey];
		gameState.map.tilesData[tileIndex] = {...gameState.map.tilesData[tileIndex], ...tileData};
	}else{
		// add new tile:
		let tileIndex = gameState.map.tilesData.length;
		gameState.map.tilesData.push({q, r, tileIndex, ...tileData});
		gameState.map.tiles[tileKey] = tileIndex;
	}
}

function setTileOwner(tile, ownerId){
	tile.ownerId = ownerId;
	if(ownerId){
		tile.ownerIndex = getPlayerIndex(ownerId);
	}else{
		tile.ownerIndex = null;
	}
}


// will set water outline to the tile, or if doesnt exist yet, adds new tile with that info.
function setOutlineAt(q, r, lines) {
	setTileAt(q, r, {outline: lines});
}

function getUnitAt(q, r) {
	return gameState.units.find(u => u.q === q && u.r === r);
}

function getCurrentTurnPlayer() {
	if (!gameState.settings.gameStarted) return null;
	return gameState.players[gameState.turn.currentPlayerIndex];
}

function isMyTurn() {
	const currentTurnPlayer = getCurrentTurnPlayer();
	return currentTurnPlayer && currentTurnPlayer.id === localPlayer.id;
}


// updateui update ui
function updateGameUI() {
	if (!gameState.settings.gameStarted) return;
	
	const myPlayer = getMyPlayer();
	const currentTurnPlayer = getCurrentTurnPlayer();
	
	// Update player list
	playerUIList.innerHTML = '';
	gameState.players.forEach(p => {
		const item = document.createElement('div');
		item.className = 'player-list-item';
		if (p.id === currentTurnPlayer?.id) {
			item.classList.add('current-turn');
		}
		let color = p.color;
		let specTag = "";
		if(p.isSpectator){
			color = "white";
			specTag = "(spec)";
		}
		if(!p.quitted){
			item.innerHTML = `
				<span class="player-turn-indicator"></span>
				<span style="color: ${color}; font-weight: bold;" class="namevals"></span>
			`;
			const safeName = document.createTextNode(`${p.name} ${specTag}`);
			item.querySelector("span.namevals").appendChild(safeName);
			playerUIList.appendChild(item);
		}
	});

	// Update turn info
	turnInfo.textContent = `Day ${gameState.turn.turnNumber}`;
	
	// Update buttons
	const canPlay = isMyTurn() && !myPlayer.isSpectator;
	buildSoldierBtn.disabled = !canPlay;
	buildCastleBtn.disabled = !canPlay;
	endTurnBtn.disabled = !canPlay;
	
	
	
	///////////////////////////////
	// THIS WONT WORK SINCE CLIENTS DOESNT HAVE currentTurnActions array, its empty! only host keeps track of it...
	let undoDisabled = !canPlay;
	if(canPlay){
		//console.log("currentTurnActions len = "+currentTurnActions.length);
		//console.log(currentTurnActions);
		if(currentTurnActions && currentTurnActions.length > 0){
			undoDisabled = false;
		}else{
			undoDisabled = true;
		}
		//console.log("undoDisabled: "+undoDisabled);
	}else{
		//console.log("cant play: undoDisabled: "+undoDisabled);
	}
	
	undoBtn.disabled = !canPlay; // need to fix this so all clients will also know if they have undo remaining.
	chatInput.disabled = false;

	
	// Update savings
	if (myPlayer && !myPlayer.isSpectator) {
		playerSavings.textContent = `Savings: ${myCurrentSavings}`;
	} else {
		playerSavings.textContent = "Spectating";
	}
}

function getMyTotalSavings() {
	// This is now just a client-side getter
	return myCurrentSavings;
}

// =================================================================
// --- GAME LOGIC - ACTIONS
// =================================================================

function isHexWater(q, r){
	const tile = getTileAt(q, r);
	if(!tile){ // out of bounds, mark as water:
		return true;
	}else if(tile.type == "water"){
		return true;
	}
	return false;
}



function handleHexClick(hex) {
	// dont allow selecting while moving on the map.
	if(isDragging){
		return;
	}
	const myPlayer = getMyPlayer();
	if (!myPlayer || myPlayer.isSpectator || !isMyTurn()) {
	
		
		if(!isHexWater(hex.q, hex.r)){

			// Spectator or not my turn, just select hex for highlighting pools:
			selectedHex = hex;
			selectedUnit = null; // Deselect
			
			buildPopup.style.display = 'none'; // not sure why this is here, maybe possible if somehow managed to end turn while popup is active?
			updateHighlights();
			
			
			/*
			let unitOnHex = getUnitAt(hex.q, hex.r);
			if(unitOnHex && unitOnHex.ownerId === myPlayer.id){
				// allow only selecting your own units:
				selectedUnit = unitOnHex;
				console.log("selectedUnit:");
				console.log(selectedUnit);

				placingUnit = null;
				buildPopup.style.display = 'none';
				updateHighlights();
			}else{
				selectedUnit = null; // Deselect
				selectedHex = null;
			}
			*/
		}else{
			selectedUnit = null; // Deselect
			selectedHex = null;
		}
		return;
	}
	


	// --- PLACING A UNIT ---
	if (placingUnit) {
		const buildCheck = isPlacementValid(placingUnit.type, hex, myPlayer);
		if (buildCheck.valid) {
			sendToHost({
				type: 'action_build',
				unitType: placingUnit.type,
				q: hex.q,
				r: hex.r
			});
		} else {
			playSound('protect');
		}
		placingUnit = null; // "deselect", must do that because there is no cancel button (yet?)
		updateHighlights();
		return;
	}
	
	// --- MOVING A UNIT ---
	if (selectedUnit) {
		
		let deselected = false;

		if(hex.q === selectedUnit.q && hex.r === selectedUnit.r){
			// deselect if clicked same unit again:
			selectedUnit = null;
			selectedHex = null;
			deselected = true;
		}

		
		if(!deselected){
			// Check if clicking a valid move hex
			// validMoveHexes = highlighted move area.
			const isValidMove = validMoveHexes.some(h => h.q === hex.q && h.r === hex.r);
			//const unitOnHex = getUnitAt(hex.q, hex.r);
			//console.error(unitOnHex);
			//if (unitOnHex && unitOnHex.type === 'castle'){
			//	isValidMove = false;
			//}
			
			console.log("isValidMove: "+isValidMove);
			
		
			if (isValidMove) {
				sendToHost({
					type: 'action_move',
					unitId: selectedUnit.id,
					toQ: hex.q,
					toR: hex.r
				});
				// Deselect
				selectedUnit = null;
				selectedHex = null;
			} else {
				// Clicked somewhere else, check for new selection
				if(!isHexWater(hex.q, hex.r)){
					const isInvalidMove = invalidMoveHexes.some(h => h.q === hex.q && h.r === hex.r);
					if(isInvalidMove){
						playSound("protect");
					}
					
					const unitOnHex = getUnitAt(hex.q, hex.r);
					if(unitOnHex){
						if (unitOnHex.ownerId === localPlayer.id) {
							if(unitOnHex.internalType === 'soldier' && !unitOnHex.hasMoved){
								selectedUnit = unitOnHex; // Select new unit
								selectedHex = hex;
								playSound('startmove');
							}
						}else{
							// deselect when clicking enemy unit that was not protected:
							if(!isInvalidMove){
								selectedUnit = null; // Deselect
								selectedHex = hex;
								console.log("deselected");
							}
						}
					}else{
						// deselect when clicked just land that was not protected:
						if(!isInvalidMove){
							selectedUnit = null; // Deselect
							selectedHex = hex;
							console.log("deselected");
						}
					}
				}else{
					selectedUnit = null; // Deselect
					selectedHex = null;
				}
			}
		}
	} else {
		// --- SELECTING AN UNIT ---
		if(!isHexWater(hex.q, hex.r)){
			const unitOnHex = getUnitAt(hex.q, hex.r);
			

		

			if (unitOnHex && unitOnHex.ownerId === localPlayer.id) {
				// allow only selecting soldiers
				if(unitOnHex.internalType === 'soldier'){
					if(!unitOnHex.hasMoved){
						console.log("selected new unit");
						selectedUnit = unitOnHex;
						selectedHex = hex;
						if(!selectedUnit.hasMoved){
							playSound('startmove');
						}
					}
				}else{
					// dont allow selecting castles.
					selectedUnit = null;
					selectedHex = hex;
				}
			} else {
				selectedUnit = null;
				selectedHex = hex;
			}

		}else{
			selectedUnit = null; // Deselect
			selectedHex = null;
		}
	}
	
	updateHighlights();
}




function findUnitPossibleMoves(this_selectedUnit, player){
	let this_poolStartHex = this_selectedUnit;
	let this_highlightedPool = [];
	let this_validMoveHexes = [];
	let this_invalidMoveHexes = [];
	
	const tile = getTileAt(this_poolStartHex.q, this_poolStartHex.r);
	if (tile && tile.ownerId === player.id) {
		// Run BFS to find all connected friendly hexes
		const queue = [{q: this_poolStartHex.q, r: this_poolStartHex.r}];
		const visited = new Set([`${this_poolStartHex.q},${this_poolStartHex.r}`]);
		
		while (queue.length > 0) {
			const current = queue.shift();
			this_highlightedPool.push(current);
			
			for (const n of getHexNeighbors(current.q, current.r)) {
				const nKey = `${n.q},${n.r}`;
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerId === player.id && !visited.has(nKey)) {
					visited.add(nKey);
					queue.push(n);
				}
			}
		}
	}
	
	const borderHexes = new Map(); // Use Map to avoid duplicates, key 'q,r'
	
	// Add all empty hexes *in* the pool as valid moves
	for (const hex of this_highlightedPool) {
		// removing this fixes bug not allowing moving around selected unit:
		//if (hex.q === selectedUnit.q && hex.r === selectedUnit.r) continue;
		if (!getUnitAt(hex.q, hex.r)) {
			this_validMoveHexes.push(hex);
		}
		
		// While we're here, find all neighbors to build the border set
		for (const n of getHexNeighbors(hex.q, hex.r)) {
			const nKey = `${n.q},${n.r}`;
			const nTile = getTileAt(n.q, n.r);
			// If neighbor exists, is not water, and is not in our pool
			if (nTile && nTile.type !== 'water' && !this_highlightedPool.some(p => p.q === n.q && p.r === n.r)) {
				borderHexes.set(nKey, n);
			}
		}
	}
	
	// Now check all border hexes for validity
	for (const [key, hex] of borderHexes.entries()) {
		const toTile = getTileAt(hex.q, hex.r); // We know this tile exists and isn't water
		const targetUnit = getUnitAt(hex.q, hex.r);
		const shieldLevel = getShieldLevel(hex.q, hex.r, player.id);

		if (targetUnit) {
			if (targetUnit.ownerId === player.id) continue; // Should be impossible
			if (this_selectedUnit.level > shieldLevel && this_selectedUnit.level > targetUnit.level) {
				this_validMoveHexes.push(hex);
			} else {
				this_invalidMoveHexes.push(hex);
			}
		} else { // No target unit
			if (toTile.ownerId !== null) { // Enemy land
				if (this_selectedUnit.level > shieldLevel) {
					this_validMoveHexes.push(hex);
				} else {
					this_invalidMoveHexes.push(hex);
				}
			} else { // Unowned land
				// Shields don't apply to unowned land
				this_validMoveHexes.push(hex);
			}
		}
	}
	//console.warn("this_validMoveHexes");
	//console.warn(this_validMoveHexes);
	return this_validMoveHexes;
}




function updateHighlights() {
	// Clear all highlights
	highlightedPool = [];
	validMoveHexes = [];
	invalidMoveHexes = [];
	
	enemyHighlightedPool = [];
	
	let poolStartHex = null;
	if (selectedUnit) {
		poolStartHex = selectedUnit;
	} else if (selectedHex) {
		poolStartHex = selectedHex;
	}
	
	const myPlayer = getMyPlayer();
	if (!myPlayer) return;

	// --- 1. Find the connected pool ---
	if (poolStartHex) {
		const tile = getTileAt(poolStartHex.q, poolStartHex.r);
		if (tile) {
			if(tile.ownerId === myPlayer.id){
				// Run BFS to find all connected friendly hexes
				const queue = [{q: poolStartHex.q, r: poolStartHex.r}];
				const visited = new Set([`${poolStartHex.q},${poolStartHex.r}`]);
				
				while (queue.length > 0) {
					const current = queue.shift();
					highlightedPool.push(current);
					
					for (const n of getHexNeighbors(current.q, current.r)) {
						const nKey = `${n.q},${n.r}`;
						const nTile = getTileAt(n.q, n.r);
						if (nTile && nTile.ownerId === myPlayer.id && !visited.has(nKey)) {
							visited.add(nKey);
							queue.push(n);
						}
					}
				}
			}else if(tile.ownerId){
				// create highlight for enemy pools:
				
				// Run BFS to find all connected friendly hexes
				const queue = [{q: poolStartHex.q, r: poolStartHex.r}];
				const visited = new Set([`${poolStartHex.q},${poolStartHex.r}`]);
				
				while (queue.length > 0) {
					const current = queue.shift();
					enemyHighlightedPool.push(current);
					
					for (const n of getHexNeighbors(current.q, current.r)) {
						const nKey = `${n.q},${n.r}`;
						const nTile = getTileAt(n.q, n.r);
						if (nTile && nTile.ownerId === tile.ownerId && !visited.has(nKey)) {
							visited.add(nKey);
							queue.push(n);
						}
					}
				}
			}
		}
	}
	
	// --- 2. Highlight movement options (only if a unit is selected) ---
	if (selectedUnit) {
		const borderHexes = new Map(); // Use Map to avoid duplicates, key 'q,r'
		
		// Add all empty hexes *in* the pool as valid moves
		for (const hex of highlightedPool) {
			// removing this fixes bug not allowing moving around selected unit:
			// todo: might actually make another bug that allows moving always to neighbours...
			//if (hex.q === selectedUnit.q && hex.r === selectedUnit.r) continue;
			if (!getUnitAt(hex.q, hex.r)) {
				// todo: move this elsewhere.. might fuck up stuff.
				validMoveHexes.push(hex);
			}
			
			// While we're here, find all neighbors to build the border set
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nKey = `${n.q},${n.r}`;
				const nTile = getTileAt(n.q, n.r);
				// If neighbor exists, is not water, and is not in our pool
				if (nTile && nTile.type !== 'water' && !highlightedPool.some(p => p.q === n.q && p.r === n.r)) {
					borderHexes.set(nKey, n);
				}
			}
		}
		
		// Now check all border hexes for validity
		for (const [key, hex] of borderHexes.entries()) {
			const toTile = getTileAt(hex.q, hex.r); // We know this tile exists and isn't water
			const targetUnit = getUnitAt(hex.q, hex.r);
			const shieldLevel = getShieldLevel(hex.q, hex.r, myPlayer.id);


			if (targetUnit) {
				if (targetUnit.ownerId === myPlayer.id){
					continue; // Should be impossible
				}
				if (selectedUnit.level > shieldLevel && selectedUnit.level > targetUnit.level) {
					validMoveHexes.push(hex);
				} else {
					invalidMoveHexes.push(hex);
				}
			} else { // No target unit
				if (toTile.ownerId !== null) { // Enemy land
					if (selectedUnit.level > shieldLevel) {
						validMoveHexes.push(hex);
					} else {
						invalidMoveHexes.push(hex);
					}
				} else { // Unowned land
					// Shields don't apply to unowned land
					validMoveHexes.push(hex);
				}
			}
		}
	}
}



function openBuildPopup(type) {
	placingUnit = null;
	selectedUnit = null;
	selectedHex = null;
	
	const data = (type === 'soldier') ? SOLDIER_DATA : CASTLE_DATA;
	const mySavings = getMyTotalSavings();
	
	let buildprefix = "Buy";
	let buildsuffix = type;
	if(type == "castle"){
		buildprefix = "Build";
		buildsuffix = "castle";
	}else if(type == "soldier"){
		buildprefix = "Recruit";
		buildsuffix = "warrior";
	}
	buildPopupTitle.textContent = `${buildprefix} ${buildsuffix}`;
	buildPopupList.innerHTML = '';
	
	for (const key in data) {
		const item = data[key];
		const canAfford = mySavings >= item.cost;
		const itemEl = document.createElement('div');
		itemEl.className = 'build-item';
		if (!canAfford) itemEl.classList.add('disabled');
		let imagePath = getImagePath(item);
		// <span>${item.name} (Lvl ${item.level})</span>
		itemEl.innerHTML = `
			<span><img src="${imagePath}" width="50"></span>
			<span class="cost"><span style="color:white">Cost:</span> ${item.cost}${item.wage ? `<br><span style="color:white">Wage:</span> ${item.wage}` : ''}</span>
		`;
		
		if (canAfford) {
			itemEl.onclick = () => {
				placingUnit = {
					type: item.name, // "soldier" etc.
					cost: item.cost,
				};
				buildPopup.style.display = 'none';
			};
		}
		buildPopupList.appendChild(itemEl);
	}
	buildPopup.style.display = 'block';
}



function getUnitLevel(unitType){
	if(SOLDIER_DATA[unitType]){
		return SOLDIER_DATA[unitType].level;
	}
	if(CASTLE_DATA[unitType]){
		return CASTLE_DATA[unitType].level;
	}
	return 0; // fallback.
}


// iscastle is_castle
function isTypeCastle(unitType){
	return !!CASTLE_DATA[unitType];
}

function isCastle(unit){
	return unit && unit.internalType === 'castle';
}




function getShieldLevel_orig(q, r, perspectiveOwnerId) {
	let maxShield = 0;
	for (const n of getHexNeighbors(q, r)) {
		const unit = getUnitAt(n.q, n.r);
		if (unit && unit.ownerId !== perspectiveOwnerId) {
			// It's an enemy unit
			maxShield = Math.max(maxShield, unit.level);
		}
	}
	return maxShield;
}


function getShieldLevel(q, r, perspectiveOwnerId) {
	let maxShield = 0;
	const tile = getTileAt(q, r);
	
	for (const n of getHexNeighbors(q, r)) {
		const unit = getUnitAt(n.q, n.r);
		//const nTile = getTileAt(n.q, n.r);
		if (tile && unit){
			if (tile.ownerId === unit.ownerId){
				if (unit.ownerId !== perspectiveOwnerId) {
					// It's an enemy unit
					maxShield = Math.max(maxShield, unit.level);
				}
			}
		}
	}
	return maxShield;
}




function goodMove(action, target = null){
	const move = { valid: true, action: action, target: target };
	console.warn(move);
	return move;
}
function badMove(reason){
	const move = { valid: false, reason: reason };
	console.warn(move);
	return move;
}



// --- HOST-SIDE VALIDATION ---

function isMoveValid(unit, toHex, player) {
	if (unit.hasMoved){
		return badMove('Unit has already moved.');
	}
	if(unit.internalType === 'castle'){
		return badMove('Cannot move castles.');
	}

	const toTile = getTileAt(toHex.q, toHex.r);
	if (!toTile || toTile.type === 'water'){
		return badMove('Cannot move into water.');
	}
	
	const targetUnit = getUnitAt(toHex.q, toHex.r);

	// Find the unit's entire pool
	const unitPool = [];
	const queue = [{q: unit.q, r: unit.r}];
	const visited = new Set([`${unit.q},${unit.r}`]);
	
	while(queue.length > 0) {
		const current = queue.shift();
		unitPool.push(current);
		
		for (const n of getHexNeighbors(current.q, current.r)) {
			const nKey = `${n.q},${n.r}`;
			const nTile = getTileAt(n.q, n.r);
			if (nTile && nTile.ownerId === player.id && !visited.has(nKey)) {
				visited.add(nKey);
				queue.push(n);
			}
		}
	}
	
	// --- Case 1: Moving onto own tile (inside the pool) ---
	const isMovingInPool = unitPool.some(h => h.q === toHex.q && h.r === toHex.r);
	if (isMovingInPool) {
		if (targetUnit){
			return badMove('Cannot move onto own unit.');
		}
		return goodMove('move');
	}

	// --- Case 2: Moving outside the pool ---
	// Check if toHex is a neighbor of *any* hex in the pool
	let isBorderHex = false;
	for (const poolHex of unitPool) {
		if (getHexDistance(poolHex.q, poolHex.r, toHex.q, toHex.r) === 1) {
			isBorderHex = true;
			break;
		}
	}

	if (!isBorderHex) {
		return badMove('Too far.');
	}
	
	// It's a valid border hex, now check shields and targets
	const shieldLevel = getShieldLevel(toHex.q, toHex.r, player.id);

	if (targetUnit) {
		if (targetUnit.ownerId === player.id) {
			return badMove('Cannot move onto own unit.'); // Should be caught by pool check, but safe
		}
		if (unit.level > shieldLevel && unit.level > targetUnit.level) {
			return goodMove('attack', targetUnit);
		} else {
			return badMove('Target unit level is too high or shielded.');
		}
	}
	
	// No target unit
	if (toTile.ownerId !== null) { // It's enemy land
		if (unit.level > shieldLevel) {
			return goodMove('move');
		} else {
			// todo: think again....
			if(toTile.ownerId !== unit.ownerId){
				return badMove('Blocked by enemy shield.');
			}else{
				return goodMove('move');
			}
		}
	} else { // It's unowned land
		// New rule: Shields do not block movement to unowned land
		return goodMove('move');
	}
}



// --- HOST-SIDE VALIDATION ---
// unitType = unit type being built (horse, peasant, etc..)
// hex      = where he builds it
// player   = who builds it
let prevhex = "";

let placementframe = 0;

// isvalidplacement
function isPlacementValid(unitType, hex, player) {
	//placementframe++;
	//console.log("placementframe: "+placementframe);

	//return isMoveValid(unit, hex, player);
	
	let unitLevel = getUnitLevel(unitType);
	
	let logallowed = prevhex !== (hex.q+","+hex.r);
	if(logallowed){
		//console.log("unitType = "+unitType);
		//console.log("hex = "+hex.q+","+hex.r);
		//console.log("player.id = "+player.id);
		prevhex = hex.q+","+hex.r;
	}
	
	
	const tile = getTileAt(hex.q, hex.r);
	if (!tile || tile.type === 'water'){
		return badMove("must be on land"); // Must be on land
	}
	
	// if there is an unit on the hex:
	const hexUnit = getUnitAt(hex.q, hex.r);
	if (hexUnit){
		//console.log("hexUnit exists:");
		//console.log(hexUnit);
		
		// checks for castles and soldiers placement too.
		if(hexUnit.ownerId === player.id){
			return badMove("must be empty"); // Must be empty
		}else{
			// if trying to kill enemy player:
			// todo: probably need to check if trying to place castle, 
			//       so it wont allow placing castle on top of enemy soldier.
			
			//console.log("hexUnit.ownerId !== player.id");
			
			// Check if any neighbour is my land:
			let isNeighborOwned = false;
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerId === player.id) {
					isNeighborOwned = true;
					break;
				}
			}
			// if not in build radius:
			if (!isNeighborOwned){
				return badMove("out of range");
			}else{

				// if it was in build radius:
				let shieldLevel = getShieldLevel(tile.q, tile.r, player.id);
				// if the enemy unit level was higher than placed unit level:
				if(shieldLevel >= unitLevel || hexUnit.level >= unitLevel){
					return badMove("level is too low");
				}else{
					return goodMove('attack', hexUnit);
				}
			}
		}
	}
	
	// if new unit is a castle:
	if (isTypeCastle(unitType)) {
		// if not your tile:
		if (tile.ownerId !== player.id){
			if(logallowed){
				//console.log("trying to place castle");
				//console.log("tile.ownerId !== player.id");
				//console.log(tile.ownerId+" != "+player.id);
			}
			return badMove("must own hex"); // Must own hex
		}
		// if there is object:
		// original game allows placing castles on objects.
		//if (tile.object){
		//	return badMove("tile has object"); // not sure if original game had this rule: Must be clear (no tree/grass)
		//}
	} else {
		// if new unit is a soldier:
		// Rules are "neighbouring land I own, or in the land I own"
		
		// if new place is not your land:
		if (tile.ownerId !== player.id) {
			if(logallowed){
				//console.log("trying to place soldier");
				//console.log("tile.ownerId !== player.id");
				//console.log(tile.ownerId+" != "+player.id);
			}
			
			// Check if any neighbour is my land:
			let isNeighborOwned = false;
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerId === player.id) {
					isNeighborOwned = true;
					break;
				}
			}
			
			// if not in build radius:
			if (!isNeighborOwned){
				return badMove("out of range");
			}else{
				// if it was in build radius:
				let shieldLevel = getShieldLevel(tile.q, tile.r, player.id);
				// if the enemy unit level was higher than placed unit level:
				if(shieldLevel >= unitLevel){
					return badMove("level is too low");
				}
			}
		}
	}
	
	
	return goodMove('move');
}




function isAiPlayer(playerId){
	let player = getPlayer(playerId);
	return player && player.isAI;
}


// gets the amount of money you get by selling a soldier.
function getUnitSellPrice(unit){
	let unitInfo = SOLDIER_DATA[unit.type];
	if(unitInfo){
		return unitInfo.sell;
	}
	return 0;
}



function executeAction(playerId, action) {
	//console.log("executeAction");
	// HOST-ONLY function
	if (!localPlayer.isHost) return;
	//console.log("executeAction 2");
	
	const player = getPlayer(playerId);
	if (!player || player.id !== getCurrentTurnPlayer()?.id) {
		console.warn(`Action from wrong player: ${playerId}`);
		return;
	}
	
	//console.log("executeAction 3");
	
	let updates = []; // Array of update messages to broadcast
	let sounds = []; // Array of sounds to broadcast
	let actionForUndo = null;
	let affectedPlayers = new Set([playerId]); // Track who needs savings update

	switch (action.type) {
		case 'action_sell': {
			// sell unit
			
			//console.log("executeAction: action_sell");
			
			const { unitId } = action;
			const unit = gameState.units.find(u => u.id === unitId);
			if (!unit || unit.ownerId !== playerId) return;
			
			let sellPrice = getUnitSellPrice(unit);
			
			actionForUndo = {
				type: 'sell', 
				soldUnit: unit, 
				sellPrice: sellPrice,
			};
			
			const pools = findEconomyPools(playerId);
			addCost(pools, sellPrice);
			
			// remove unit:
			gameState.units = gameState.units.filter(u => u.id !== unit.id);
			updates.push({ type: 'unit_removed', unitId: unit.id });
			
			if(!isAiPlayer(playerId)){
				sounds.push('sell');
			}
			break;
		}
		case 'action_move': {
			// move unit
			
			//console.log("executeAction action_move");
			
			const { unitId, toQ, toR } = action;
			const unit = gameState.units.find(u => u.id === unitId);
			if (!unit || unit.ownerId !== playerId) return;
			
			const moveCheck = isMoveValid(unit, { q: toQ, r: toR }, player);
			if (moveCheck.valid) {
				const fromQ = unit.q;
				const fromR = unit.r;
				const toTile = getTileAt(toQ, toR);
				const oldOwner = toTile.ownerId;
				const oldObject = toTile.object;
				
				actionForUndo = {
					type: 'move',
					unitId: unit.id,
					fromQ, fromR,
					toQ, toR,
					didClaim: oldOwner !== playerId,
					oldOwner: oldOwner,
					clearedObject: oldObject,
				};
				
				if (moveCheck.action === 'attack') {
					const targetUnit = moveCheck.target;
					actionForUndo.killedUnit = { ...targetUnit }; // Store copy
					gameState.units = gameState.units.filter(u => u.id !== targetUnit.id);
					updates.push({ type: 'unit_removed', unitId: targetUnit.id });
					if(!isAiPlayer(playerId)){
						sounds.push(CASTLE_DATA[targetUnit.type] ? 'destroy' : 'kill');
					}
					
					//console.warn("moveCheck.action === 'attack'");
				}
				
				//console.warn("actionForUndo1");
				//console.warn(actionForUndo);
				
				// Move unit
				unit.q = toQ;
				unit.r = toR;
				unit.hasMoved = true;
				updates.push({ type: 'unit_moved', unitId: unit.id, q: toQ, r: toR, hasMoved: true });
				
				// Claim hex
				if (toTile.ownerId !== playerId) {
					setTileOwner(toTile, playerId);
					//toTile.ownerId = playerId;
					updates.push({ type: 'tile_changed', q: toQ, r: toR, ownerId: playerId });
					if(!isAiPlayer(playerId)){
						if (!toTile.object) {
							sounds.push('moveunit');
						}
					}
				}else{
					// if moved inside own pool, play also sound.
					if(!isAiPlayer(playerId)){
						if (!toTile.object) {
							sounds.push('moveunit');
						}
					}
				}
				
				if (toTile.object) {
					if(!isAiPlayer(playerId)){
						if(toTile.object === 'tree'){
							sounds.push('claimTree');
						}else if(toTile.object === 'grass'){
							sounds.push('claimGrass');
						}else{
							sounds.push('moveunit');
						}
					}
					toTile.object = null;
					updates.push({ type: 'tile_changed', q: toQ, r: toR, object: null });
					

				}
				
				distributePoolSavings(findEconomyPools(playerId));
				if (oldOwner) {
					affectedPlayers.add(oldOwner);
					distributePoolSavings(findEconomyPools(oldOwner));
				}
				
				//console.warn(actionForUndo);
				
			}
			break;
		}
		
		case 'action_build': {
			// build unit
			
			//console.log("executeAction action_build");
			
			const { unitType, q, r } = action;
			const data = SOLDIER_DATA[unitType] || CASTLE_DATA[unitType];
			if (!data) return;
			
			const buildCheck = isPlacementValid(unitType, {q, r}, player);
			if (buildCheck.valid) {
				const pools = findEconomyPools(playerId);
				let totalSavings = 0;
				pools.forEach(p => totalSavings += p.totalSavings);
				
				if (totalSavings >= data.cost) {
					deductCost(pools, data.cost);
					
					const newUnit = {
						id: getUID(),
						ownerId: playerId,
						q: q, 
						r: r,
						type: unitType,
						level: data.level,
						hasMoved: true,
						ownerIndex: getPlayerIndex(playerId),
						internalType: data.type,
					};
					//console.log("action_build: gameState.units.push(newUnit);");
					//console.log(newUnit);
					
					
					//gameState.units.push(newUnit); // if used here then host gets the unit double!
					
					let didClaim = false;
					
					const tile = getTileAt(q, r);
					const oldOwner = tile.ownerId;
					
					if (!isCastle(newUnit) && tile.ownerId !== playerId) {
						//tile.ownerId = playerId;
						setTileOwner(tile, playerId);
						didClaim = true;
						updates.push({ type: 'tile_changed', q: q, r: r, ownerId: playerId });
						if(!isAiPlayer(playerId)){
							if (!tile.object) {
								sounds.push('moveunit');
							}
						}
					}else{
						if(!isAiPlayer(playerId)){
							if (!tile.object) {
								sounds.push('moveunit');
							}
						}
					}
					
					let clearedObject = null;
					if (tile.object) {
						if(!isAiPlayer(playerId)){
							if(tile.object === 'tree'){
								sounds.push('claimTree');
							}else if(tile.object === 'grass'){
								sounds.push('claimGrass');
							}else{
								sounds.push('moveunit');
							}
						}
						clearedObject = tile.object;
						tile.object = null;
						updates.push({ type: 'tile_changed', q: q, r: r, object: null });

					}
					
					actionForUndo = {
						type: 'build', 
						unit: newUnit, 
						cost: data.cost, 
						didClaim: didClaim, 
						oldOwner: oldOwner,
						clearedObject: clearedObject,
					};
					/*
					actionForUndo = {
						type: 'move',
						unitId: unit.id,
						fromQ, fromR,
						toQ, toR,
						didClaim: oldOwner !== playerId,
						oldOwner: oldOwner,
						clearedObject: oldObject,
					};*/
					
					if (buildCheck.action === 'attack') {
						const targetUnit = buildCheck.target;
						actionForUndo.killedUnit = { ...targetUnit }; // Store copy
						gameState.units = gameState.units.filter(u => u.id !== targetUnit.id);
						updates.push({ type: 'unit_removed', unitId: targetUnit.id });
						//sounds.push(CASTLE_DATA[targetUnit.type] ? 'destroy' : 'kill');
						if(!isAiPlayer(playerId)){
							sounds.push('kill');
						}
						
						//console.warn("buildCheck.action === 'attack'");
						
					}
					
					console.warn("actionForUndo");
					console.warn(actionForUndo);
					updates.push({ type: 'unit_added', unit: newUnit });
					//sounds.push('moveunit');
					
					distributePoolSavings(findEconomyPools(playerId));
					if (tile.ownerId) {
						affectedPlayers.add(tile.ownerId);
						distributePoolSavings(findEconomyPools(tile.ownerId));
					}
					
					//console.warn(actionForUndo);
				}
			}
			break;
		}
		
		case 'action_undo': {
			// undo move
			
			//console.log("executeAction action_undo");
			
			const lastAction = currentTurnActions.pop();
			if (!lastAction) break;
			
			if (lastAction.type === 'move') {
				const unit = gameState.units.find(u => u.id === lastAction.unitId);
				if (unit) {
					unit.q = lastAction.fromQ;
					unit.r = lastAction.fromR;
					unit.hasMoved = false;
					updates.push({ type: 'unit_moved', unitId: unit.id, q: unit.q, r: unit.r, hasMoved: false });
				}
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						//tile.ownerId = lastAction.oldOwner;
						setTileOwner(tile, lastAction.oldOwner);
						updates.push({ type: 'tile_changed', q: lastAction.toQ, r: lastAction.toR, ownerId: tile.ownerId });
					}
				}
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						tile.object = lastAction.clearedObject;
						updates.push({ type: 'tile_changed', q: lastAction.toQ, r: lastAction.toR, object: tile.object });
					}
				}
				if (lastAction.killedUnit) {
					gameState.units.push(lastAction.killedUnit);
					updates.push({ type: 'unit_added', unit: lastAction.killedUnit });
				}
				
				distributePoolSavings(findEconomyPools(playerId));
				if(lastAction.oldOwner) {
					affectedPlayers.add(lastAction.oldOwner);
					distributePoolSavings(findEconomyPools(lastAction.oldOwner));
				}
				
			} else if (lastAction.type === 'build') {
				gameState.units = gameState.units.filter(u => u.id !== lastAction.unit.id);
				updates.push({ type: 'unit_removed', unitId: lastAction.unit.id });
				
				const pools = findEconomyPools(playerId);
				addCost(pools, lastAction.cost);
				
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						//tile.ownerId = null;
						setTileOwner(tile, lastAction.oldOwner);
						updates.push({ type: 'tile_changed', q: lastAction.unit.q, r: lastAction.unit.r, ownerId: tile.ownerId });
					}
				}
				if (lastAction.killedUnit) {
					gameState.units.push(lastAction.killedUnit);
					updates.push({ type: 'unit_added', unit: lastAction.killedUnit });
				}
				
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						tile.object = lastAction.clearedObject;
						updates.push({ type: 'tile_changed', q: lastAction.unit.q, r: lastAction.unit.r, object: tile.object });
					}
				}
				distributePoolSavings(findEconomyPools(playerId));
				if(lastAction.oldOwner) {
					affectedPlayers.add(lastAction.oldOwner);
					distributePoolSavings(findEconomyPools(lastAction.oldOwner));
				}
			} else if (lastAction.type === 'sell') {
				// handle un-selling the unit.
				
				const pools = findEconomyPools(playerId);
				deductCost(pools, lastAction.sellPrice);

				gameState.units.push(lastAction.soldUnit);
				updates.push({ type: 'unit_added', unit: lastAction.soldUnit });
				
				
				distributePoolSavings(findEconomyPools(playerId));
			}
			
			updateHighlights();
			
			if(!isAiPlayer(playerId)){
				sounds.push('moveunit');
			}
			break;
		}
		
		case 'action_end_turn': {
			// end turn
			
			//console.log("executeAction action_end_turn");
			
			executeEndTurn(playerId);
			if(!isAiPlayer(playerId)){
				broadcast({ type: 'sound', name: "move" });
			}
			return; // end turn handles its own broadcasts
		}
	}
	
	//console.log("executeAction endswitch");
	
	if (actionForUndo) {
		currentTurnActions.push(actionForUndo);
	}
	
	for (const update of updates) {
		broadcast(update);
	}
	const uniqueSounds = [...new Set(sounds)];
	for (const sound of uniqueSounds) {
		broadcast({ type: 'sound', name: sound });
	}
	
	//console.log("executeAction endswitch 2");
	
	// Send savings updates to all affected players
	affectedPlayers.forEach(pid => updatePlayerSavings(pid));
	
	//console.log("executeAction endswitch 3");
	
	// non-synced updates executed on every action:
	setProtectedTiles();
	
	//console.log("executeAction endswitch 4");
}



// =================================================================
// --- ECONOMY & TURN LOGIC (HOST-SIDE)
// =================================================================
function updatePlayerSavings(playerId) {
	//console.log("updatePlayerSavings");
	
	if (!playerId) return;
	const newPools = findEconomyPools(playerId);
	let newTotalSavings = 0;
	
	//console.log("updatePlayerSavings 2: newPools.len = "+newPools.length);
	
	newPools.forEach(p => newTotalSavings += p.totalSavings);
	
	console.log("newTotalSavings");
	console.log(newTotalSavings);
	
	sendToPlayer(playerId, { 
		type: 'savings_update', 
		total: Math.floor(newTotalSavings) 
	});
}

function findEconomyPools(playerId) {
	// Finds all contiguous land areas for a given player
	const pools = [];
	const visited = new Set(); // 'q,r,t'
	
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const qq = tile.q;
		const rr = tile.r;
		let elem = `${qq},${rr},${t}`;

		if (tile.ownerId !== playerId || visited.has(elem)) {
			continue;
		}
		
		// Start a new pool
		const pool = {
			hexes: [], // {q, r, tile}
			soldiers: [],
			totalSavings: 0,
			totalIncome: 0,
			totalWages: 0
		};
		
		const queue = [elem]; // 'q,r,t'
		visited.add(elem);
		
		while (queue.length > 0) {
			const currentKey = queue.shift();
			const [q, r, tileIndex] = currentKey.split(',').map(Number);
			const currentTile = gameState.map.tilesData[tileIndex];
			
			pool.hexes.push({ q, r, tile: currentTile });
			pool.totalSavings += currentTile.savings;
			
			// Add income (if no object on it)
			if (!currentTile.object) {
				pool.totalIncome += gameRules.tileIncome;
			}
			
			// Check for soldier
			const unit = getUnitAt(q, r);
			if (unit && !isCastle(unit) && SOLDIER_DATA[unit.type]) {
				pool.soldiers.push(unit);
				pool.totalWages += SOLDIER_DATA[unit.type].wage;
			}
			
			// Check neighbors
			for (const n of getHexNeighbors(q, r)) {
				const nTile = getTileAt(n.q, n.r);
				
				if (nTile && nTile.ownerId === playerId){
					const nKey = `${n.q},${n.r},${nTile.tileIndex}`;
					if(!visited.has(nKey)) {
						visited.add(nKey);
						queue.push(nKey);
					}
				}
			}
		}
		pools.push(pool);
	}
	return pools;
}

function distributePoolSavings(pools) {
	// Takes a list of pools (from findEconomyPools) and distributes
	// their savings evenly among their hexes.
	let updates = [];
	for (const pool of pools) {
		if (pool.hexes.length === 0) continue;
		
		const savingsPerHex = pool.totalSavings / pool.hexes.length;
		for (const hex of pool.hexes) {
			if (hex.tile.savings !== savingsPerHex) {
				hex.tile.savings = savingsPerHex;
				// Don't need to broadcast savings changes,
				// they are implicit and only matter to the host
				// and the player (who gets a total).
			}
		}
	}
	// Return updates if we ever need them
	return updates;
}

function deductCost(pools, cost) {
	// Deducts cost proportionally from all pools
	let totalSavings = 0;
	pools.forEach(p => totalSavings += p.totalSavings);
	if (totalSavings < cost) return false; // Should not happen
	
	for (const pool of pools) {
		const proportion = pool.totalSavings / totalSavings;
		pool.totalSavings -= cost * proportion;
	}
	distributePoolSavings(pools);
	return true;
}

function addCost(pools, cost) {
	// Refunds cost. Just add it to the first pool.
	// distributePoolSavings will spread it evenly.
	if (pools.length > 0) {
		pools[0].totalSavings += cost;
	}
	distributePoolSavings(pools);
}


function getNextPlayerIndex(currentIndex){
	let nextIndex = currentIndex;
	// get next player index:
    do {
        nextIndex = (nextIndex + 1) % gameState.players.length;
    } while (gameState.players[nextIndex].isSpectator);
	
	return nextIndex;
}


// this is host function.
function advanceToNextPlayer(){

	// advance to next player:
    gameState.turn.currentPlayerIndex = getNextPlayerIndex(gameState.turn.currentPlayerIndex);
	//console.log("gameState.turn.currentPlayerIndex = "+gameState.turn.currentPlayerIndex);
	// end of day check:
	if (gameState.turn.currentPlayerIndex === gameState.turn.startPlayerIndex) {
		gameState.turn.turnNumber++;
		processEndOfDay();
	}
	
	updateGameUI();
}



function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomItem(arr){
	return arr[random(0, arr.length-1)];
}

/*
// this function doesnt need polishing, its very rudimentary AI that just moves not yet moved units to free hex.
function ai_find_best_move(player){
	console.log("ai_find_best_move");
	
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];
		// skip already moved units:
		if(unit.hasMoved){
			continue;
		}
		// only allow own units movement:
		if(unit.ownerId === player.id){
			// handle only ai units.
			let neigh = getHexNeighbors(unit.q, unit.r);
			
			console.log("neigh");
			console.log(neigh);
			
			let possibleMovesTemp = findUnitPossibleMoves(unit, player);
			let possibleMoves = [];
			// remove your owned tiles from possible moves, dont make ai just move in his own land:
			for(let t = 0; t < possibleMovesTemp.length; t++){
				let possibleMove = possibleMovesTemp[t];
				let possibleTile = getTileAt(possibleMove.q, possibleMove.r);
				if(possibleTile.ownerId !== player.id){
					let move = {q: possibleMove.q, r: possibleMove.r};
					const moveCheck = isMoveValid(unit, move, player);
					if (moveCheck.valid) {
						possibleMoves.push(move);
					}
				}
			}
			if(possibleMoves.length > 0){
				let randomMove = randomItem(possibleMoves);
				return {
					type: 'action_move',
					unitId: unit.id,
					toQ: randomMove.q,
					toR: randomMove.r
				};
			}

		}
	}
	
	return null; // no valid move found. turn will end.
}
*/

function ai_find_best_move(player) {
	//console.log("ai_find_best_move (improved)");

	let bestMove = null;
	let bestScore = -Infinity;

	for (let i = 0; i < gameState.units.length; i++) {
		const unit = gameState.units[i];
		if (unit.hasMoved || unit.ownerId !== player.id) continue;

		const possibleMovesTemp = findUnitPossibleMoves(unit, player);
		const possibleMoves = [];

		for (const move of possibleMovesTemp) {
			const tile = getTileAt(move.q, move.r);
			if (!tile || tile.ownerId === player.id) continue;
			const check = isMoveValid(unit, move, player);
			if (check.valid) possibleMoves.push(move);
		}

		for (const move of possibleMoves) {
			const tile = getTileAt(move.q, move.r);
			let score = 0;

			// === Base scoring ===
			// Prefer new land
			if (!tile.ownerId) score += 5;

			// Prefer enemy tiles
			if (tile.ownerId && tile.ownerId !== player.id) score += 10;

			// === Attack scoring ===
			const enemyUnit = gameState.units.find(u => u.q === move.q && u.r === move.r);
			if (enemyUnit) {
				if (unit.level > enemyUnit.level) {
					score += 25; // easy kill
				} else {
					score -= 20; // risky
				}
			}

			// === Territorial influence ===
			// More valuable if this move borders more enemy land (potential cutoff)
			const neighbors = getHexNeighbors(move.q, move.r);
			let enemyAdj = 0;
			for (const n of neighbors) {
				const nt = getTileAt(n.q, n.r);
				if (nt && nt.ownerId && nt.ownerId !== player.id) enemyAdj++;
			}
			score += enemyAdj * 2;

			// === Economy safety ===
			// Slightly prefer staying near friendly land (less isolation)
			const friendlyAdj = neighbors.filter(n => {
				const nt = getTileAt(n.q, n.r);
				return nt && nt.ownerId === player.id;
			}).length;
			score += friendlyAdj;

			if (score > bestScore) {
				bestScore = score;
				bestMove = {
					type: "action_move",
					unitId: unit.id,
					toQ: move.q,
					toR: move.r
				};
			}
		}
	}

	if (bestMove) {
		console.log("AI selected best move:", bestMove, "score:", bestScore);
		return bestMove;
	}

	// fallback
	return null;
}


// ai turn delay ai aidelay aiturn
let AI_DELAY_START = 50;
let AI_DELAY_MOVE = 50;



// *** NEW FUNCTION ***
// This function recursively calls itself with a delay to execute AI moves sequentially.
// moveai handleaimove aiturn handleai
function executeAIMoveSequentially(player) {
	if (!localPlayer.isHost || gameState.settings.gameOver) return;

	// Double-check if it's still this AI's turn
	const currentPlayer = gameState.players[gameState.turn.currentPlayerIndex];
	if (!currentPlayer || currentPlayer.id !== player.id || !currentPlayer.isAI) {
		console.log("AI turn interrupted or changed.");
		return;
	}

	//console.log(`AI ${player.name} is thinking...`);

	const bestMove = ai_find_best_move(player);
	//console.warn("AI bestMove:", bestMove);

	if (bestMove) {
		//console.log("executeAIMoveSequentially bestMove");
		
		// If a move is found, execute it
		// handleClientData is correct, as the host is simulating the AI's action
		handleClientData(player.id, bestMove);
		
		// Schedule the next move check after a delay
		setTimeout(() => {
			//console.log("setTimeout executeAIMoveSequentially");
			executeAIMoveSequentially(player); // Recursive call for the next move
		}, AI_DELAY_MOVE); // delay between moves
	} else {
		// No more moves found, end the turn
		console.log(`AI ${player.name} has no more moves. Ending turn.`);
		handleClientData(player.id, { type: "action_end_turn" });
	}
}


// checkaiturn
function checkForAITurn(){
	//console.log("checkForAITurn");
	// Only the host should control the AI
	if (!localPlayer.isHost || gameState.settings.gameOver) return;
	
	//console.log("checkForAITurn 2");

	const currentPlayer = gameState.players[gameState.turn.currentPlayerIndex];

	// If the current player is an AI, trigger their move sequence
	if (currentPlayer && currentPlayer.isAI && !currentPlayer.isDead) {
		console.log(`Starting AI turn for: ${currentPlayer.name}`);
		
		// Start the sequential move execution
		// Add a small initial delay to allow the "turn changed" message to settle
		setTimeout(() => {
			executeAIMoveSequentially(currentPlayer);
		}, AI_DELAY_START); // Small delay before first move
	}
}



// this is host function.
function processEndOfDay(){
	console.warn("Day ended, new day starts. process trees, grasses etc.");
	

	
	// process:
	// - crosses turning into grass.
	// - grass spreading randomly.
	// - new trees spawning randomly.
	
	// cross becomes grass in... 4 turns
	// grass ´grows 1-3 pieces per turn, chance is 50 for one piece?
	// trees grow more the more land there is, i think max is 2 per turn.
	let grassGrow = {};
	let landtilesCount = 0;
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];

		// add random trees to land tiles without any objects or units:
		if(tile.type === 'land'){
			landtilesCount++;
			
			// check if there is object on tile for grass/cross functionality:
			if(tile.object && tile.actionTurnNumber){

				let turnDiff = gameState.turn.turnNumber - tile.actionTurnNumber;
				if(tile.object === 'dead'){
					// turn crosses into grass after 4 turns:
					if(turnDiff >= 4){
						tile.object = 'grass';
						tile.actionTurnNumber = gameState.turn.turnNumber;
						broadcast({ type: 'object_changed', q: tile.q, r: tile.r, object: tile.object });
					}
				}else if(tile.object === 'grass'){
					// spread grass 
					let neigh = getHexNeighbors(tile.q, tile.r);
					for(let i = 0; i < neigh.length; i++){
						let n = neigh[i];
						const nTile = getTileAt(n.q, n.r);
						if(nTile && nTile.type === 'land' && !nTile.object){
							// a land tile without any objects yet.
							// check if there is any units on this tile:
							if(!getUnitAt(n.q, n.r)){
								// ready to use random chance for growing:
								if(Math.random() < 0.08){
									// set this tile as possible growing for grass:
									grassGrow[`${nTile.q},${nTile.r}`] = nTile;
								}
							}
						}
					}
				}
			}
		}
	}
	
	
	
	// spread grass, using keyed array so it wont spread into too far away, just neighbours:
	for (const key in grassGrow) {
		if (grassGrow.hasOwnProperty(key)) {
			let nTile = grassGrow[key]; // was neighbour tile, so using nTile still here.
			nTile.object = 'grass';
			nTile.actionTurnNumber = gameState.turn.turnNumber;
			broadcast({ type: 'object_changed', q: nTile.q, r: nTile.r, object: nTile.object });
		}
	}



	
	const tiles = gameState.map.tilesData;
	
	let treesPercent = 2/240; // 0.00833
	let maxTrees = Math.round(landtilesCount*treesPercent);
	let minTrees = 1;
	if(maxTrees > 4) maxTrees = 4;
	
	// if maxtrees is 0, add randomly 0 or 1 trees
	if(maxTrees == 0){
		minTrees = 0;
		maxTrees = random(0,random(0,1));
	}else if(maxTrees == 1){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 2){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 3){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 4){
		minTrees = 1;
		maxTrees = random(1,2);
	}
	let curMaxTrees = random(minTrees, maxTrees);
	
	console.log("maxTrees: "+maxTrees+", curMaxTrees: "+curMaxTrees);
	// add random trees:
	for (let i = 0; i < curMaxTrees; i++) {
		let rti, tile, hasUnit;

		// Find a valid tile
		do {
			rti = random(0, tiles.length - 1);
			tile = tiles[rti];
			hasUnit = getUnitAt(tile.q, tile.r);
		} while (tile.type === 'water' || tile.object || hasUnit);

		// add tree:
		tile.object = 'tree';
		tile.actionTurnNumber = gameState.turn.turnNumber;
		broadcast({ type: 'object_changed', q: tile.q, r: tile.r, object: tile.object });
		console.warn("tree spawned at "+tile.q+tile.r);
	}
	
	
	
	// Save this game state
	saveGameToDB(gameState);
}



function executeEndTurn(playerId) {
	// --- 1. Apply income and wages for current player ---
	const player = getPlayer(playerId);
	const pools = findEconomyPools(playerId);
	
	let allSoldiersKilled = [];
	
	//sounds.push('move');
	
	for (const pool of pools) {
		pool.totalSavings += pool.totalIncome;
		pool.totalSavings -= pool.totalWages;
		
		if (pool.totalSavings < 0) {
			// Bankrupt!
			pool.totalSavings = 0;
			for (const soldier of pool.soldiers) {
				allSoldiersKilled.push(soldier);
			}
			//sounds.push('kill'); // or 'famine'
		}
	}
	
	// Distribute final savings
	distributePoolSavings(pools);
	updatePlayerSavings(playerId); // Update savings *after* calcs
	
	

	// --- 2. Kill soldiers & turn to crosses ---
	for (const soldier of allSoldiersKilled) {
		const tile = getTileAt(soldier.q, soldier.r);
		if (tile) {
			tile.object = 'dead'; // Turn to dead (crosses)
			tile.actionTurnNumber = gameState.turn.turnNumber;
			broadcast({ type: 'object_changed', q: soldier.q, r: soldier.r, object: tile.object });
		}
		gameState.units = gameState.units.filter(u => u.id !== soldier.id);
		broadcast({ type: 'unit_removed', unitId: soldier.id });
	}
	
	

	
	// --- 3. Reset "hasMoved" for all *this player's* units ---
	gameState.units.forEach(u => {
		if (u.ownerId === playerId) {
			if (u.hasMoved) {
				u.hasMoved = false;
				broadcast({ type: 'unit_moved', unitId: u.id, q: u.q, r: u.r, hasMoved: false });
			}
		}
	});
	
	// --- 4. Grow Grass / Spawn Trees (random events) ---
	// TODO: Add grass spreading and tree spawning logic
	
	// --- 5. Advance Turn ---

	advanceToNextPlayer();
	
	//console.log("gameState.turn.currentPlayerIndex");
	//console.log(gameState.turn.currentPlayerIndex);
	
	
	currentTurnActions = []; // Clear undo stack
	
	broadcast({ 
		type: 'turn_changed', 
		currentPlayerIndex: gameState.turn.currentPlayerIndex, 
		turnNumber: gameState.turn.turnNumber 
	});
	
	
	
	// --- 6. Check for AI turn ---
	// NEW: This will now start the AI's sequential turn
	checkForAITurn(); // start AI turn if it is his turn.
}


const uiRightTopRow = document.getElementById('ui-right-top-row-id');
const uiRightButtonRow1 = document.getElementById('ui-right-button-row1-id');


function spectatorUiMode(){
	//uiRight.style.display = "none";
	// make transparent panel:
	uiRight.classList.remove('ui-panel');
	uiRight.classList.add('ui-panel-trans');
	
	// hide unnecessary buttons and ui elements:
	uiRightTopRow.style.display = "none";
	uiRightButtonRow1.style.display = "none";
	undoBtn.style.display = "none";
	endTurnBtn.style.display = "none";
}


function addCurrentTurnChatMessage(){
	addSystemChatMessage(`Day ${gameState.turn.turnNumber}: ${getCurrentTurnPlayer().name}'s turn.`);
}



// =================================================================
// --- GAME STATE SYNC (NETWORKING)
// =================================================================

function handleHostData(data) {
	// CLIENT-SIDE: Received data from host
	let needsUIUpdate = false;
	
	//console.log("handleHostData: data.type = "+data.type);
	
	switch (data.type) {
		case 'game_start':
			markDirty();
			gameState = data.state;
			showPage('game');
			updateGameUI();
			centerToFirstUnit();
			break;
		case 'full_state':
			gameState = data.state;
			console.warn("handleHostData full_state");
			
			if (!localPlayer.isSpectator) {
				localPlayer.isSpectator = true;
				localPlayer.color = SPECTATOR_COLOR;
				spectatorUiMode();
				console.log("localPlayer");
				console.log(localPlayer);
				addSystemChatMessage("Joined as spectator");
				//alert("Game in progress. Joining as spectator.");
			}
			showPage('game');
			updateGameUI();
			break;
		case 'lobby_update':
			gameState.settings = data.settings;
			gameState.players = data.players;
			gameState.map = data.map;
			lobbyLoadedMapImg.src = data.map.imageData;
			updateLobbyUI();
			break;
		case 'map_update':
			gameState.map = data.map;
			lobbyLoadedMapImg.src = data.map.imageData;
			updateLobbyUI();
			break;
		case 'chat':
			addChatMessage(data.from, data.message, lightenHexColor(data.color, 0.3));
			break;
		case 'tile_changed': 
			{
				const tile = getTileAt(data.q, data.r);
				if (tile) {
					if (data.ownerId !== undefined) setTileOwner(tile, data.ownerId); //tile.ownerId = data.ownerId;
					if (data.object !== undefined) tile.object = data.object;
				}
				needsUIUpdate = true;
			}
			break;
		case 'object_changed':
			{
				const tile = getTileAt(data.q, data.r);
				if (tile) {
					if (data.object !== undefined){
						tile.object = data.object;
					}
				}
				needsUIUpdate = true;
			}
			break;
		case 'unit_added':
			console.log("unit_added: gameState.units.push(data.unit);");
			console.log(data.unit);
			gameState.units.push(data.unit);
			needsUIUpdate = true;
			break;
		case 'unit_removed':
			gameState.units = gameState.units.filter(u => u.id !== data.unitId);
			needsUIUpdate = true;
			break;
		case 'unit_moved':
			const unit = gameState.units.find(u => u.id === data.unitId);
			if (unit) {
				unit.q = data.q;
				unit.r = data.r;
				unit.hasMoved = data.hasMoved;
			}
			needsUIUpdate = true;
			break;
		case 'turn_changed':
			gameState.turn.currentPlayerIndex = data.currentPlayerIndex;
			gameState.turn.turnNumber = data.turnNumber;

			selectedUnit = null;
			selectedHex = null;
			updateHighlights();
			updateGameUI();

			addCurrentTurnChatMessage();
			break;
		case 'sound':
			playSound(data.name);
			break;
		case 'savings_update':
			myCurrentSavings = data.total;
			playerSavings.textContent = `Savings: ${myCurrentSavings}`;
			break;
	}
	
	// non-synced updates executed on every action:
	setProtectedTiles();
	
	if (needsUIUpdate) {
		updateGameUI();
	}
}

function handleClientData(peerId, data) {
	//console.log("handleClientData");
	// HOST-SIDE: Received data from a client
	const player = getPlayer(peerId);
	if (!player) return;
	
	//console.log("handleClientData 2");
	
	switch (data.type) {
		case 'join':
			player.name = data.name;
			
			if (!gameState.settings.gameStarted) {
				player.color = getNextFreeColor();
				player.isSpectator = data.isSpectator;
			} else {
				player.color = "#FFFFFF";
				player.isSpectator = true; // Always spectator if game in progress
			}
			// If player "takes" a loaded name, update that
			if (data.loadedPlayerName) {
				const p = loadedGameState.players.find(lp => lp.name === data.loadedPlayerName);
				if (p) p.isTaken = true;
			}
			broadcastLobbyState();
			if(gameState.settings.gameStarted){
				addSystemChatMessage(`${player.name} has joined.`, "#AAAAFF");
			}
			break;
		case 'player_update':
			player.name = data.name;
			player.color = data.color;
			broadcastLobbyState();
			break;
		case 'chat':
			broadcast({
				type: 'chat',
				from: player.name,
				message: data.message,
				color: player.color
			});
			break;
		case 'host_quit':
			console.warn("host has quit the game. showing popup to continue game or quit.");
		break;
		
		// All game actions
		case 'action_sell':
		case 'action_move':
		case 'action_build':
		case 'action_undo':
		case 'action_end_turn':
			//console.log("handleClientData executeAction "+data.type);
			if (gameState.settings.gameStarted) {
				executeAction(peerId, data);
			}
			break;
	}
}


function newPeer(myPeerId = null){
	if(myPeerId){
		console.log("newPeer(): myPeerId = "+myPeerId);
	}else{
		console.log("newPeer(): myPeerId = null");
	}
	selectedServerIndex = parseInt(serverNameInput.value, 10);
	let selectedServer = serversList[selectedServerIndex];

	peer = new Peer(myPeerId, selectedServer.config);
	
	if(selectedServer.config.host){
		console.warn(`connecting to ${selectedServer.config.host}${selectedServer.config.path}`);
	}else{
		console.warn(`connecting to peerjs.com`);
	}
	console.warn(selectedServer.config);
}

// =================================================================
// --- PEERJS NETWORKING
// =================================================================
function initPeerJS() {
	try {
		// This peer is for clients, or for the host to override
		newPeer();

		peer.on('open', (id) => {
			myPeerId = id;
			localPlayer.id = id;
			connectionStatus.textContent = 'Connected to Peer server.';
			console.log('My peer ID is: ' + id);
			// Enable buttons
			hostBtn.disabled = false;
			joinBtn.disabled = false;
			spectateBtn.disabled = false;
		});
		
		// NO 'connection' listener here. Clients don't accept connections.
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			alert(`Connection Error: ${err.message}\nTry refreshing or check your connection.`);
		});
		
	} catch (err) {
		console.error("Failed to initialize PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}


function setupConnection(conn) {
	connections.set(conn.peer, conn); // must be here instantly or color/nick changes wont work.
	
	conn.on('open', () => {
		console.log(`Data connection opened with ${conn.peer}`);
		//connections.set(conn.peer, conn);

		// If we are host, add new player and send lobby state
		if (localPlayer.isHost) {
			const newPlayer = {
				id: conn.peer,
				name: 'Joining...', // Will be updated by 'join' message
				color: "gray",
				isSpectator: false,
				isAI: false,
				isDead: false,
			};
			gameState.players.push(newPlayer);
			
			if (gameState.settings.gameStarted) {
				// Send full game state to new player (who will join as spec)
				conn.send({ type: 'full_state', state: gameState });
			} else {
				// Send lobby state
				conn.send({ type: 'lobby_update', settings: gameState.settings, players: gameState.players, map: gameState.map });
			}
		}
	});
	
	
	conn.on('data', (data) => {
		if (localPlayer.isHost) {
			handleClientData(conn.peer, data);
		} else {
			handleHostData(data);
		}
	});
	
	conn.on('close', () => {
		console.log(`Connection closed with ${conn.peer}`);
		connections.delete(conn.peer);
		if (localPlayer.isHost) {
			const player = getPlayer(conn.peer);
			if (player) {
				addSystemChatMessage(`${player.name} has left.`, "#FFFF00");
				//gameState.players = gameState.players.filter(p => p.id !== conn.peer);
				gameState.players = gameState.players.map(p =>
					p.id === conn.peer ? { ...p, isSpectator: true, quitted: true } : p
				);
				if (gameState.settings.gameStarted) {
					// let others play if quitter was in turn:
					if(conn.peer == gameState.players[gameState.turn.currentPlayerIndex].id){
						advanceToNextPlayer();
						checkForAITurn(); // start AI turn if it is his turn.
					}else{
						
						updateGameUI();
					}
				} else {
					broadcastLobbyState();
				}
			}
		} else {
			// We were disconnected from host
			//alert('Disconnected from host. Returning to start page.');
			console.warn('Disconnected from host. Returning to start page.');
			addSystemChatMessage("Host has left the game.", "#FFFF00");
			
			let answer = confirm("Host has left the game, quit game?");
			if(answer){
				restartGame();
				//showPage('start');
				// Reset state?
				// todo: causes weird bugs when the client player goes to start page and starts hosting his own room.
				//resetGameState();
			}else{
				// maybe set some UI element to display "host quitted" or something.
			}
		}
	});
}


// todo: make without reloading the page but instead clear the gameState.
function restartGame(){
	location.reload();
}

// Helper function for joinGame
function executeJoin(hostPeerId) {
	console.log(`Attempting to connect to host: ${hostPeerId}`);
	const conn = peer.connect(hostPeerId);
	
	conn.on('open', () => {
		console.log(`Connected to host: ${hostPeerId}`);
		setupConnection(conn);
		
		// Send our initial join info
		conn.send({
			type: 'join',
			name: localPlayer.name,
			color: getNextFreeColor(),
			isSpectator: localPlayer.isSpectator
		});
		
		// Go to lobby page
		lobbyPlayerNameInput.value = localPlayer.name;
		lobbyRoomNameTitle.textContent = `Joining: ${hostPeerId}`; // Use the ID we joined
		showPage('lobby');
	});
	
	conn.on('error', (err) => {
		console.error('Connection failed:', err);
		alert(`Failed to connect to room: ${hostPeerId}\nCheck the ID and try again.`);
	});
}

function joinGame(isSpectator) {
	localPlayer.isSpectator = isSpectator;
	localPlayer.name = playerNameInput.value;
	if (isSpectator) {
		localPlayer.color = SPECTATOR_COLOR;
		spectatorUiMode();
		addSystemChatMessage("Joined as spectator");
	}
	
	hostPeerId = gameNameInput.value.trim();
	if (!hostPeerId) {
		alert('Please enter a Game Room Name (which is the Host\'s ID).');
		return;
	}
	
	if (!peer || peer.destroyed) {
		console.log("Peer is destroyed, re-initializing for join.");
		initPeerJS(); // Re-init
		// Need to wait for 'open'
		peer.on('open', () => {
			console.log("Re-initialized peer, now joining.");
			executeJoin(hostPeerId);
		});
		return;
	}
	
	executeJoin(hostPeerId);
}

function hostGame() {
	const gameName = gameNameInput.value.trim();
	if (!gameName) {
		alert("Please enter a Game Room Name.");
		return;
	}

	if (peer) {
		peer.destroy();
	}
	
	console.log(`Attempting to host with ID: ${gameName}`);
	try {
		//peer = new Peer(gameName, { debug: 2 });
		newPeer(gameName);

		peer.on('open', (id) => {
			myPeerId = id;
			localPlayer.id = id;
			localPlayer.isHost = true;
			localPlayer.name = playerNameInput.value;
			localPlayer.color = getNextFreeColor();
			hostPeerId = myPeerId;
			
			// Use the desired ID, not the one from the 'open' event (which should be the same)
			gameState.settings.roomName = gameName;
			// This was the line overwriting your input, it's now correct.
			gameNameInput.value = gameName; 
			hostRoomPlayerNameInput.value = localPlayer.name;
			hostRoomNameTitle.textContent = `Hosting: ${gameName}`;
			
			// Reset player list and add host
			gameState.players = []; 
			gameState.players.push(localPlayer);
			
			

			let server = getSelectedServer();
			console.log(server);
			
			// todo: You could also send a DELETE /unregister-game request when the host manually closes the game.
			
			// only allow games list on servers that is possible:
			if(server.serverListEnabled){
				fetch(`${server.fetchUrl}/register-game`, {
				  method: 'POST',
				  headers: { 'Content-Type': 'application/json' },
				  body: JSON.stringify({
					peerId: localPlayer.id,
					name: gameName,
					appName: APP_NAME,
					hostName: localPlayer.name,
					maxPlayers: 400, // todo: allow changing this some day.
				  }),
				});
			}


			
			updateHostLobbyUI();
			showPage('host');
			connectionStatus.textContent = `Hosting at ${gameName}. Ready for players.`;
		});
		
		// Host MUST listen for connections
		peer.on('connection', (conn) => {
			console.log('Incoming connection from', conn.peer);
			setupConnection(conn);
		});
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			if (err.type === 'unavailable-id') {
				alert(`Game Room "${gameName}" is already taken. Please choose another name.`);
				showPage('start');
				peer.destroy();
				initPeerJS(); // Re-init with a random client ID
			}
		});
		
	} catch (err) {
		console.error("Failed to initialize host PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}



// generates svg for hexagon with color.
function hexagonSVG(color, size = 35){
	let targetSize = size;
	let aspectRatio = 175/200;
	let targetWidth = targetSize;
	let targetHeight = targetSize*aspectRatio;
	let width = 200;
	let height = 175;
	let points = [[50,0],[150,0],[200,87],[150,174],[50,174],[0,87]];
	let pointsArr = [];
	for(let p = 0; p < points.length; p++){
		let x = points[p][0]/width*targetWidth;
		let y = points[p][1]/height*targetHeight;
		pointsArr.push(x+","+y);
	}
	let pointsStr = pointsArr.join(" ");
	
	return `<svg width="${targetWidth}" height="${targetHeight}" viewBox="0 0 ${targetWidth} ${targetHeight}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Hexagon"><polygon points="${pointsStr}" fill="${color}"/></svg>
`;
}



// =================================================================
// --- LOBBY UI & LOGIC
// =================================================================

function updateHostLobbyUI() {
	// for host player:
	hostPlayerList.innerHTML = '';
	const usedColors = [];
	gameState.players.forEach(p => {
		if(!p.quitted){
			const item = document.createElement('div');
			item.className = 'player-list-item';
			let specTag = p.isSpectator ? ' (spec)' : '';
			item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.color;
			item.textContent = `${p.name}${specTag}`;
			hostPlayerList.appendChild(item);
			if (p.color) usedColors.push(p.color);
		}
	});
	
	// Update color picker
	hostRoomColorPicker.innerHTML = '';
	if (localPlayer.isSpectator) {
		hostRoomColorPicker.innerHTML = '<i>Spectators cannot change color.</i>';
		lobbyPlayerNameInput.disabled = true;
	} else {
		lobbyPlayerNameInput.disabled = false;
		//console.log("usedColors");
		//console.log(usedColors);
		PLAYER_COLORS.forEach(color => {
			const box = document.createElement('div');
			box.className = 'color-box';
			box.style.backgroundColor = color;
			
			if (localPlayer.color === color) {
				box.classList.add('selected');
			}
			if (usedColors.includes(color) && localPlayer.color !== color) {
				//console.log(usedColors);
				box.classList.add('disabled');
			} else {
				box.onclick = () => {
					//console.log("tried to change color");
					localPlayer.color = color;
					sendToHost({
						type: 'player_update',
						name: localPlayer.name,
						color: localPlayer.color
					});
					updateLobbyUI(); // Re-render
				};
			}
			hostRoomColorPicker.appendChild(box);
		});
	}
}

function updateLobbyUI() {
	// Update settings info
	lobbyRoomNameTitle.textContent = `Joining: ${gameState.settings.roomName}`;
	lobbyMapSize.textContent = `${gameState.settings.mapWidth} x ${gameState.settings.mapHeight}`;
	lobbyStartMoney.textContent = `${gameState.settings.startingMoney} G`;
	lobbyMapScale.value = gameState.settings.mapScale;
	
	// Update player list for non-host players:
	lobbyPlayerList.innerHTML = '';
	const usedColors = [];
	gameState.players.forEach(p => {
		if(!p.quitted){
			const item = document.createElement('div');
			item.className = 'player-list-item';
			let specTag = p.isSpectator ? ' (spec)' : '';
			item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.color;
			item.textContent = `${p.name}${specTag}`;
			lobbyPlayerList.appendChild(item);
			if (p.color) usedColors.push(p.color);
		}
	});

	// Update color picker
	lobbyColorPicker.innerHTML = '';
	if (localPlayer.isSpectator) {
		lobbyColorPicker.innerHTML = '<i>Spectators cannot change color.</i>';
		lobbyPlayerNameInput.disabled = true;
	} else {
		lobbyPlayerNameInput.disabled = false;
		//console.log("usedColors");
		//console.log(usedColors);
		PLAYER_COLORS.forEach(color => {
			const box = document.createElement('div');
			box.className = 'color-box';
			box.style.backgroundColor = color;
			
			if (localPlayer.color === color) {
				box.classList.add('selected');
			}
			if (usedColors.includes(color) && localPlayer.color !== color) {
				//console.log(usedColors);
				box.classList.add('disabled');
			} else {
				box.onclick = () => {
					//console.log("tried to change color");
					localPlayer.color = color;
					sendToHost({
						type: 'player_update',
						name: localPlayer.name,
						color: localPlayer.color
					});
					updateLobbyUI(); // Re-render
				};
			}
			lobbyColorPicker.appendChild(box);
		});
	}
}

function broadcastLobbyState(settings = gameState.settings, players = gameState.players, map = gameState.map) {
	if (!localPlayer.isHost) return;
	// Update host's own UI
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: 'lobby_update',
		settings: gameState.settings,
		players: gameState.players,
		map: gameState.map,
	});
}

function broadcastMapState() {
	if (!localPlayer.isHost) return;
	// Update host's own UI
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: 'map_update',
		map: gameState.map,
	});
}

// =================================================================
// --- INDEXEDDB
// =================================================================

function initDB() {
	const request = indexedDB.open(DB_NAME, 1);
	
	request.onerror = (e) => {
		console.error("IndexedDB error:", e.target.errorCode);
	};
	
	request.onsuccess = (e) => {
		db = e.target.result;
		console.log("IndexedDB initialized.");
		console.log(db);
	};
	
	request.onupgradeneeded = (e) => {
		let db = e.target.result;
		if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
			db.createObjectStore(DB_STORE_NAME, { keyPath: 'roomName' });
		}
	};
}


async function getMostRecentSave() {
	return new Promise((resolve, reject) => {
		if (!db) {
			resolve(null); // no saves to be found
			//reject('Database not initialized');
			return;
		}

		const transaction = db.transaction([DB_STORE_NAME], 'readonly');
		const objectStore = transaction.objectStore(DB_STORE_NAME);
		const getAllRequest = objectStore.getAll();

		getAllRequest.onsuccess = (event) => {
			const allSaves = event.target.result;
			if (allSaves.length > 0) {
				allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
				resolve(allSaves[0].roomName);
			} else {
				resolve(null); // no saves found
			}
		};

		getAllRequest.onerror = (e) => {
			console.error('Error loading game:', e.target.error);
			//reject(e.target.error);
			resolve(null); // no saves to be found
		};
	});
}



async function getAllSavedGames() {
	return new Promise((resolve, reject) => {
		if (!db) {
			resolve(null); // no saves to be found
			return;
		}

		const transaction = db.transaction([DB_STORE_NAME], 'readonly');
		const objectStore = transaction.objectStore(DB_STORE_NAME);
		const getAllRequest = objectStore.getAll();

		getAllRequest.onsuccess = (event) => {
			const allSaves = event.target.result;

			// Sort saves by saveDate (newest first)
			allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
			resolve(allSaves); // return array of saved games.
		};

		getAllRequest.onerror = (e) => {
			console.error('Error loading game:', e.target.error);
			resolve(null); // no saves to be found
		};
	});
}


function pruneOldSaves(maxSaves = 5) {
	if (!db) return;

	const transaction = db.transaction([DB_STORE_NAME], 'readwrite');
	const objectStore = transaction.objectStore(DB_STORE_NAME);

	// Get all saved games
	const getAllRequest = objectStore.getAll();

	getAllRequest.onsuccess = (event) => {
		const allSaves = event.target.result;

		// Sort saves by saveDate (newest first)
		allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));

		// If there are more than maxSaves, delete the oldest ones
		if (allSaves.length > maxSaves) {
			const savesToDelete = allSaves.slice(maxSaves);

			savesToDelete.forEach((save) => {
				const deleteRequest = objectStore.delete(save.roomName);
				deleteRequest.onsuccess = () => {
					console.warn('Deleted old save:', save.roomName);
				};
			});
		}
	};
}


// get date like "12.11.2025 - 09:45:03" from saved new Date().toISOString() from db.
function formatReadableDate(isoString) {
	const date = new Date(isoString);
	const pad = (n) => n.toString().padStart(2, '0');

	const day = pad(date.getDate());
	const month = pad(date.getMonth() + 1);
	const year = date.getFullYear();
	const hours = pad(date.getHours());
	const minutes = pad(date.getMinutes());
	const seconds = pad(date.getSeconds());

	return `${day}.${month}.${year} - ${hours}:${minutes}:${seconds}`;
}



function formatDateForSave() {
	const now = new Date();

	const pad = (n) => n.toString().padStart(2, '0');

	const year = now.getFullYear();
	const month = pad(now.getMonth() + 1);
	const day = pad(now.getDate());
	const hours = pad(now.getHours());
	const minutes = pad(now.getMinutes());
	const seconds = pad(now.getSeconds());

	return `${year}${month}${day}_${hours}${minutes}${seconds}`;
}



let currentFormattedDate = formatDateForSave(); // updated at startGame() to get precise date of start time.


function saveGameToDB(gameState) {
	if (!db) return;

	
	let stateToSave = {
		gameState: JSON.parse(JSON.stringify(gameState)), // Create a deep clone to store
		saveDate: new Date().toISOString(),
		// roomName key is used for db key:
		roomName: currentFormattedDate, // "20251112_170804", initialized at app launch only.
	};

	
	const transaction = db.transaction([DB_STORE_NAME], 'readwrite');
	const objectStore = transaction.objectStore(DB_STORE_NAME);
	const request = objectStore.put(stateToSave);
	
	request.onsuccess = () => {
		console.log('Game saved:', stateToSave.roomName);
		// remove old saved games, keep only 6:
		pruneOldSaves(8);
		//console.log("stateToSave:");
		//console.log(stateToSave);
	};
	request.onerror = (e) => {
		console.error('Error saving game:', e.target.error);
		//console.log("stateToSave:");
		//console.log(stateToSave);
	};
}



function loadGameFromDB(roomName, callback) {
	if (!db) return;
	// if no saved games found: (roomName set to null in that case)
	if(!roomName){
		callback(null);
		return;
	}
	
	const transaction = db.transaction([DB_STORE_NAME], 'readonly');
	const objectStore = transaction.objectStore(DB_STORE_NAME);
	const request = objectStore.get(roomName);
	
	request.onsuccess = (e) => {
		callback(e.target.result);
	};
	request.onerror = (e) => {
		console.error('Error loading game:', e.target.error);
		callback(null);
	};
}

// =================================================================
// --- GAME INIT (HOST-SIDE)
// =================================================================



let loadedmap = null;

let customMaps = {
	/* example data:
	small: [
		{
			name: "mapname",
			width: 24,
			height: 24,
			data: null, // parsed map data ready to use ingame.
			preview: "path/to/image.jpg",
			imageData: null,
		},
	],
	normal: [
		{
			width: 24,
			height: 24,
			data: null, // parsed map data ready to use ingame.
			preview: "path/to/image.jpg",
			imageData: null,
		},
	],
	*/
};






//mapdata = {width: 0, height: 0, data: []};
// compact data: L/W/0 P/T/0 0-6 -> L00 = empty piece of land.
// only for compact data.
function getTileCountCompact(mapdata){
	let tileCount = 0;
	let data = mapdata.data;
	let height = data.length;
	let width = data[0].length;
	for(let y = 0; y < height; y++){
		for(let x = 0; x < width; x++){
			if(data[y][x][0] === "L"){
				tileCount++;
			}
		}
	}
	return tileCount;
}


async function buildMapList(mapSizeName) {
	const t = mapSizeName[0];
	const totalMaps = 40;

	const promises = Array.from({ length: totalMaps }, async (_, i) => {
		const n = i + 1;
		const name = `map${t}${n}`;
		const mapBasePath = `maps/${mapSizeName}/${name}`;
		const mapFile = `${mapBasePath}.dat`;
		const mapImageFile = `${mapBasePath}.png`;

		try {
			const mapdata = await parseMap(mapFile, true);
			if (!mapdata) return null;

			// Convert image to base64
			const imageResponse = await fetch(mapImageFile);
			if (!imageResponse.ok) throw new Error(`Image not found: ${mapImageFile}`);

			const blob = await imageResponse.blob();
			const imageData = await blobToBase64(blob); // convert blob → base64

			mapdata.preview = mapImageFile; // original URL (optional)
			mapdata.name = name;
			mapdata.imageData = imageData; // base64 string ready for <img src="...">
			mapdata.tileCount = getTileCountCompact(mapdata);
			return mapdata;

		} catch (err) {
			console.error(`Error loading map ${name}:`, err);
			return null;
		}
	});

	const results = await Promise.all(promises);
	customMaps[mapSizeName] = results.filter(Boolean);

	console.log(`✅ Loaded ${customMaps[mapSizeName].length}/${totalMaps} maps successfully.`);
}

// Helper to convert Blob → Base64 string
function blobToBase64(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onloadend = () => resolve(reader.result); // returns a Data URL (base64)
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}


// only used when compiled-maps.json has to be updated.
async function loadmaps(){
	// other way to load them:
	//await Promise.all([
	//  buildMapList("normal"),
	//  buildMapList("small")
	//]);

	await buildMapList("normal");
	console.log("buildMapList normal finished");
	await buildMapList("small");
	console.log("buildMapList small finished");
	
	
	const jsonString = JSON.stringify(customMaps);
	console.log("customMaps");
	console.log(customMaps);
	console.warn("jsonString");
	console.warn(jsonString);
}
//loadmaps(); // used only to recompile maps again into one file.




async function loadMapsFromJSON() {
	try {
		const response = await fetch('maps/all-compiled.json');
		if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

		const allmaps = await response.json(); // parses JSON into JS object
		//console.log('Loaded maps:', allmaps);

		// now you can use allmaps normally
		return allmaps;

	} catch (err) {
		console.error('Failed to load JSON file:', err);
		return null;
	}
}


let loadedMapCategory = "small";
let loadedMapIndex = 0;

// load map on start:
(async () => {
	customMaps = await loadMapsFromJSON();
	// sort maps by tileCount (land tiles)
	for (const key in customMaps) {
		customMaps[key].sort((a, b) => a.tileCount - b.tileCount);
	}
	
	//console.warn(customMaps);
	//console.warn(customMaps.normal[0]);

	// load default map, first in array:
	loadMap(loadedMapCategory, loadedMapIndex);
})();


function getCustomMap(category, index){
	return customMaps[category][index];
}

	
function loadMap(category, index) {
	// unload loaded game so it wont mess up new game:
	unloadGame();
	
	loadedMapCategory = category;
	loadedMapIndex = index;
	
	const map = getCustomMap(category, index);//customMaps[category][index];
	console.log('Loading map:', category, index, map.name);
	loadedMapImg.src = map.imageData;
	

	setLoadedMapAndApplyScale();

	
	
}


function setLoadedMapAndApplyScale(){
	//loadedmap = customMaps[loadedMapCategory][loadedMapIndex];
	
	loadedmap = structuredClone(customMaps[loadedMapCategory][loadedMapIndex]);
	//console.warn("loadedmap");
	//console.warn(loadedmap);
	
	scaleMap();
	loadParsedMap(loadedmap, true);
	
	
	broadcastMapState();
}




// loadmap
async function parseMap(mapFilePath, compact = false){
	const response = await fetch(mapFilePath);
	if (!response.ok) {
		console.error("Failed to load file:", response.statusText);
		return;
	}

	const text = await response.text(); // read file as plain text
	const lines = text.split(/\r?\n/);  // split into lines

	let parsedMap = {
		width: 0,
		height: 0,
		data: [],
	};

	for(let p = 0; p < lines.length; p++){
		const trimmed = lines[p].trim();
		if (!trimmed) continue; // skip empty lines
		
		const lineValues = trimmed.split(/\s+/); // split by spaces
		
		// get width/height:
		if(p == 0){
			parsedMap.width = parseInt(lineValues[0], 10);
			parsedMap.height = parseInt(lineValues[1], 10);
			continue;
		}
		
		let parsedRowArr = [];
		
		// process cell values:
		for(let i = 0; i < lineValues.length; i++){
			//console.log(lineValues[i]);
			let info = getMapValueInfo(lineValues[i], compact);
			//console.log(info);
			parsedRowArr.push(info);
		}
		
		parsedMap.data.push(parsedRowArr);
		//console.log(lineValues);
	}
	
	console.log(parsedMap);
	
	loadedmap = parsedMap;
	return parsedMap;
}




// {type: land/water, object: null/tree/peasant, owner: 0-6}
function getMapValueInfo(valueStr, compact = false){
	// set default type to land, so we dont need to modify it for player owned tiles.
	let info = {type: "land", object: null, owner: 0};
	let value = parseInt(valueStr, 10);
	switch(value){
		case -1:
			info.type = "water";
		break;
		case 241:
			info.owner = 0;
		break;
		case 243:
			info.owner = 0;
			info.object = "tree";
		break;
		case 1:
			info.owner = 1;
		break;
		case 4:
			info.owner = 1;
			info.object = "peasant";
		break;
		case 41:
			info.owner = 2;
		break;
		case 44:
			info.owner = 2;
			info.object = "peasant";
		break;
		case 81:
			info.owner = 3;
		break;
		case 84:
			info.owner = 3;
			info.object = "peasant";
		break;
		case 121:
			info.owner = 4;
		break;
		case 124:
			info.owner = 4;
			info.object = "peasant";
		break;
		case 161:
			info.owner = 5;
		break;
		case 164:
			info.owner = 5;
			info.object = "peasant";
		break;
		case 201:
			info.owner = 6;
		break;
		case 204:
			info.owner = 6;
			info.object = "peasant";
		break;
	}
	if(compact){
		//let info2 = {type: "land", object: null, owner: 0};
		let type = "L"; // L = land, W = water
		let obj = "0"; // T = tree, P = peasant, 0 = none
		let owner = info.owner; // 0 = nobody, 1-6 = players.
		if(info.type == "water"){
			type = "W";
		}
		if(info.object == "peasant"){
			obj = "P";
		}else if(info.object == "tree"){
			obj = "T";
		}
		return `${type}${obj}${owner}`; // "LT3" etc
	}else{
		return info;
	}
}

function compactToExpandedInfo(str){
	let type = "land"; // L = land, W = water
	let obj = null; // T = tree, P = peasant, 0 = none
	let owner = parseInt(str[2], 10); // 0 = nobody, 1-6 = players.
	
	if(str[0] === "W"){
		type = "water";
	}
	if(str[1] === "T"){
		obj = "tree";
	}else if(str[1] === "P"){
		obj = "peasant";
	}
	
	return {type: type, object: obj, owner: owner};
}

function loadParsedMap(parsedMap, compact = false){
	
	// clear previous data:
	gameState.map.tiles = {}; // associative array where [key] = tilesData array index.
	gameState.map.tilesData = []; // actual data for tiles. {q,r, type, ownerId, object, savings} 
	
	let width = parsedMap.width;
	let height = parsedMap.height;
	gameState.map.width = parsedMap.width;
	gameState.map.height = parsedMap.height;
	gameState.map.imageData = parsedMap.imageData;
	gameState.map.name = parsedMap.name;
	
	console.log("parsedMap");
	console.log(parsedMap);
	
	// TODO: check if width/height is used properly in the loops! not sure which is which...
	//for (let q = -Math.floor(width/2), y = 0; q <= Math.floor(width/2); q++, y++) {
	for (let q = 0, y = 0; q < width; q++, y++) {
		let roff = 0;
	
		//for (let r = -Math.floor(height/2), x = 0; r <= Math.floor(height/2); r++, x++) {
		for (let r = 0, x = 0; r < height; r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let xx = x;
			let yy = y;
			let qq = q-roff;
			let rr = r;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info;
				if(compact){
					info = compactToExpandedInfo(parsedMap.data[yy][xx]);
				}else{
					info = parsedMap.data[yy][xx];
				}
				let object = null;
				//if(info.object == "tree"){
				//	tree = "tree";
				//}
				// add random trees 20% chance:
				if(!info.owner && Math.random() < 0.2){
					object = "tree";
				}
				setTileAt(qq, rr, { type: info.type, ownerId: null, object: object, savings: 0 });
			}
		}
	}
	
	// set tile.neighbours for rendering pools with continuous lines:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		
		if(tile.type === "land"){
			let neigh = getHexNeighbors(q,r);
			let availableNeighbours = [];
			for(let i = 0; i < neigh.length; i++){
				let n = neigh[i];
				const nTile = getTileAt(n.q, n.r);
				if(nTile){
					availableNeighbours.push({tileIndex: nTile.tileIndex, neighbourIndex: i, q: n.q, r: n.r});
				}else{
					availableNeighbours.push({tileIndex: -1, neighbourIndex: i, q: n.q, r: n.r});
				}
			}
			tile.neighbours = availableNeighbours;
		}
	}
	
	// find map actual bounds:
	let minQ = 9999999;
	let maxQ = -9999999;
	let minR = 9999999;
	let maxR = -9999999;
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		if(q < minQ) minQ = q;
		if(q > maxQ) maxQ = q;
		if(r < minR) minR = r;
		if(r > maxR) maxR = r;
	}
	gameState.map.bounds = {q: {min:minQ, max:maxQ}, r: {min:minR, max:maxR}};
	
}

function getMapScale(){
	let scale = getUint(mapScale.value);
	if(scale < 1) scale = 1;
	if(scale > 4) scale = 4;
	return scale;
}

function scaleMap(){
	let scale = getMapScale();
	if(scale == 1){
		return; // dont scale if nothing changes.
	}


	let width = loadedmap.data[0].length;
	let height = loadedmap.data.length;
	let newData = [];
	for(let y = 0; y < height; y++){
		let rowData = [];
		for(let x = 0; x < width; x++){
			let elem = loadedmap.data[y][x];
			for(let i = 0; i < scale; i++){
				rowData.push(elem);
			}
		}
		for(let i = 0; i < scale; i++){
			newData.push(rowData);
		}
	}
	
	loadedmap.width = loadedmap.width*scale;
	loadedmap.height = loadedmap.height*scale;
	loadedmap.tileCount = loadedmap.tileCount*(scale*scale);
	
	loadedmap.data = newData;
	
	
}

// generate_map
function generateMap(width, height) {
	// NOTE: map is loaded before this generateMaps call, so any changes here for the map wont be visible for playes.
	// go to loadParsedMap
	
	width = loadedmap.width;
	height = loadedmap.height;
	

	// NOTE: map is loaded before this generateMaps call, so any changes here for the map wont be visible for playes.
	gameState.settings.mapWidth = width;
	gameState.settings.mapHeight = height;
	
	//loadParsedMap(loadedmap, true);
	
	console.log(`Generating map ${width}x${height}`);
	/*
	// "random" map generator:
	gameState.map.tiles = {};
	
	
	
	// Create a "rhombus" shape of hexes
	for (let q = -Math.floor(width/2); q <= Math.floor(width/2); q++) {
		for (let r = -Math.floor(height/2); r <= Math.floor(height/2); r++) {
			// This creates a rectangle in axial coords
			// We can refine this later
			setTileAt(q, r, { type: 'water', ownerId: null, object: null, savings: 0 });
		}
	}
	
	// Add 15x15 land square in middle
	const landSize = 15;
	const qStart = -Math.floor(landSize/2);
	const rStart = -Math.floor(landSize/2);
	
	for (let q = qStart; q < qStart + landSize; q++) {
		for (let r = rStart; r < rStart + landSize; r++) {
			const tile = getTileAt(q, r);
			if (tile) {
				tile.type = 'land';
			}
			// add random trees:
			if(Math.random() < 0.1){
				tile.object = 'tree';
			}
		}
	}
	*/
	

	// generate outlines for all land pieces in the map:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		let lines = [];
		let neigh = getHexNeighbors(q, r);
		for(let i = 0; i < neigh.length; i++){
			// skip topleft,top,topright neighbours:
			if(i > 1 && i < 5){
				continue;
			}
			let n = neigh[i];
			const nTile = getTileAt(n.q, n.r);
			let addline = 0;
			if (nTile && nTile.type === 'water') {
				addline = 1;
			}
			// if out of bounds, add outlines also:
			if (!nTile){
				addline = 1;
			}
			if(addline){
				lines.push(i);
			}
		}
		setOutlineAt(q, r, lines);
	}  
	
}


function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i
    [array[i], array[j]] = [array[j], array[i]];   // swap elements
  }
  return array;
}



// spawns players on loaded original maps which already has spawn points, just add peasants and claim random player hexes.
function spawnPlayers(){
	let compact = true; // always compact when using original game maps format in loadedmap
	
	let parsedMap = loadedmap;
	
	let width = parsedMap.width;
	let height = parsedMap.height;
	

	let mapOwnerNumbers = {};
	
	// find all possible owners from tiles:
	for (let q = 0, y = 0; q < width; q++, y++) {
		for (let r = 0, x = 0; r < height; r++, x++) {
			let xx = x;
			let yy = y;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info; // {type, object, owner}
				if(compact){
					info = compactToExpandedInfo(parsedMap.data[yy][xx]);
				}else{
					info = parsedMap.data[yy][xx];
				}
				// if owned tile by some player:
				if(info.owner > 0){
					mapOwnerNumbers[info.owner] = info.owner;
				}
			}
		}
	}
	let mapOwners = [];
	for (let owner in mapOwnerNumbers) {
		mapOwners.push(owner);
	}
	
	// randomize and choose a player for each mapOwner:
	mapOwners = shuffle(mapOwners);
	
	const playingPlayers = gameState.players.filter(p => !p.isSpectator);
	


	// set player id's to map owner numbers:
	let mapPlayerToPlayerId = {};
	let extraPlayers = [];
	for(let p = 0, i = 0; p < playingPlayers.length; p++, i++){
		let player = playingPlayers[p];
		//let mapOwner = null; 
		if(i < mapOwners.length){
			mapPlayerToPlayerId[mapOwners[i]] = player.id;
		}else{
			extraPlayers.push(player);
		}
	}
	
	console.warn("mapOwners");
	console.warn(mapOwners);
	console.warn("mapPlayerToPlayerId");
	console.warn(mapPlayerToPlayerId);
	
	// spawn players and claim hexes for them:
	for (let q = 0, y = 0; q < width; q++, y++) {
		let roff = 0;
	
		//for (let r = -Math.floor(height/2), x = 0; r <= Math.floor(height/2); r++, x++) {
		for (let r = 0, x = 0; r < height; r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let xx = x;
			let yy = y;
			let qq = q-roff;
			let rr = r;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info; // {type, object, owner}
				if(compact){
					info = compactToExpandedInfo(parsedMap.data[yy][xx]);
				}else{
					info = parsedMap.data[yy][xx];
				}
				
				if(info.owner){
					let playerId = mapPlayerToPlayerId[info.owner];
					if(playerId){
						let tile = getTileAt(qq, rr);

						setTileOwner(tile, playerId);
						
						if(info.object == "peasant"){
							// unit found
							// no need to remove object, since map format doesnt have object here.
							spawnSoldier(qq, rr, playerId, 'peasant');
							
						}
					}
				}
				
				
			}
		}
	}
	
	// spawn extra players:
	if(extraPlayers.length > 0){
		for(let i = 0; i < extraPlayers.length; i++){
			// find free tile:
			let randomTileIndex;
			do {
				randomTileIndex = random(0, gameState.map.tilesData.length-1);
			} while (gameState.map.tilesData[randomTileIndex].ownerId || gameState.map.tilesData[randomTileIndex].type === "water");
			
			let tile = gameState.map.tilesData[randomTileIndex];
			let qq = tile.q;
			let rr = tile.r;
			
			let playerId = extraPlayers[i].id;
			setTileOwner(tile, playerId);
			setTileAt(qq, rr, {object:null}); // remove object if any.
			spawnSoldier(qq, rr, playerId, 'peasant');
			// TODO: try to claim hex neighbour:
			
		}
	}
	
	
}


function spawnPlayersRandom() {
	const playersToSpawn = gameState.players.filter(p => !p.isSpectator); // && !p.isAI
	let landHexes = [];
	
	// Get all available land hexes
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		
		if (tile.type === 'land') {
			landHexes.push({q, r});
		}
	}

	// Shuffle
	landHexes.sort(() => Math.random() - 0.5);
	
	for (const player of playersToSpawn) {
		let spawnHex = null;
		let neighbors = [];

		// Find a spawn point with at least 4 land neighbors
		let found = false;
		while (!found && landHexes.length > 0) {
			spawnHex = landHexes.pop();
			neighbors = getHexNeighbors(spawnHex.q, spawnHex.r)
				.map(h => ({ ...h, tile: getTileAt(h.q, h.r) }))
				.filter(h => h.tile && h.tile.type === 'land');
			
			if (neighbors.length >= 4) {
				found = true;
			}
		}
		
		if (!found) {
			console.warn(`Could not find ideal spawn for ${player.name}`);
			// Just use the last one we tried
			if (!spawnHex) continue; // No land hexes left?
		}
		
		// Claim center hex
		const centerTile = getTileAt(spawnHex.q, spawnHex.r);
		//centerTile.ownerId = player.id;
		setTileOwner(centerTile, player.id);
		centerTile.object = null;
		centerTile.savings = gameState.settings.startingMoney / 5; // Split money
		
		// Claim 4 neighbors
		let claimedHexes = [];
		for (let i = 0; i < 4; i++) {
			const n = neighbors[i];
			//n.tile.ownerId = player.id;
			setTileOwner(n.tile, player.id);
			n.tile.object = null;
			n.tile.savings = gameState.settings.startingMoney / 5;
			claimedHexes.push(n);
		}
		
		// Add Peasants
		let total_start_units = 2;
		if(claimedHexes.length < total_start_units){
			total_start_units = claimedHexes.length;
		}

		for(let i = 0; i < total_start_units; i++){
			const soldierHex = claimedHexes[i];
			spawnSoldier(soldierHex.q, soldierHex.r, player.id, 'peasant');
		}
	}
	
	console.warn("gameState.units ");
	console.warn(gameState.units);
}

// type = Peasant, Knight, Horse, Dragon
function spawnSoldier(q, r, playerId, type){
	const soldier = {
		// rearranged keys for easier debugging
		id: getUID(),
		ownerId: playerId,
		q: q,
		r: r,
		hasMoved: false,
		type: type,
		level: getSoldierLevel(type),
		internalType: SOLDIER_DATA[type].type,
		ownerIndex: getPlayerIndex(playerId),
	};
	
	gameState.units.push(soldier);
}

function spawnCastle(q, r, playerId, type){
	const castle = {
		// rearranged keys for easier debugging
		id: getUID(),
		ownerId: playerId,
		q: q,
		r: r,
		hasMoved: false,
		type: type,
		level: getCastleLevel(type),
		internalType: CASTLE_DATA[type].type,
		ownerIndex: getPlayerIndex(playerId),
	};
	
	gameState.units.push(castle);
}

function startGame() {

	if (!localPlayer.isHost) return;
	

	console.log("Starting game...");
	
	if (loadedGameState) {
		console.log("Starting from loaded state.");
		gameState = loadedGameState;
		gameState.settings.gameStarted = true;
		
		// Match current players to loaded players
		const newPlayerList = [];
		const loadedPlayers = gameState.players.filter(p => !p.isSpectator);
		
		// Add all current spectators
		for (const p of connections.keys()) {
			const player = getPlayer(p);
			if (player && player.isSpectator) newPlayerList.push(player);
		}
		if (localPlayer.isSpectator) newPlayerList.push(localPlayer);
		
		// Match players
		for (const loadedP of loadedPlayers) {
			// Find a current player who 'took' this name
			const matchingCurrentPlayer = [...gameState.players, localPlayer].find(
				p => p.name === loadedP.name && p.color === loadedP.color && !p.isSpectator
			);
			
			if (matchingCurrentPlayer) {
				// This player takes the slot
				loadedP.id = matchingCurrentPlayer.id; // Assign new PeerID
				newPlayerList.push(loadedP);
			} else {
				// No one took this slot. Mark as AI or disconnected?
				// For now, let's just keep them.
				loadedP.isAI = true; // Mark as AI for now
				newPlayerList.push(loadedP);
			}
		}
		gameState.players = newPlayerList;
		
	} else {
		
		// update gameRoom key for the db, so the game room name will match the start time.
		currentFormattedDate = formatDateForSave();
	
		console.log("Starting new game.");
		// Set settings from inputs
		gameState.settings.mapWidth = parseInt(mapWidthInput.value, 10);
		gameState.settings.mapHeight = parseInt(mapHeightInput.value, 10);
		gameState.settings.startingMoney = parseInt(startMoneyInput.value, 10);
		
		// Filter out players without connection from play (unless they are host or ai):
		gameState.players = gameState.players.filter(p => p.id === localPlayer.id || connections.has(p.id) || p.isAI);
		
		

		// list playing players for colors: (not sure what is this for)
		const playingPlayers = gameState.players.filter(p => !p.isSpectator);
		
		// dont allow starting game without players (crash).
		if(playingPlayers.length == 0){
			return;
		}
		
		// Assign first colors to any uncolored players
		let colorIdx = 0;
		const usedColors = gameState.players.map(p => p.color);
		for (const p of playingPlayers) {
			if (!p.color) {
				while(usedColors.includes(PLAYER_COLORS[colorIdx])) {
					colorIdx++;
				}
				p.color = PLAYER_COLORS[colorIdx];
				usedColors.push(p.color);
			}
		}
		
		gameState.settings.gameStarted = true;
		generateMap(gameState.settings.mapWidth, gameState.settings.mapHeight);
		spawnPlayers();
		
		let myPlayer = getMyPlayer();
		if(myPlayer.isSpectator){
			spectatorUiMode();
		}
		
		// Set initial turn (skips spectators)
		gameState.turn.currentPlayerIndex = getNextPlayerIndex(random(0, gameState.players.length-1));
		gameState.turn.startPlayerIndex = gameState.turn.currentPlayerIndex;
		gameState.turn.turnNumber = 1;
		console.warn("currentPlayerIndex: "+gameState.turn.currentPlayerIndex);
		console.warn("startPlayerIndex: "+gameState.turn.startPlayerIndex);
		//advanceToNextPlayer(); // not sure why this was here, probably because of bugged currentPlayerIndex calculations
	}
	
	
	addCurrentTurnChatMessage();
	
	
	setProtectedTiles();
	
	// Clear undo stack
	currentTurnActions = [];
	

	
	// Broadcast start
	// At the very end of the function, AFTER broadcast('game_start'):
	broadcast({ type: 'game_start', state: gameState });
	checkForAITurn(); // start AI turn if it is his turn.
	
	// Send initial savings to all players
	gameState.players.forEach(p => {
		if (!p.isSpectator) {
			updatePlayerSavings(p.id);
		}
	});
	
	
}



// checks all tiles if they are protected or not.
function setProtectedTiles(){
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		if(tile.type === 'land'){
			if(getUnitAt(q,r)){
				// if unit on tile, set protected
				tile.isProtected = true;
			}else{
				// check if this tile is protected
				tile.isProtected = getShieldLevel(q, r, -1) ? true : false;
			}
		}
	}
}

// safer parseInt so it wont allow any text to cause extreme large values.
function getInt(str) {
	let parsed = str.replace(/[^0-9-]/g, '');
	return (parsed.length > 0) ? parseInt(parsed, 10) : 0;
}

// same but force to unsigned.
function getUint(str) {
	let parsed = str.replace(/[^0-9]/g, '');
	return (parsed.length > 0) ? parseInt(parsed, 10) : 0;
}


document.addEventListener('keydown', (event) => {
	// dont handle enter if it came from chat input.
	if(event.target.id !== 'chat-input'){
	  if (event.key === 'Enter') {
		if(gameState.settings.gameStarted){
			toggleUiTopLeft();
		}
	  }
	}
});

	//if (canvas.contains(e.target)) return; // let the canvas handle it
	
	
function handleOutside(e) {
	if (!buildPopup.contains(e.target) && !buildSoldierBtn.contains(e.target) && !buildCastleBtn.contains(e.target)) {
		if(isBuildPopupOpen()){
			closeBuildPopup();
			return true;
		}
	}
	return false;
}

document.addEventListener('click', handleOutside);
//document.addEventListener('touchstart', handleOutside, { passive: true });


const dirtyInput = document.getElementById('dirty-flag');

// Whenever you want the page to be “dirty” (e.g., game started)
function markDirty() {
	dirtyInput.value = Date.now(); // any change will make the browser consider it modified
}

// When the game ends, you can reset it
function clearDirty() {
	dirtyInput.value = '';
}



window.addEventListener('beforeunload', (e) => {
	if (dirtyInput.value) {
		e.preventDefault();
		e.returnValue = 'Quit game?';
	}
});

window.addEventListener('unload', () => {
	if (peer && !peer.destroyed) {
		peer.destroy();
		navigator.sendBeacon('/peer-disconnect', JSON.stringify({ peerId: peer.id }));
	}
});


// Prevent accidental back navigation
function preventBackNavigation() {
	history.pushState(null, '', location.href);

	window.addEventListener('popstate', function (event) {
		const leave = confirm('Are you sure you want to quit the game?');

		if (leave) {
			// Let them go back by removing the listener
			window.removeEventListener('popstate', arguments.callee);
			//history.back();
			restartGame();
		} else {
			// Re-add the state so back button keeps working
			history.pushState(null, '', location.href);
		}
	});
}

preventBackNavigation();




function unloadGame(){
	// Unload
	loadedGameState = null;
	loadGameBtn.textContent = 'Load Game';
	loadedGameInfoContainer.style.display = 'none';
}


function loadSavedGame(roomName){
	if (loadedGameState) {
		unloadGame();
	} else {
		// Load
		
		// update so it will not create new savegame for this game. uses same date key for db.
		currentFormattedDate = roomName;
		
		loadGameFromDB(roomName, (state) => {
			if (state) {
				loadedGameState = state.gameState;
				console.warn("loadedGameState:");
				console.warn(loadedGameState);
				
				
				//console.log(lobbyLoadedMapImg);
				gameState.settings = loadedGameState.settings;
				//gameState.players = loadedGameState.players;
				gameState.map = loadedGameState.map;
				// update minimap for host:
				loadedMapImg.src = loadedGameState.map.imageData;
				updateHostLobbyUI();

				//console.log(lobbyLoadedMapImg);

				// update state to all players so they see the map loaded etc.
				broadcastLobbyState(loadedGameState.settings, loadedGameState.players, loadedGameState.map);
				
				
				
				loadGameBtn.textContent = 'Unload Game';
				
				loadGameDate.textContent = new Date(state.saveDate).toLocaleString();
				loadGamePlayersList.innerHTML = '';
				state.gameState.players.filter(p => !p.isSpectator).forEach(p => {
					const li = document.createElement('li');
					li.textContent = `${p.name}`;
					li.style.color = p.color;
					li.className = 'loaded-player';
					li.onclick = () => {
						if (li.classList.contains('taken')) return;
						
						// Mark others as not taken
						loadGamePlayersList.querySelectorAll('li').forEach(item => {
							if (item.textContent.endsWith(' (taken)')) {
								const originalName = item.dataset.name;
								const pData = loadedGameState.players.find(lp => lp.name === originalName);
								if (pData) pData.isTaken = false;
								item.textContent = originalName;
								item.classList.remove('taken');
							}
						});
						
						// Take this one
						localPlayer.name = p.name;
						localPlayer.color = p.color;
						playerNameInput.value = p.name;
						localPlayer.isSpectator = false;
						spectateHostBtn.classList.remove('active');
						p.isTaken = true; // Mark in loaded state
						li.textContent = `${p.name} (taken)`;
						li.dataset.name = p.name;
						li.classList.add('taken');
						broadcastLobbyState(); // Update others
					};
					loadGamePlayersList.appendChild(li);
				});
				loadedGameInfoContainer.style.display = 'block';
			} else {
				alert('No saved game found for this room name: '+roomName);
			}
		});
	}
}


function closeBuildPopup(){
	buildPopup.style.display = 'none';
	placingUnit = null;
}


// =================================================================
// --- EVENT LISTENERS
// =================================================================
window.addEventListener('DOMContentLoaded', async () => {
	initDB();

	await loadImages();
	
	hostBtn.disabled = true;
	joinBtn.disabled = true;
	spectateBtn.disabled = true;
	
	// --- Start Page ---
	hostBtn.onclick = hostGame;
	joinBtn.onclick = () => joinGame(false);
	spectateBtn.onclick = () => joinGame(true);
	playerNameInput.onchange = (e) => localPlayer.name = e.target.value;
	


	// --- Host Page ---
	hostRoomPlayerNameInput.onchange = () => {
		localPlayer.name = hostRoomPlayerNameInput.value;
		broadcastLobbyState();
	}
	
	mapWidthInput.onchange = () => {
		gameState.settings.mapWidth = getUint(mapWidthInput.value);
		mapWidthInput.value = gameState.settings.mapWidth;
		broadcastLobbyState();
	}
	mapHeightInput.onchange = () => {
		gameState.settings.mapHeight = getUint(mapHeightInput.value);
		mapHeightInput.value = gameState.settings.mapHeight;
		broadcastLobbyState();
	}

	startMoneyInput.onchange = () => {
		gameState.settings.startingMoney = getUint(startMoneyInput.value);
		startMoneyInput.value = gameState.settings.startingMoney;
		broadcastLobbyState();
	};

	mapScale.onchange = () => {
		gameState.settings.mapScale = getMapScale();
		mapScale.value = gameState.settings.mapScale;
		broadcastLobbyState();
		setLoadedMapAndApplyScale();
	}
	
	spectateHostBtn.onclick = () => {
		localPlayer.isSpectator = !localPlayer.isSpectator;
		localPlayer.color = localPlayer.isSpectator ? SPECTATOR_COLOR : PLAYER_COLORS[0];
		spectateHostBtn.classList.toggle('active', localPlayer.isSpectator);
		broadcastLobbyState();
	};
	
	/*
	// async needed here for await to work for getMostRecentSave()
	loadGameBtn.onclick = async () => {
		if (loadedGameState) {
			// Unload
			loadedGameState = null;
			loadGameBtn.textContent = 'Load Game';
			loadedGameInfoContainer.style.display = 'none';
		} else {
			// Load
			let mostRecentSave = await getMostRecentSave();
			console.log("mostRecentSave: "+mostRecentSave);
			
			const roomName = mostRecentSave;//gameNameInput.value;
			loadGameFromDB(roomName, (state) => {
				if (state) {
					loadedGameState = state.gameState;
					console.warn("loadedGameState:");
					console.warn(loadedGameState);
					
					
					//console.log(lobbyLoadedMapImg);
					gameState.settings = loadedGameState.settings;
					gameState.players = loadedGameState.players;
					gameState.map = loadedGameState.map;
					// update minimap for host:
					loadedMapImg.src = loadedGameState.map.imageData;
					updateHostLobbyUI();

					//console.log(lobbyLoadedMapImg);

					// update state to all players so they see the map loaded etc.
					broadcastLobbyState(loadedGameState.settings, loadedGameState.players, loadedGameState.map);
					
					
					
					loadGameBtn.textContent = 'Unload Game';
					loadGameDate.textContent = new Date(state.saveDate).toLocaleString();
					loadGamePlayersList.innerHTML = '';
					state.gameState.players.filter(p => !p.isSpectator).forEach(p => {
						const li = document.createElement('li');
						li.textContent = `${p.name}`;
						li.style.color = p.color;
						li.className = 'loaded-player';
						li.onclick = () => {
							if (li.classList.contains('taken')) return;
							
							// Mark others as not taken
							loadGamePlayersList.querySelectorAll('li').forEach(item => {
								if (item.textContent.endsWith(' (taken)')) {
									const originalName = item.dataset.name;
									const pData = loadedGameState.players.find(lp => lp.name === originalName);
									if (pData) pData.isTaken = false;
									item.textContent = originalName;
									item.classList.remove('taken');
								}
							});
							
							// Take this one
							localPlayer.name = p.name;
							localPlayer.color = p.color;
							playerNameInput.value = p.name;
							localPlayer.isSpectator = false;
							spectateHostBtn.classList.remove('active');
							p.isTaken = true; // Mark in loaded state
							li.textContent = `${p.name} (taken)`;
							li.dataset.name = p.name;
							li.classList.add('taken');
							broadcastLobbyState(); // Update others
						};
						loadGamePlayersList.appendChild(li);
					});
					loadedGameInfoContainer.style.display = 'block';
				} else {
					alert('No saved game found for this room name: '+roomName);
				}
			});
		}
	};
	*/
	
	startGameBtn.onclick = startGame;
	
	// --- Lobby Page ---
	lobbyPlayerNameInput.onchange = (e) => {
		localPlayer.name = e.target.value;
		sendToHost({
			type: 'player_update',
			name: localPlayer.name,
			color: localPlayer.color
		});
	};
	
	// --- Game Page ---
	window.onresize = resizeCanvas;
	canvas.addEventListener('wheel', handleWheel, { passive: false });
	canvas.addEventListener('mousedown', handleCanvasMouseDown);
	canvas.addEventListener('mousemove', handleCanvasMouseMove);
	canvas.addEventListener('mouseup', handleCanvasMouseUp);
	canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
	canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
	canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
	
	
	refreshCanvasBtn.onclick = () => {
		resizeCanvas();	
	};

	quitGameBtn.onclick = () => {
		restartGame();
	};

	toggleUiBtn.onclick = () => {
		toggleUiTopLeft();
	};
	
	chatInput.onkeydown = (e) => {
		// enter key "enter"
		if (e.key === 'Enter') {
			toggleUiTopLeft(false);
			if(chatInput.value.trim() !== ''){
				sendToHost({ type: 'chat', message: chatInput.value.trim() });
				chatInput.value = '';
			}
		}
	};
	
	buildSoldierBtn.onclick = () => openBuildPopup('soldier');
	buildCastleBtn.onclick = () => openBuildPopup('castle');
	buildPopupClose.onclick = () => {
		closeBuildPopup();
	};
	
	endTurnBtn.onclick = () => {
		if (!endTurnBtn.disabled && isMyTurn()) {
			sendToHost({ type: 'action_end_turn' });
		}
	};
	
	undoBtn.onclick = () => {
		if (isMyTurn()) {
			sendToHost({ type: 'action_undo' });
			updateGameUI();
		}
	};
	
	sellUnitBtn.onclick = () => {
		if (isMyTurn()) {
			console.log("action_sell");
			console.log(selectedUnit);
			if(selectedUnit){
				sendToHost({ type: 'action_sell', unitId: selectedUnit.id });
				selectedUnit = null; // Deselect
				selectedHex = null;
				console.log("Deselected unit");
			}
		}
	};
	
	initPeerJS();
	

	console.log("DOMContentLoaded finished");
});


</script>



</body>
</html>
